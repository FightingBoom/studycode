

# 第1章 计算机系统漫游

hello world 程序



## 1.1 信息就是位 + 上下文

基本思想：系统中所有的信息 包括磁盘文件、内 存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。区 分不同数据对象的唯 方法是我们读到这些数据对象时的上下文 比如，在不同的上下文 中，一个同样的字节序列可能表示一个整数 浮点数、字符串或者机器指令。



## 1.2 程序被其他程序翻译成不同的格式

![image-20250420174021935](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202504211008449.png)



- 预处理阶段。预处理器 cpp ，替换 `#` 开头的预处理命令到当前源码文件，生成 *.i 文件。
- 编译阶段。编译器 ccl ，将 *.i 翻译成文本文件 *.s 。
- 汇编阶段。汇编器 as 。
- 链接阶段。链接器 ld 。



## 1.3 了解编译系统如何工作是大有益处的

原因：

- 优化程序性能。
- 理解链接时出现的错误。
- 避免安全漏洞。
    - 学习安全编程的第一步就是理解数据和控制信息存 储在程序栈上的方式会引起的后果。



## 1.4 处理器读并解释存储在内存中的指令

如果该命令不是内置的 shell 命令，那 shell 会假设这是一个可执行文件的名字。



### 1.4.1 系统的硬件组成

![image-20250422081939796](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202504220819874.png)



1. 总线

贯穿整个系统的是一组电子管道，称作总线，它携带信息字节并负责在各个部件间传 递。通常总线被设计成传送定长的字节块，也就是宇 (word) 。



2. I/O 设备（输入/输出）

每个 I/0 设备都通过一个控制器或适配器与 总线相连。功能都是在 I/O 总线和 I/O 设备之间传递信息。区别在于：

- 控制器：是 I/O 设备本身或者系统的主板上的芯片组。
- 适配器：则是一块插在主板插槽上的卡。



3. 主存

物理上：由动态随机存取存储器（DRAM）芯片组成。

逻辑上：存储器是一个线性的字节数组，每个字节都有其唯一的地址（数组索引）。



4. 处理器

中央处理单元（CPU），简称处理器，是解释（或执行）存储在主存中指令的引擎。



### 1.4.2 运行 hello 程序

在键盘上输入字符串后，会先将字符逐一读入寄存器，再存放到内存中。



按下回车后，认为输入结束，开始从磁盘中复制到主存。

如果使用直接存储器存取（DMA），数据可以不通过处理器，而直接从磁盘到达主存。



当目标文件被加载到主存后，处理器开始执行程序，会依次将字符传从主存复制到寄存器文件，再从寄存器文件中复制到显示设备，最终显示到屏幕上。



## 1.5 高速缓存至关重要

这个简单的示例揭示了一个重要的问题，即系统花费了大量的时间把信息从一个地方挪到另一个地方。

从程序员的角度来看，这些复制就是开销，减慢了程序“真正”的工作



根据机械原理，较大的存储设备要比较小的存储设备运行得慢，而快速设备的造价远高于同类的低速设备。

加快处理器的运行速度比加快主存的运行速度要容易和便宜得多。



高速缓存存储器（cache memory ，简称为 cache 或高速缓存）。

L1 和 L2 高速缓存是用一种叫做静态随机访问存储器（SRAM）的硬件技术实现的。



![image-20250423082609357](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202504230826469.png)



本书结论：意识到高速缓存存储器存在的应用程序员能够利用高速缓存将程序的性能提高一个数量级。



## 1.6 存储设备形成层次结构

![image-20250424081538744](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202504240815879.png)



存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。



## 1.7 操作系统管理硬件

操作系统有两个基本功能：

（1）防止硬件被失控的应用程序滥用；

（2）向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。

操作系统通过几个基本的抽象概念（进程、虚拟内存和文件）来实现这两个功能。



Posix 标准。



### 1.7.1 进程

进程是操作系统对一个正在运行的程序的一种抽象。



并发运行：一个进程的指令和另一个进程的指令是交错执行的。



无论是在单核还是多核系统中，一个CPU看上去都像是在并发地执行多个进程，这是通过处理器在进程间切换来实现的。操作系统实现这种交错执行的机制称为上下文切换。



从一个进程到另一个进程的转换是由操作系统内核（kernel）管理的。

内核不是一个独立的进程。相反，它是系统管理全部进程所用代码和数据结构的集合。



### 1.7.2 线程

现代系统，一个进程实际上可以有多个线程组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。



### 1.7.3 虚拟内存

地址从低到高，依次介绍：

- 程序代码和数据。
- 堆。
- 共享库。
- 栈。
- 内核虚拟内存。



虚拟内存的一个基本思想是：把一个进程虚拟内存的内容存储在磁盘上，然后用主存作为磁盘的高速缓存。



### 1.7.4 文件

文件就是字节序列。



## 1.8 系统之间利用网络通信

hello 示例，利用 telnet 在远端服务器执行，并在当前终端返回结果。



## 1.9 重要主题

### 1.9.1 Amdahl 定律

该定律的主要 思想是，当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要 性和加速程度。



Amdahl 定律的主要观点：要想显著加速整个系统，必须提升全系统中相当大的部分的速度。



### 1.9.2 并发和并行

并发，concurrency

并行，parallelism



1. 线程级并发

超线程，hyperthreading

别称：同时多线程，simultaneous multi-threading



![image-20250508081045867](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202505080810996.png)



多处理器的使用，可以从两个方面提高系统性能

- 减少了在执行多个任务时模拟并发的需要。
- 可以使应用程序运行得更快。



2. 指令级并行

在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为指令级并行。



流水线，pipelining

在 流水线中，将执行一条指令所需要的活动划分成不同的步骤，将处理器的硬件组织成一系 列的阶段，每个阶段执行一个步骤。这些阶段可以并行地操作，用来处理不同指令的不同 部分。



超标量处理器（super-scalar），指处理器达到比一个周期一条指令更快的执行速率。



3. 单指令、多数据并行

在最低层次上，许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执 行的操作，这种方式称为单指令、多数据，即 SIMD 并行。



### 1.9.3 计算机系统中抽象的重要性

抽象的使用是计算机科学中最为重要的概念之一。



计算机系统中的一个重大主题就是提供不同层次的抽象表示，来隐藏实际实现的复杂性。



文件是对 I/0 设备的抽象，虚拟内存是对 程序存储器的抽象，而进程是对一个正在运行的程序的抽象。虚拟机，它提供对整个计算机的抽象，包括操作系统、处理器和程序。



## 1.10 小结

计算机系统由硬件和系统软件组成，共同协作以运行应用程序。



# 第一部分 —— 程序结构和执行



# 第2章 信息的表示和处理



无符号，unsigned

补码，two's-complement

浮点数，floating-point



整数的表示是精确的；浮点数的表示只是近似的。



## 2.1 信息存储

虚拟内存（virtual memory ）。

虚拟内存空间（virtual memory space）。

虚拟地址空间只是一个 机器级程序的概念性映像 实际的实现（见第 章）是将动 态随机访问存储器 DRAM 、闪存、磁盘存储器、特 硬件和 作系统软件结合起来，为程序提供一个看上去统一的字节数组。



指针包括值和类型。

- 值表示某个对象的位置；
- 类型表示那个位置上所存储对象的类型；



### 2.1.1 十六进制表示法

十六进制表示法：0x / 0X 开头。



### 2.1.2 字数据大小

64 位机器一般可以兼容运行 32 位程序，反之则不可以。



C99 提供了新的数据类型 int32_t / int64_t ，他们分别是 4 字节和 8 字节，是固定的，不随编译器和机器设置而变化。



有疑问，下边的几种形式，怎么是一样的意思？long int 没理解。。

```c
unsigned long
unsigned long int
long unsigned
long unsigned int
```



### 2.1.3 寻址和字节顺序

小端法，小端传输，little endian

大端法，大端传输，big endian



![image-20250518222914869](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202505182229078.png)



直接用 man 命令就可以查看 ASCII 表

```shell
man ascii
```

![image-20250518223207205](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202505182232330.png)



### 2.1.4 表示字符串

Unicode 联合会（Unicode Consortium）



### 2.1.5 表示代码

不同的机器类型使用不同的且不兼容的指令和编码方式。即使是完全一样的进程，运行在不同的操作系统上也会有不同的编码规则，因此二进制代码是不兼容的。二进制代码很少能在不同机器和操作系统组合之间移植。



### 2.1.6 布尔代数简介

布尔代数（Boolean algebra）

布尔环（Boolean ring）



### 2.1.7 C语言中的位级运算

| 就是 OR( 或），＆就是 AND( 与），～就是 NOT( 反），而＾就是 EXCLUSIVE-OR( 异或）。



### 2.1.8 C语言中的逻辑运算

逻辑运算符 || 、&& 、! ，注意与位运算的差异。

逻辑运算符＆＆和 II 与它们对应的位级运算＆和 之间第二个重要的区别是，如果对 第一个参数求值就能确定表达式的结果，那么逻辑运算符就不会对第二个参数求值。



### 2.1.9 C语言中的移位运算

移位运算是从左至右可结合的，x << j << k == (x << j) << k。



对于有符号数使用算数右移；对于无符号数，右移必须是逻辑的。



Java 对于如何进行右移有明确的定义。表达是 x>>k 会将 x 算术右移 k 个位置，而 x>>>k 会对 x 做逻辑右移。



加法（和减法）的优先级比移位运算要高，注意结合性问题。



## 2.2 整数表示

![image-20250623222235445](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202506232222966.png)



### 2.2.1 整数数据类型

有符号数，负数的范围比正数的范围大 1 。



C 和 C++ 都支持有符号（默认）和无符号数。Java 只支持有符号数。



### 2.2.2 无符号数的编码

B2U~w~（Binary to Unsigned 缩写，长度为 w）



原理：无符号数编码的定义



原理：无符号数编码的唯一性



### 2.2.3 补码编码

B2T~w~（Binary to Two's-complement）



书中这个补码示例图很有意思，之前从没这样想过。

![image-20250629104659979](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202506291047145.png)

由上述图片，就可以发现为啥 负数范围比正数的范围大 1 了。

1000 0000，-128

0111 1111，127



PRId32 / PRIu64

使用宏可以保证：不论代码是如何被编译的，都能生成正确的格式字符串。



正数数据类型的取值范围和表示，Java 标准非常明确，要求采用补码表示。单字节数据类型称为 byte ，而不是 char 。



### 2.2.4 有符号数和无符号数之间的转换

```c++
short int v = -12345;
unsigned short uv = (unsigned short)v;
printf("v = %d, uv = %u\n", v, uv);
```

![image-20250702082314033](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202507020823103.png)



### 2.2.5 C 语言中的有符号数与无符号数

大多数数字都默认为是有符号的。如果要创建一个无符号常量，必须加上后缀字符 U / u ;



注意最小值的写法，-2147483647-1 ，并不是 -2147483648 或 0 ，因为 limits.h 头文件中有类似写法；



### 2.2.6 扩展一个数字的位表示

要将一个无符号数转换为一个更大的数据类型，只需要在表示的开头添加 0 即可，这种运算被称为零扩展（zero extension）



















