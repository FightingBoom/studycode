

# 第1章 计算机系统漫游

hello world 程序



## 1.1 信息就是位 + 上下文

基本思想：系统中所有的信息 包括磁盘文件、内 存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。区 分不同数据对象的唯 方法是我们读到这些数据对象时的上下文 比如，在不同的上下文 中，一个同样的字节序列可能表示一个整数 浮点数、字符串或者机器指令。



## 1.2 程序被其他程序翻译成不同的格式

![image-20250420174021935](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202504211008449.png)



- 预处理阶段。预处理器 cpp ，替换 `#` 开头的预处理命令到当前源码文件，生成 *.i 文件。
- 编译阶段。编译器 ccl ，将 *.i 翻译成文本文件 *.s 。
- 汇编阶段。汇编器 as 。
- 链接阶段。链接器 ld 。



## 1.3 了解编译系统如何工作是大有益处的

原因：

- 优化程序性能。
- 理解链接时出现的错误。
- 避免安全漏洞。
    - 学习安全编程的第一步就是理解数据和控制信息存 储在程序栈上的方式会引起的后果。



## 1.4 处理器读并解释存储在内存中的指令

如果该命令不是内置的 shell 命令，那 shell 会假设这是一个可执行文件的名字。



### 1.4.1 系统的硬件组成

![image-20250422081939796](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202504220819874.png)



1. 总线

贯穿整个系统的是一组电子管道，称作总线，它携带信息字节并负责在各个部件间传 递。通常总线被设计成传送定长的字节块，也就是宇 (word) 。



2. I/O 设备（输入/输出）

每个 I/0 设备都通过一个控制器或适配器与 总线相连。功能都是在 I/O 总线和 I/O 设备之间传递信息。区别在于：

- 控制器：是 I/O 设备本身或者系统的主板上的芯片组。
- 适配器：则是一块插在主板插槽上的卡。



3. 主存

物理上：由动态随机存取存储器（DRAM）芯片组成。

逻辑上：存储器是一个线性的字节数组，每个字节都有其唯一的地址（数组索引）。



4. 处理器

中央处理单元（CPU），简称处理器，是解释（或执行）存储在主存中指令的引擎。



### 1.4.2 运行 hello 程序

在键盘上输入字符串后，会先将字符逐一读入寄存器，再存放到内存中。



按下回车后，认为输入结束，开始从磁盘中复制到主存。

如果使用直接存储器存取（DMA），数据可以不通过处理器，而直接从磁盘到达主存。



当目标文件被加载到主存后，处理器开始执行程序，会依次将字符传从主存复制到寄存器文件，再从寄存器文件中复制到显示设备，最终显示到屏幕上。



## 1.5 高速缓存至关重要

这个简单的示例揭示了一个重要的问题，即系统花费了大量的时间把信息从一个地方挪到另一个地方。

从程序员的角度来看，这些复制就是开销，减慢了程序“真正”的工作



根据机械原理，较大的存储设备要比较小的存储设备运行得慢，而快速设备的造价远高于同类的低速设备。

加快处理器的运行速度比加快主存的运行速度要容易和便宜得多。



高速缓存存储器（cache memory ，简称为 cache 或高速缓存）。

L1 和 L2 高速缓存是用一种叫做静态随机访问存储器（SRAM）的硬件技术实现的。



![image-20250423082609357](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202504230826469.png)



本书结论：意识到高速缓存存储器存在的应用程序员能够利用高速缓存将程序的性能提高一个数量级。



## 1.6 存储设备形成层次结构

![image-20250424081538744](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202504240815879.png)



存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。



## 1.7 操作系统管理硬件

操作系统有两个基本功能：

（1）防止硬件被失控的应用程序滥用；

（2）向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。

操作系统通过几个基本的抽象概念（进程、虚拟内存和文件）来实现这两个功能。



Posix 标准。



### 1.7.1 进程

进程是操作系统对一个正在运行的程序的一种抽象。



并发运行：一个进程的指令和另一个进程的指令是交错执行的。



无论是在单核还是多核系统中，一个CPU看上去都像是在并发地执行多个进程，这是通过处理器在进程间切换来实现的。操作系统实现这种交错执行的机制称为上下文切换。



从一个进程到另一个进程的转换是由操作系统内核（kernel）管理的。

内核不是一个独立的进程。相反，它是系统管理全部进程所用代码和数据结构的集合。



### 1.7.2 线程

现代系统，一个进程实际上可以有多个线程组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。



### 1.7.3 虚拟内存

地址从低到高，依次介绍：

- 程序代码和数据。
- 堆。
- 共享库。
- 栈。
- 内核虚拟内存。



虚拟内存的一个基本思想是：把一个进程虚拟内存的内容存储在磁盘上，然后用主存作为磁盘的高速缓存。



### 1.7.4 文件

文件就是字节序列。



## 1.8 系统之间利用网络通信

hello 示例，利用 telnet 在远端服务器执行，并在当前终端返回结果。



## 1.9 重要主题

### 1.9.1 Amdahl 定律

该定律的主要 思想是，当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要 性和加速程度。



Amdahl 定律的主要观点：要想显著加速整个系统，必须提升全系统中相当大的部分的速度。



### 1.9.2 并发和并行

并发，concurrency

并行，parallelism



1. 线程级并发

超线程，hyperthreading

别称：同时多线程，simultaneous multi-threading



![image-20250508081045867](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202505080810996.png)



多处理器的使用，可以从两个方面提高系统性能

- 减少了在执行多个任务时模拟并发的需要。
- 可以使应用程序运行得更快。



2. 指令级并行

在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为指令级并行。



流水线，pipelining

在 流水线中，将执行一条指令所需要的活动划分成不同的步骤，将处理器的硬件组织成一系 列的阶段，每个阶段执行一个步骤。这些阶段可以并行地操作，用来处理不同指令的不同 部分。



超标量处理器（super-scalar），指处理器达到比一个周期一条指令更快的执行速率。



3. 单指令、多数据并行

在最低层次上，许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执 行的操作，这种方式称为单指令、多数据，即 SIMD 并行。



### 1.9.3 计算机系统中抽象的重要性

抽象的使用是计算机科学中最为重要的概念之一。



计算机系统中的一个重大主题就是提供不同层次的抽象表示，来隐藏实际实现的复杂性。



文件是对 I/0 设备的抽象，虚拟内存是对 程序存储器的抽象，而进程是对一个正在运行的程序的抽象。虚拟机，它提供对整个计算机的抽象，包括操作系统、处理器和程序。



## 1.10 小结

计算机系统由硬件和系统软件组成，共同协作以运行应用程序。



# 第一部分 —— 程序结构和执行



# 第2章 信息的表示和处理



无符号，unsigned

补码，two's-complement

浮点数，floating-point



整数的表示是精确的；浮点数的表示只是近似的。



## 2.1 信息存储

虚拟内存（virtual memory ）。

虚拟内存空间（virtual memory space）。

虚拟地址空间只是一个 机器级程序的概念性映像 实际的实现（见第 章）是将动 态随机访问存储器 DRAM 、闪存、磁盘存储器、特 硬件和 作系统软件结合起来，为程序提供一个看上去统一的字节数组。



指针包括值和类型。

- 值表示某个对象的位置；
- 类型表示那个位置上所存储对象的类型；



### 2.1.1 十六进制表示法

十六进制表示法：0x / 0X 开头。



### 2.1.2 字数据大小

64 位机器一般可以兼容运行 32 位程序，反之则不可以。



C99 提供了新的数据类型 int32_t / int64_t ，他们分别是 4 字节和 8 字节，是固定的，不随编译器和机器设置而变化。



有疑问，下边的几种形式，怎么是一样的意思？long int 没理解。。

```c
unsigned long
unsigned long int
long unsigned
long unsigned int
```



### 2.1.3 寻址和字节顺序

小端法，小端传输，little endian

大端法，大端传输，big endian



![image-20250518222914869](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202505182229078.png)



直接用 man 命令就可以查看 ASCII 表

```shell
man ascii
```

![image-20250518223207205](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202505182232330.png)



### 2.1.4 表示字符串

Unicode 联合会（Unicode Consortium）



### 2.1.5 表示代码

不同的机器类型使用不同的且不兼容的指令和编码方式。即使是完全一样的进程，运行在不同的操作系统上也会有不同的编码规则，因此二进制代码是不兼容的。二进制代码很少能在不同机器和操作系统组合之间移植。



### 2.1.6 布尔代数简介

布尔代数（Boolean algebra）

布尔环（Boolean ring）



### 2.1.7 C语言中的位级运算

| 就是 OR( 或），＆就是 AND( 与），～就是 NOT( 反），而＾就是 EXCLUSIVE-OR( 异或）。



### 2.1.8 C语言中的逻辑运算

逻辑运算符 || 、&& 、! ，注意与位运算的差异。

逻辑运算符＆＆和 II 与它们对应的位级运算＆和 之间第二个重要的区别是，如果对 第一个参数求值就能确定表达式的结果，那么逻辑运算符就不会对第二个参数求值。



### 2.1.9 C语言中的移位运算

移位运算是从左至右可结合的，x << j << k == (x << j) << k。



对于有符号数使用算数右移；对于无符号数，右移必须是逻辑的。



Java 对于如何进行右移有明确的定义。表达是 x>>k 会将 x 算术右移 k 个位置，而 x>>>k 会对 x 做逻辑右移。



加法（和减法）的优先级比移位运算要高，注意结合性问题。



## 2.2 整数表示

![image-20250623222235445](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202506232222966.png)



### 2.2.1 整数数据类型

有符号数，负数的范围比正数的范围大 1 。



C 和 C++ 都支持有符号（默认）和无符号数。Java 只支持有符号数。



### 2.2.2 无符号数的编码

B2U~w~（Binary to Unsigned 缩写，长度为 w）



原理：无符号数编码的定义



原理：无符号数编码的唯一性



### 2.2.3 补码编码

B2T~w~（Binary to Two's-complement）



书中这个补码示例图很有意思，之前从没这样想过。

![image-20250629104659979](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202506291047145.png)

由上述图片，就可以发现为啥 负数范围比正数的范围大 1 了。

1000 0000，-128

0111 1111，127



PRId32 / PRIu64

使用宏可以保证：不论代码是如何被编译的，都能生成正确的格式字符串。



正数数据类型的取值范围和表示，Java 标准非常明确，要求采用补码表示。单字节数据类型称为 byte ，而不是 char 。



### 2.2.4 有符号数和无符号数之间的转换

```c++
short int v = -12345;
unsigned short uv = (unsigned short)v;
printf("v = %d, uv = %u\n", v, uv);
```

![image-20250702082314033](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202507020823103.png)



### 2.2.5 C 语言中的有符号数与无符号数

大多数数字都默认为是有符号的。如果要创建一个无符号常量，必须加上后缀字符 U / u ;



注意最小值的写法，-2147483647-1 ，并不是 -2147483648 或 0 ，因为 limits.h 头文件中有类似写法；



### 2.2.6 扩展一个数字的位表示

要将一个无符号数转换为一个更大的数据类型，只需要在表示的开头添加 0 即可，这种运算被称为零扩展（zero extension）



### 2.2.7 截断数字

原理：截断无符号数



原理：截断补码数值



### 2.2.8 关于有符号数与无符号数的建议

有符号数到无符号数的隐式强制类型转换导致了某些非直观的 行为。而这些非直观的特性经常导致程序错误，并且这种包含隐式强制类型转换的细微差 别的错误很难被发现。



> 练习题 2.25

如下代码，直接运行会出现断错误。原因在于 length 为 0 ，再减一，就发生了隐式类型转换。

![image-20250705103135894](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202507051031323.png)



## 2.3 整数运算

问题一：两个正数相加，会得出一个负数；

问题二：比较表达式 x < y 和比较表达式 x - y < 0 会产生不同的结果；



### 2.3.1 无符号加法

两个 unsigned short 类型相加，其和需要一个 unsigned int 来存储。



正常情况下 x+y 的值保持不变，而溢出情况则是该和数减去 2^w^ 的结果。



### 2.3.2 补码加法

原理：补码加法



原理：检测补码加法中的溢出



### 2.3.3 补码的非

 C 语言中，我们 可以说，对于任意整数值 x, 计算表达式 -x 和 ~x+1 得到的结果完全一样。



### 2.3.4 无符号乘法

C 语言中的无符号乘法被定义为产生 w 位的值。



### 2.3.5 补码乘法

原理：无符号和补码乘法的位级等价性



### 2.3.6 乘以常数

大多数机器，整数乘法指令运行非常慢，可能需要 10 个或者更多时钟周期。

因此，编译器考虑使用移位和加法运算的组合来代替乘以常数因子的乘法。



原理：乘以 2 的幂

原理：与 2 的幂相乘的无符号乘法

原理：与 2 的幂相乘的补码乘法



```c
x * 14
14 = 2^3 + 2^2 + 2^1 = 2^4 - 2^1
x * 14 = (x << 3) + (x << 2) + (x << 1)
x * 14 = (x << 4) - (x << 1)
```



### 2.3.7 除以 2 的幂

在大多数机器上，整数除法比整数乘法更慢，可能需要 30 个或者更多的时钟周期。



除以 2 的幂，也可以用移位来实现，但是是右移。



原理：除以 2 的幂的无符号除法

原理：除以 2 的幂的补码除法，向下舍入



偏置（biasing）



原理：除以 2 的幂的补码除法，向上舍入



### 2.3.8 关于整数运算的最后思考

我们特别看到了 unsigned 数据类型，虽然它概念上很简 单，但可能导致即使是资深程序员都意想不到的行为。我们还看到这种数据类型会以出乎 意料的方式出现，比如，当书写整数常数和当调用库函数时。



## 2.4 浮点数

IEEE 标准 754 ，表示浮点数及其运算的标准。



### 2.4.1 二进制小数

二进制小数点向左移动一位，相当于这个数被 2 除。

二进制小数点向右移动一位，相当于将该数乘 2 。



### 2.4.2 IEEE 浮点表示

IEEE 浮点标准

- 符号（sign）
- 尾数（significand）
- 阶码（exponent）



规格化的值：E = e - Bias



非规格化的值：E = 1 - Bias

逐渐溢出



特殊值

NaN（Not a Number）



### 2.4.3 数字示例

IEEE 格式如此设计，就是为了浮点数能够使用整数排序函数来进行排序。



### 2.4.4 舍入

舍入（rounding）



IEEE 浮点格式定义了四种不同的舍入方式，默认的方法是找到最接近的匹配，而其他三种可用于计算上界和下界。

- 向偶数舍入
- 向零舍入
- 向下舍入
- 向上舍入



### 2.4.5 浮点运算

阿贝尔群，这又是啥？



### 2.4.6 C语言中的浮点数

当在int、float和double格式之间进行强制类型转换时，程序改变数值和位模式的原则如下（假设int是32位的）：

- 从int转换成float，数字不会溢出，但是可能被舍人入。
- 从int 或float转换成double，因为double有更大的范围（也就是可表示值的范围），也有更高的精度（也就是有效位数），所以能够保留精确的数值。
- 从double转换成float，因为范围要小一些，所以值可能溢出成+∞或一∞。另外，由于精确度较小，它还可能被舍人。
- 从float 或者double转换成int，值将会向零舍入。例如，1.999将被转换成1，而一1.999将被转换成—1。进一步来说，值可能会溢出。C语言标准没有对这种情况指定固定的结果。与Intel兼容的微处理器指定位模式[10··00]（字长为w时的TMin）为整数不确定（ （integer  indefinite）值。一个从浮点数到整数的转换，如果不能为该浮点数找到一个合理的整数近似值，就会产生这样一个值。因此，表达式（int）+le10会得到—21483648，即从一个正值变成了一个负值。



## 2.5 小结

编码为位。

64 位程序优势就是可以突破 32 位程序 4GB 地址空间的限制。



# 第3章 程序的机器级表示

逆向工程（reverse engineering）



## 3.1 历史观点

1978年，8086，29K 晶体管，x86

1980年，8087，浮点协处理器，x87



Pentium 4E，2004年，125M 晶体管，增加了超线程（hyperthreading），还增加了 EM64T ，它是 Intel AMD 提出的对 IA32 64 位扩展的实现，我们称之为 x86-64 。



## 3.2 程序编码

-Og 告诉编译器使用会生成符合原始 代码整体结构的机 器代码的优化等级。使用较高级别优化产生的代码会严重变形，以至于产生的机器代码和 初始源代码之间的关系非常难以理解。



### 3.2.1 机器级代码

指令集体系结构或指令集架构（Instruction Set Architecture, ISA），来定义机器级程序的格式和行为。



第二种抽象是，机器级程 序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。



### 3.2.2 代码示例

编译时，加上 -S 选项，就能看到 C 语言编译器产生的汇编代码。



GDB 可以看二进制文件反汇编之后的字节数据

```shell
(gdb) x/14xb multstore
```



反汇编器：objdump



### 3.2.3 关于格式的注解

所有以 . 开头的行，都是指导汇编器和链接器工作的伪指令。



条件码（condition code）

PF，parity flag（奇偶标志）



在 C 语言中，可以用 asm 的伪指令，包含简短的汇编代码。



## 3.3 数据格式

![image-20250727164228280](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202507271642414.png)



## 3.4 访问信息

x86-64 的 CPU ，包含一组 16 个存储 64 位值的通用目的寄存器。



### 3.4.1 操作数指示符

不同的操作数的可能性被分为三种类型。

- 立即数（immediate），用来表示常数值。
- 寄存器（register），表示某个寄存器的内容。
- 内存引用，它会根据计算出来的地址（通常称为有效地址）访问某个内存位置。



### 3.4.2 数据传送指令

指令类，MOV 类





### 3.4.3 数据传送示例

```c
long exchange(long *xp, long y)
{
    long x = *xp;
    *xp = y;
    return x;
}
```



### 3.4.4 压入和弹出栈数据

栈，是一种数据结构，遵循先进后出/后进先出的原则。



x86-64 中， 栈向低地址方向增长，所以压栈是减小栈指针（寄存器 %rsp) 的值，并将数据存放到 内存中，而出栈是从内存中读数据，并增加栈指针的值

![image-20250727165939236](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202507271704496.png)



## 3.5 算术和逻辑操作

指令类，以 ADD 加法为例，有字节加法、字加法、双字加法和四字加法。

操作被分为四组：加载有效地址、一元操作、二元操作和移位。



### 3.5.1 加载有效地址

加载有效地址（load effective address）



### 3.5.2 一元和二元操作

第一个操作数 可以是立即数、寄存器或是内存位置。第二个操作数可以是寄存器或是内存位置。注意， 当第二个操作数为内存地址时，处理器必须从内存读出值，执行操作，再把结果写回



### 3.5.3 移位操作

移位量可以是一个立即数，或者放在单字节寄存器 cl 中。



### 3.5.4 讨论

只有右移操作要求区分有符号和无符号数。



### 3.5.5 特殊的算术操作

IMUL 指令类



## 3.6 控制

直线代码的行为：指令一条接着一条顺序地执行。



jump 指令可以改变一组机器代码指令的执行顺序。



### 3.6.1 条件码

条件码（condition code）

- CF: 进位标志。最近的操作使最高位产生了进位。可用来检查无符号操作的溢出
- ZF: 零标志。最近的操作得出的结果为
- SF: 符号标志。最近的操作得到的结果为负数。
- OF: 溢出标志。最近的操作导致一个补码溢出 正溢出或负溢出



### 3.6.2 访问条件码

条件码常用的使用方法有三种：

- 可以根据条件码的某种组合， 将一个字节设置为 或者 1
- 可以条件跳转到程序的某个其他的部分
- 可以有条件地 传送数据。



同义名（synonym）



### 3.6.3 跳转指令

正常情况，指令是一条一条顺序执行。跳转（jump）会切换到程序中一个全新的位置。



### 3.6.4 跳转指令的编码

PC相对的（PC-relative）



### 3.6.5 用条件控制来实现条件分支

使用 goto 语句通常认为是一种不好的编程风格，因为它会使代码非常难以阅读和调试。



### 3.6.6 用条件传送来实现条件分支

实现条件操作的传统方法是通过使用控制的条件转移 。

一种替代的策略是使用数据的条件转移。



处理器采用非常精密的分支预测逻辑来猜测每条跳转指令是否会执行。



即使许多分支预测错误的开销会超 过更复杂的计算， GCC 还是会使用条件控制转移。



### 3.6.7 循环

do-while / while / for



### 3.6.8 switch语句

和使用一 组很长的 if-else 语句相比，使用跳转表的优点是执行开关语句的时间与开关情况的数量无关。



## 3.7 过程

过程是软件中一种很重要的抽象。

- 传递控制
- 传递数据
- 分配和释放内存



### 3.7.1 运行时栈

后进先出。



为了提高空间和时间效率，x86-64 过程只分配自己所需要的栈帧部分。



### 3.7.2 转移控制

程序计数器（PC）



call Q，该指令会把地址 A 压入栈中，并将 PC 设置为 Q 的起始地址。压入的地址 A 被称为返回地址，是紧跟在 call 指令后的那条指令的地址。



### 3.7.3 数据传送

![image-20250813103930522](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202508131039932.png)



### 3.7.4 栈上的局部存储

局部数据必须存放在内存中的常见情况如下：

- 寄存器不足够存放所有的本地数据；
- 对一个局部变量使用地址运算符 '&' ，因此必须能够为它产生一个地址；
- 某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到；



### 3.7.5 寄存器中的局部存储空间

寄存器组是唯一被所有过程共享的资源。



### 3.7.6 递归过程

每个过程调用在栈中都有它自己的私有空间，因此多个未完成调用的局部变量不会相互影响。



## 3.8 数组分配和访问

C语言一个特点就是可以产生指向数组中元素的指针，并对这些指针进行运算。



### 3.8.1 基本原则

数组，指针数组。



### 3.8.2 指针运算

C语言允许对指针进行运算，而计算出来的值会根据该指针引用的数据类型的大小进行伸缩。



Expr 与 * &Expr 是等价的。



### 3.8.3 嵌套的数组

创建数组时，数组分配和引用的一般原则也是成立的。

```c
int A[5][3];

// 等价于下列声明
typedef int row3_t[3];
row3_t A[5];
```



### 3.8.4 定长数组

良好的编程习惯：用常数作为数组的维度或者缓冲区的大小时，最好通过 # define 声明定义一个别名，后续都操作该名字。



### 3.8.5 变长数组

ISO C99 引入了一种功能，允许数组的维度是表达式，在数组被分配的时候才计算出来。



### 3.9 异质的数据结构

结构（structure），用关键字 struct 来声明；

联合（union），用关键字 union 来声明；



### 3.9.1 结构

结构的所有组成部分都存放在内存中一段连续的区域内，而指向结构的指针就是结构第一个字节的地址。



```c
struct rec
{
    int i;
    int j;
    int a[2];
    int *p;
};
```

如上结构内存分布如下图：

![image-20250817182546910](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202508171825483.png)



### 3.9.2 联合

```c
// 
struct S3
{
    char c;
    int i[2];
    double v;
};

// 
union U3
{
    char c;
    int i[2];
    double v;
};
```

如上结构体、联合体定义，x86-64 Linux 机器，内存偏移位置如下：

![image-20250817183123833](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202508171831939.png)



在结构体其他字段，与联合的元素之间，需要有 4 个字节的填充，所以 v 的起始地址是 16 ，而不是 12 。



对于有较多字段的数据结构，使用结构体 + 联合，可以节省很多内存空间。



### 3.9.3 数据对齐

对齐原则是任何 K 字节的基本对象的地址必须是 K 的倍数。



对于大多数 x86-64 指令，保持数据对齐能够提高效率，但是不会影响程序的行为。



## 3.10 在机器级程序中将控制与数据结合起来



### 3.10.1 理解指针

指针和映射到机器代码的关键原则

- 每个指针都对应一个类型。void * 类型代表通用指针。
- 每个指针都有一个值。
- 指针用 '&' 运算符创建。
- *操作符用于间接引用指针。间接引用是用内存引用来实现的，要么是存储到一个指定的地址，要么是从指定的地址读取。
- 数组与指针紧密联系。
- 将指针从一种类型强制转换成另一种类型，只改变它的类型，而不改变它的值。
- 指针也可以指向函数。



函数指针示例如下

```c
int (*f)(int*);

// *f 两侧的括号是必须的，否则会被解释为一个函数原型
int *f(int*);
// 声明了一个函数 f ，它以一个 int * 作为参数并返回一个 int *
(int *) f(int*);
```



### 3.10.2 应用：使用 GDB 调试器

用 objdump 获取程序的反汇编版本。



GDB 部分命令示例如下

![image-20250827100609576](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202508271006737.png)



DDD：是 GDB 的一个扩展，提供了图形用户界面。



### 3.10.3 内存越界引用和缓冲区溢出

对越界的数组元素的写操作会破坏存储在栈中的状态信息。



缓冲区溢出（buffer overflow）。



很多常用的库函数，包括 strcpy / strcat / sprintf 都不需要告诉它们目标缓冲区的大小，就产生一个字节序列，这样就很容易导致缓冲区溢出漏洞。



攻击代码（exploit code）



蠕虫（worm）可以自己运行，并且能够将自己的等效副本传播到其他机器。

病毒（virus）能将自己添加到包括操作系统在内的其他程序中，但它不能独立运行。



### 3.10.4 对抗缓冲区溢出攻击

1. 栈随机化

安全单一化（security monoculture）

栈随机化的思想使得栈的位置在程序每次运行时都有变化。

地址空间布局随机化（Address-Space Layout Randomization），简称 ASLR 。



nop ，读作 no op ，no operatioin 的缩写。



空操作雪橇（nop sled）



2. 栈破坏检测

栈保护者机制，stack protector



3. 限制可执行代码区域



### 3.10.5 支持变长栈帧

%rbp / base pointer 基指针。



## 3.11 浮点代码

处理器的浮点体系结构包括多个方面

- 如何存储和访问浮点数值。通常是通过某种寄存器方式来完成。
- 对浮点数据操作的指令。
- 向函数传递浮点数参数和从函数返回浮点数结果的规则。
- 函数调用过程中保存寄存器的规则。



### 3.11.1 浮点传送和转换操作

GCC 只用标量传送操作从内存传送数据到 XMM 寄存器，或从 XMM 寄存器传送数据到内存。



aligned（对齐的）



把浮点值转换成整数时，指令会执行截断（truncation），把值向 0 进行舍入。



### 3.11.2 过程中的浮点代码

x86-64 中，XMM 寄存器用来向函数传递浮点参数，以及从函数返回浮点值。



### 3.11.3 浮点运算操作

AVX2 浮点指令。



### 3.11.4 定义和使用浮点常数

AVX 浮点操作不能以立即数值作为操作数。相反，编译器必须为所有的常量值分配和初始化存储空间。然后代码再把这些值从内存读入。



### 3.11.5 在浮点代码中使用位级操作

GCC 生成的代码会在 XMM 寄存器上执行位级操作，得到有用的浮点结果。



### 3.11.6 浮点比较操作

浮点比较指令会设置三个条件码：零标志位 ZF 、进位标志位 CF 和奇偶标志位 PF 。

对于整数 操作，当最近的一次算术或逻辑运算产生的值的最低位字节是偶校验的（即这个字节中有 偶数个 1)，那么就会设置这个标志位。不过对于浮点比较，当两个操作数中任一个是 NaN 时，会设置该位。根据惯例，C 语言中如果有个参数为 NaN， 就认为比较失败了，这个标志位就被用来发现这样的条件。



当任一操作数为 NaN 时，就会出现无序的情况。



### 3.11.7 对浮点代码的观察结论

用 AVX2 为浮点数上的操作产生的机器代码风格类似于为整数上的操作产生的代码风格。



## 3.12 小结

及时编译（just-in-time compilation）



# 第4章 处理器体系结构

指令集体系结构（Instruction-Set Architecture, ISA）



为什么还需要了解处理器设计？

- 从智力方面来说，处理器设计是非常有趣而且很重要的。
- 理解处理器如何工作能帮助理解整个计算机系统如何工作。
- 虽然很少有人设计处理器，但是许多人设计包含处理器的硬件系统。
- 你的工作可能就是处理器设计。



HCL（Hardware Control Language，硬件控制语言）



## 4.1 Y86-64 指令集体系结构



### 4.1.1 程序员可见的状态

内存从概念上来说就是一个很大的字节数组，保存着程序和数据。



程序状态的最后一个部分是状态码 Stat ，它表明程序执行的总体状态。



### 4.1.2 Y86-64 指令

movq 、整数操作指令、跳转指令、条件传送指令等 



### 4.1.3 指令编码

第一个字节表明指令的类型。高四位是代码部分，低四位是功能部分。



寄存器指示符字节（register specifier byte）

常数字（constant word）



指令集的一个重要性质就是字节编码必须有唯一的解释。任意一个字节序列要么是一个唯一的指令序列的编码，要么就不是一个合法的字节序列。



复杂指令集计算机，CISC

精简指令集计算机，RISC



ARM，Acorn RISC Machine 缩写



### 4.1.4 Y86-64 异常

AOK / HLT / ADR / INS 



### 4.1.5 Y86-64 程序

汇编器伪指令（assembler directives）

```c
long sum(long *start, long count)
{
    long sum = 0;
    while (count)
    {
        sum += *start;
        start++;
        count--;
    }
    return sum;
}
```



### 4.1.6 一些 Y86-64 指令的详情

pushq 指令会把栈指针减 8, 并且将一个寄存器值写入内存中。因此，当执行 pushq %rsp 指令时，处理器的行为是不确定的，因为要入栈的寄存器会被同一条指令修改。通 常有两种不同的约定： 1) 压入 %rsp 的原始值， 2) 压入减去 %rsp 的值。



## 4.2 逻辑设计和硬件控制语言 HCL

HCL（Hardware Control Language，硬件控制语言）

HDL（Hardware Description Language，硬件描述语言）



逻辑合成（logic synthesis）



### 4.2.1 逻辑门

逻辑门总是活动的（active）。一旦一个门的输入变化了，在很短的时间内，输出就会相应地变化。



### 4.2.2 组合电路和 HCL布尔表达式

将很多逻辑门组合成一个网，就能构建计算块（computational block），称为组合电路（combinational circuits）。

- 每个逻辑门的输入必须连接到下述选项之一：
    - 一个系统输入（称为主输入）
    - 某个存储器单元的输出；
    - 某个逻辑门的输出；
- 两个或多个逻辑门的输出不能连接在一起。否则它们可能会使线上的信号矛盾，可能会导致一个不合法的电压或电路故障；
- 这个网必须是无环的。也就是在网中不能有路径经过一系列的门而形成一个回路，这样的回路会导致该网络计算的函数有歧义。



多路复用器（multiplexor，通常称为“MUX”）



### 4.2.3 字级的组合电路和 HCL 整数表达式

非门（inverters）

情况表达式（case expression）



算数/逻辑单元（ALU）是一种很重要的组合电路。



### 4.2.4 集合关系

在处理器设计中，很多时候都需要将一个信号与许多可能匹配的信号做比较，以此来 检测正在处理的某个指令代码是否属于某一类指令代码。



### 4.2.5 存储器和时钟

时序电路（sequential circuit）



时钟寄存器（简称寄存器），存储单个位或字。时钟信号控制寄存器加载输入值。

随机访问存储器（简称内存），存储多个字，用地址来选择该读或该写哪个字。



为避免歧义，在说到硬件和机器级编程时，会用硬件寄存器、程序寄存器来区分。



## 4.3 Y86-64 的顺序实现

SEQ（sequential，顺序的）



### 4.3.1 将处理组织成阶段

- 取指（fetch）
- 译码（decode）
- 执行（execute）
- 访存（memory）
- 写回（write back）
- 更新 PC （PC update）



### 4.3.2 SEQ 硬件结构

硬件单元（hardware units）



### 4.3.3 SEQ 的时序

SEQ 的实现包括组合逻辑和两种存储器设备：时钟寄存器（程序计数器和条件码寄存 器），随机访问存储器（寄存器文件、指令内存和数据内存）



原则：从不回读



### 4.3.4 SEQ 阶段的实现

还是之前几个阶段做的事情，结合图示，更加详细了

1. 取指阶段
2. 译码和写回阶段
3. 执行阶段
4. 访存阶段
5. 更新 PC 阶段



## 4.4 流水线的通用原理

流水线化的特性

-  提高了系统的吞吐量（throughput）
- 轻微地增加延迟（latency）



### 4.4.1 计算流水线

微微秒/皮秒（picosecond，简写成 ps ）

流水线图（pipeline diagram）

流水线寄存器（pipeline register）



### 4.4.2 流水线操作的详细说明

波阵面（curved wavefront）

减缓时钟不会影响流水线的行为。



### 4.4.3 流水线的局限性

1. 不一致的划分

运行时钟的速率是由最慢的阶段的延迟限制的。



2. 流水线过深，收益反而下降



### 4.4.4 带反馈的流水线系统

数据相关（data dependency）

控制相关（control dependency）



## 4.5 Y86-64 的流水线实现



### 4.5.1 SEQ+：重新安排计算阶段

电路重定时（circuit retiming）



### 4.5.2 插入流水线寄存器

流水线寄存器按如下方式标号：

- F ：保存程序计数器的预测值；
- D ：位于取指和译码阶段之间。保存关于最新取出的指令的信息，即将由译码阶段进行处理；
- E ：位于译码和执行阶段之间。保存关于最新译码的指令和从寄存器文件读出的值的信息，即将由执行阶段进行处理；
- M ：位于执行和访存阶段之间。保存最新执行的指令的结果，即将由访存阶段进行处理。还保存关于用于处理条件转移的分支条件和分支目标的信息；
- W ：位于访存阶段和反馈路径之间，反馈路径将计算出来的值提供给寄存器文件写，而当完成 ret 指令时，还要向 PC 选择逻辑提供返回地址。



### 4.5.3 对信号进行重新排列和标号

在命名系统中，大写的前缀 "D" "E" "M" "W" 指的是流水线寄存器，所 _ stat 指的是流水线寄存器 的状态码宇段。 小写的 前缀"£"、 "cl" "e" "m "w" 的是流水线阶段，所以 m _ stat 的是在访存阶段中由控制逻辑块产生出的 状态信号。



### 4.5.4 预测下一个 PC

流水线化设计的目的就 是每个时钟周期都发射一条新指令，也就是说每个时钟周期都有一条新指令进入执行阶段并 最终完成。



我们的设计使用，总是选择（always taken）分支的预测策略。



### 4.5.5 流水线冒险

两种相关

- 数据相关，下一条指令会用到这一条指令计算出的结果；
- 控制相关，一条指令要确定下一条指令的位置，例如在执行跳转、调用或返回指令时；



冒险 hazard

- 数据冒险，data hazard
- 控制冒险，control hazard



1. 用暂停来避免数据冒险

暂停（stalliing）



2. 用转发来避免数据冒险

数据转发，data forwarding ，或简称转发，又是称为旁路（bypassing）



3. 加载/使用数据冒险

加载/使用冒险（load/use hazard）

可能存在需要的数据，在下个周期才生产出来的问题，此时就可以加一个气泡。

这种用暂停来处理加载/使用冒险的方法称为加载互锁（load interlock）。



4. 避免控制冒险

预测跳转指令会选择分支。

指令排除（instruction squashing）



### 4.5.6 异常处理

我们的指令集体系结构包括三种不同的内部产生的异常： 1) halt 指令， 2) 有非法指 令和功能码组合的指令， 3) 取指或数据读写试图访问一个非法地址。



异常指令（excepting instruction）

异常处理程序（exception handler）



基本原则是：由流水线中最深的指令引起的异常，优先级最高。



### 4.5.7 PIPE 各阶段的实现

1. PC 选择和取指阶段

在取指阶段，可以测 试由于指令地址越界引起的内存错误，还可以发现非法指令或 halt 指令。必须推迟到访存阶段才能发现非法数据地址。



2. 译码和写回阶段



3. 执行阶段



4. 访存阶段





### 4.5.8 流水线控制逻辑

加载/使用冒险

处理 ret

预测错误的分支

异常



复位配置（reset configuration）

形式化验证（formal verification）

逻辑合成（logic synthesis）





### 4.5.9 性能分析

CPI，Cycles Per Instruction，每指令周期数。



### 4.5.10 未完成的工作

1. 多周期指令
2. 与存储系统的接口

高速缓存，cache

翻译后备缓冲器，translation Look-aside Buffer，TLB

缺页，page fault



## 4.6 小结

指令集体系结构



# 第5章 优化程序性能

妨碍优化的因素，optimization blocker

指令级并行，instruction-level parallelism

代码剖析程序，profiler

关键路径，critical path



## 5.1 优化编译器的能力和局限性

虽然对于大多数使用 GCC 的软件项目来说，优化级别 -O2 已经成为 了被接受的标准，但是还是主要考虑以优化级别 -O1 编译出的代码。



内存别名使用，memory aliasing

内联函数替换，inline substitution，简称内联，inlining



## 5.2 表示程序性能

每元素的周期数，Cycles Per Element，CPE

循环展开，loop unrolling

最小二乘拟合，least squares fit



最终关心的是：对于给定的向量长度，程序运行的速度如何。



## 5.3 程序示例

魔术，black art



简单地 使用命令行选项 "-O1", 就会进行一些基本的优化 正如可以看到的，程序员不需要做什 么，就会显著地提高程序性能 ~超过两个数量级。通常，养成至少使用这个级别优化的 习惯是很好的。（使用 -Og 优化级别能得到相似的性能结果。）



## 5.4 消除循环的低效率

代码移动，code motion

识别要执行多次（例如在循环里）但是计算结果不会改变的计算。



渐进低效率，asymptotic inefficiency



## 5.5 减少过程调用

循环中多次调用相同的函数之类的。



## 5.6 消除不必要的内存引用

把结果累积在临时变量中。将累积值存放在局部变最 ace( 累积器 (a cc umulator) 的简写）中， 消除了每次循环迭代中从内存中读出并将更新值写回的需要。



等最后临时变量一次读完之后，再统一写回内存中。



## 5.7 理解现代处理器

随着试图进一步提高性能，必须考虑利用处理器微体系结构的优化，也就是处理器用来执行指令的底层系统设计。



延迟界限，latency bound

吞吐量界限，throughput bound



### 5.7.1 整体操作

超标量，superscalar，可以在每个时钟周期执行多个操作，而且是乱序的。

乱序，out-of-order，指令执行的顺序不一定要与它们在机器级程序中的顺序一致。

按序，in-order



控制单元，Instruction Control Unit，ICU

执行单元，Execution Unit，EU

前者负责 从内存中读出指令序列，并根据这些指令序列生成一组针对程序数据的基本操作；而后者 执行这些操作。



指令高速缓存，instruction cache

分支预测，branch prediction

投机执行，speculative execution

数据高速缓存，data cache

退役单元，retirement unit

寄存器重命名，register renaming



### 5.7.2 功能单元的性能

延迟，latency，表示完成运算所需要的总时间；

发射时间，issue time，表示两个连续的同类型的运算之间需要的最小时钟周期数；

容量，capacity，表示能够执行该运算的功能单元的数量；



阶段，stage

完全流水线化的，fully pipelined



### 5.7.3 处理器操作的抽象模型

数据流，data-flow

关键路径，critical path



1. 从机器级代码到数据流图
2. 其他性能因素



## 5.8 循环展开

循环展开是一种程序变换，通过增加每次迭代计算的元素的数量，减少循环的迭代次数。



> 编译器可以很容易地执行循环展开。只要优化级别设置得足够高，许多编译器都能 例行公事地做到这一点。用优化等级 或更高等级调用 GCC, 它就会执行循环展开。



## 5.9 提高并行性

程序的性能是受运算单元的延迟限制的。



### 5.9.1 多个累积变量

对于一个可结合和可交换的合并运算来说，比如说整数加法或乘法，我们可以通过将一组合并运算分割成两个或更多的部分，并在最后 合并结果来提高 性能 。



### 5.9.2 重新结合变换

重新结合变换，reassociation transformation 

SSE 指令，Streaming SIMD Extensions，流 SIMD 扩展的缩写

高级向量扩展，advanced vector extension，或 AVX



## 5.10 优化合并代码的结果小结

CPE 从最开始的 10.xx 提高到了 1 左右。

![image-20251029090806993](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202510290908424.png)



## 5.11 一些限制因素

功能单元的吞吐量界限也是程序执行时间的一个下界。



### 5.11.1 寄存器溢出

溢出，spilling



### 5.11.2 分支预测和预测错误处罚

指令流水线化，instruction pipelining

投机执行，speculative execution



那么一个 C。语言程序员怎么能够保证分支预测处罚不会阻碍程序的效率呢？通用原则

1. 不要过分关心可预测的分支
2. 书写适合用条件传送实现的代码



## 5.12 理解内存性能

高速缓存，cache



### 5.12.1 加载的性能

一个包含加载操作的程序的性能既依赖于流水线的能力，也依赖千加载单元的延迟。



### 5.12.2 存储的性能

加载操作的函数，就是从内存位置读到寄存器中。



## 5.13 应用：性能提高技术

优化程序性能的基本策略：

1. 高级设计。
2. 基本编码原则

- 消除连续的函数调用。
- 消除不必要的内存引用。

3. 低级优化



## 5.14 确认和消除性能瓶颈

代码剖析程序，code profiler

系统优化的通用原则，Amdahl 定律，Amdahl's law



### 5.14.1 程序剖析

程序剖析，profiling

基准数据，benchmark data

间隔计数，interval counting



Unix 提供了一个剖析程序 GPROF ，有如下属性值得注意：

- 计时不是很准确；
- 假如没有执行内联替换，则调用信息相当可靠；
- 默认情况下，不会显示对库函数的计时；



### 5.14.2 使用剖析程序来指导优化

渐近性能，asymptotic performance



## 5.15 小结

 Linux 系统 基本 上都有的 VALGRIND 。这 些工具 可以在过程级分斛 执行时间，估计程序每个基 本块 (basic block) 性能。（基本 块是内部没有 控制 转移的指令序列，因此基本块总是整个被执行的。）



# 第6章 存储器层次结构

存储器系统，memory system



如果你的程序需要的数据 存储 PU 寄存器中的，那么在指令的执行期间，在 个周期内就能访问到它们。如果存储在高速缓存中，需要 4~7 个周期 如果存储在主存 中，需要上百个周期。而如果存储在磁 上，需要大约几千万个周期！



局部性，locality

存储器山，memory mountain



## 6.1 存储技术

计算机技术的成功很大程度上源自千存储技术的巨大进步。



### 6.1.1 随机访问存储器

随机访问存储器，Random-Access Memory，RAM

分为两类：静态的和动态的，静态 RAM (SRAM) 比动态 RAM (DRAM) 更快，但也贵得多。



1. 静态 RAM

SRAM 将每个位存储在一个双稳态的 (bistable) 存储器单元里。每个单元是用一个六 晶体管电路来实现的。

![image-20251104085911803](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202511040859080.png)

由千 SRAM 存储器单元的双稳态特性，只要有电，它就会永远地保持它的值。即使 有干扰（例如电 子噪 音）来扰乱电压，当干扰消除时，电路就会恢复到稳定值。



2. 动态 RAM

DRAM 将每个位存储为对 个电容的充电。

![image-20251104090234260](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202511040902425.png)



3. 传统的 DRAM

内存控制器，memory controller

行地址 i 称为 RAS ，Row Access Strobe，行访问选通脉冲

列地址 j 称为 CAS ，Column Access Strobe，列访问选通脉冲



4. 内存模块

内存模块，memory module

双列直插内存模块，Dual Inline Memory Module，DIMM



5. 增强的 DRAM

- 快页模式 DRAM ，Fast Page Mode DRAM, FPM DRAM
- 扩展数据输出 DRAM，Extended Data Out DRAM，EDO DRAM
- 同步 DRAM ，Synchronous DRAM，SDRAM
- 双倍数据速率同步 DRAM ，Double Data-Rate Synchronous DRAM，DDR SDRAM
- 视频 RAM ，Video RAM，VRAM



6. 非易失性存储器

PROM(Programmable ROM, 可编程 ROM) 只能被编程一次。 PROM 的每个存储器 单元有 种熔丝 (fuse), 只能用高电流熔断一次

可擦写可编程 ROM(Erasable Programmable ROM, EPROM) 有一个透明的石英窗 口，允许光到达存储单元。

电子可擦除 PROM (Electrically Erasable  PROM, EEPROM) 类似于 EPROM, 但是它不需要一个物理上独立的编程设备，因此可 以直接在印制电路卡上编程。 EEPROM 能够被编程的次数的数量级可以达到 10 次。



固态硬盘，Solid State Disk，SSD



7. 访问主存



### 6.1.2 磁盘存储

1. 磁盘构造

2. 磁盘容量

- 记录密度
- 磁道密度
- 面密度

3. 磁盘操作

4. 逻辑磁盘块



> 格式化的磁盘容量
>
> 磁盘控制器必须对磁盘进行格式化，然后才能在该磁盘上存储数据 格式化包括用 标识扇区的信息填写扇区之间的间隙，标识出表面有故障的柱面并且不使用它们，以及 在每个区中预留出一组柱面作为备用，如果区中一个或多个柱面在磁盘使用过程中坏掉 了，就可以使用这些备用的柱面 因为存在着这些备用的柱面，所以磁盘制造商所说的 格式化容量比最大容量要小



5. 连接 I/O 设备

6. 访问磁盘

PCie 是一组高速串行、通过开关连接的点到点链路，最大吞吐率为 16GB/s 。



### 6.1.3 固态硬盘

闪存翻译层，flash translation layer



### 6.1.4 存储技术趋势

不同的存储技术有不同的价格和性能折中。

不同存储技术的价格和性能属性以截然不同的速率变化着。



## 6.2 局部性

局部性原理，principle of locality

- 时间局部性，temporal locality
- 空间局部性，spatial locality



有良好局部性的程序比局部性差的程序运行得更快。



### 6.2.1 对程序数据引用的局部性

步长为 1 的引用模式，顺序引用模式，sequential reference pattern



### 6.2.2 取指令的局部性

代码区别千程序数据的一个重要属性是在运行时它是不能被修改的。当程序正在执行 CPU 只从内存中读出它的指令。 CPU 很少会重写或修改这些指令。



### 6.2.3 局部性小结

简单原则：

- 复引用相同变量的程序有良好的时间局部性。
- 对千具有步长为 的引用模式的程序，步长越小，空间局部性越好。具有步长为 的引用模式的程序有很好的空间局部性。在内存中以大步长跳来跳去的程序空间局 部性会很差。
- 对千取指令来说，循环有好的时间和空间局部性。循环体越小，循环迭代次数越 多，局部性越



## 6.3 存储器层次结构

![image-20251122092338364](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202511220923542.png)



### 6.3.1 存储器层次结构中的缓存

1. 缓存命中，cache hit
2. 缓存不命中，cache miss

3. 缓存不命中的种类

4.缓存管理



### 6.3.2 存储器层次结构概念小结

- 利用时间局部性
- 利用空间局部性



## 6.4 高速缓存存储器

L1，大概 4 个时钟周期

L2 ，大概 10 个时钟周期

L3 ，大概 50 个时钟周期



### 6.4.1 通用的高速缓存存储器组织结构

考虑一个计算机系统，其中每个存储器地址有 位，形成 M= 沪个不同的地址。



### 6.4.2 直接映射高速缓存

每个组只有一行的高速缓存，称为直接映射高速缓存



### 6.4.3 组相联高速缓存

最不常使用 (Least-Frequently-Used, LFU) 策略会替换在过去某个时间窗口内引用次数最少的那一行。最近最少使用 (LeastRecently-Used, LRU) 策略会替换最后一次访问时间 久远的那一行。



### 6.4.4 全相联高速缓存

全相联高速缓存，fully associative cache



### 6.4.5 有关写的问题

直写，write-through

写回，write-back



### 6.4.6 一个真实的高速缓存层次结构的解剖

高速缓存即保存数据，也保存指令。



### 6.4.7 高速缓存参数的性能影响

指标如下：

- 不命中率，miss rate
- 命中率，hit rate
- 命中时间，hit time
- 不命中处罚，miss penalty



## 6.5 编写高速缓存友好的代码

从具有良好局部性的 义上来说，好的程序员总是应该试着去编写高速缓存友 (cache friendly) 的代码。

- 让最常见的情况运行得快
- 尽量减小每个循环内部的缓存不命中数量



编写高速缓存友好的代码的重要问题

- 对局部变 量的反复 引用是好的，因为编译器能够将它们 缓存在寄存器文 件中（时间 局部性）
- 步长为 的引用模式是好的，因为存储器层次结构中所有层次上的缓存都是将数据 存储为连续的块（空间局部性）。



## 6.6 综合：高速缓存对程序性能的影响

### 6.6.1 存储器山

一个程序从存储系统中读数据的速率称为读吞吐量 (read throughput), 或者有时称为 读带宽 (read bandwidth) 。



存储器山，memory mountain















