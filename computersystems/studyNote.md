

# 第1章 计算机系统漫游

hello world 程序



## 1.1 信息就是位 + 上下文

基本思想：系统中所有的信息 包括磁盘文件、内 存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。区 分不同数据对象的唯 方法是我们读到这些数据对象时的上下文 比如，在不同的上下文 中，一个同样的字节序列可能表示一个整数 浮点数、字符串或者机器指令。



## 1.2 程序被其他程序翻译成不同的格式

![image-20250420174021935](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202504211008449.png)



- 预处理阶段。预处理器 cpp ，替换 `#` 开头的预处理命令到当前源码文件，生成 *.i 文件。
- 编译阶段。编译器 ccl ，将 *.i 翻译成文本文件 *.s 。
- 汇编阶段。汇编器 as 。
- 链接阶段。链接器 ld 。



## 1.3 了解编译系统如何工作是大有益处的

原因：

- 优化程序性能。
- 理解链接时出现的错误。
- 避免安全漏洞。
    - 学习安全编程的第一步就是理解数据和控制信息存 储在程序栈上的方式会引起的后果。



## 1.4 处理器读并解释存储在内存中的指令

如果该命令不是内置的 shell 命令，那 shell 会假设这是一个可执行文件的名字。



### 1.4.1 系统的硬件组成

![image-20250422081939796](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202504220819874.png)



1. 总线

贯穿整个系统的是一组电子管道，称作总线，它携带信息字节并负责在各个部件间传 递。通常总线被设计成传送定长的字节块，也就是宇 (word) 。



2. I/O 设备（输入/输出）

每个 I/0 设备都通过一个控制器或适配器与 总线相连。功能都是在 I/O 总线和 I/O 设备之间传递信息。区别在于：

- 控制器：是 I/O 设备本身或者系统的主板上的芯片组。
- 适配器：则是一块插在主板插槽上的卡。



3. 主存

物理上：由动态随机存取存储器（DRAM）芯片组成。

逻辑上：存储器是一个线性的字节数组，每个字节都有其唯一的地址（数组索引）。



4. 处理器

中央处理单元（CPU），简称处理器，是解释（或执行）存储在主存中指令的引擎。



### 1.4.2 运行 hello 程序

在键盘上输入字符串后，会先将字符逐一读入寄存器，再存放到内存中。



按下回车后，认为输入结束，开始从磁盘中复制到主存。

如果使用直接存储器存取（DMA），数据可以不通过处理器，而直接从磁盘到达主存。



当目标文件被加载到主存后，处理器开始执行程序，会依次将字符传从主存复制到寄存器文件，再从寄存器文件中复制到显示设备，最终显示到屏幕上。



## 1.5 高速缓存至关重要

这个简单的示例揭示了一个重要的问题，即系统花费了大量的时间把信息从一个地方挪到另一个地方。

从程序员的角度来看，这些复制就是开销，减慢了程序“真正”的工作



根据机械原理，较大的存储设备要比较小的存储设备运行得慢，而快速设备的造价远高于同类的低速设备。

加快处理器的运行速度比加快主存的运行速度要容易和便宜得多。



高速缓存存储器（cache memory ，简称为 cache 或高速缓存）。

L1 和 L2 高速缓存是用一种叫做静态随机访问存储器（SRAM）的硬件技术实现的。



![image-20250423082609357](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202504230826469.png)



本书结论：意识到高速缓存存储器存在的应用程序员能够利用高速缓存将程序的性能提高一个数量级。



## 1.6 存储设备形成层次结构

![image-20250424081538744](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202504240815879.png)



存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。



## 1.7 操作系统管理硬件

操作系统有两个基本功能：

（1）防止硬件被失控的应用程序滥用；

（2）向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。

操作系统通过几个基本的抽象概念（进程、虚拟内存和文件）来实现这两个功能。



Posix 标准。



### 1.7.1 进程

进程是操作系统对一个正在运行的程序的一种抽象。



并发运行：一个进程的指令和另一个进程的指令是交错执行的。



无论是在单核还是多核系统中，一个CPU看上去都像是在并发地执行多个进程，这是通过处理器在进程间切换来实现的。操作系统实现这种交错执行的机制称为上下文切换。



从一个进程到另一个进程的转换是由操作系统内核（kernel）管理的。

内核不是一个独立的进程。相反，它是系统管理全部进程所用代码和数据结构的集合。



### 1.7.2 线程

现代系统，一个进程实际上可以有多个线程组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。



### 1.7.3 虚拟内存

地址从低到高，依次介绍：

- 程序代码和数据。
- 堆。
- 共享库。
- 栈。
- 内核虚拟内存。



虚拟内存的一个基本思想是：把一个进程虚拟内存的内容存储在磁盘上，然后用主存作为磁盘的高速缓存。



### 1.7.4 文件

文件就是字节序列。



## 1.8 系统之间利用网络通信

hello 示例，利用 telnet 在远端服务器执行，并在当前终端返回结果。



## 1.9 重要主题

### 1.9.1 Amdahl 定律

该定律的主要 思想是，当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要 性和加速程度。



Amdahl 定律的主要观点：要想显著加速整个系统，必须提升全系统中相当大的部分的速度。



### 1.9.2 并发和并行

并发，concurrency

并行，parallelism



1. 线程级并发

超线程，hyperthreading

别称：同时多线程，simultaneous multi-threading



![image-20250508081045867](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202505080810996.png)



多处理器的使用，可以从两个方面提高系统性能

- 减少了在执行多个任务时模拟并发的需要。
- 可以使应用程序运行得更快。



2. 指令级并行

在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为指令级并行。



流水线，pipelining

在 流水线中，将执行一条指令所需要的活动划分成不同的步骤，将处理器的硬件组织成一系 列的阶段，每个阶段执行一个步骤。这些阶段可以并行地操作，用来处理不同指令的不同 部分。



超标量处理器（super-scalar），指处理器达到比一个周期一条指令更快的执行速率。



3. 单指令、多数据并行

在最低层次上，许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执 行的操作，这种方式称为单指令、多数据，即 SIMD 并行。



### 1.9.3 计算机系统中抽象的重要性

抽象的使用是计算机科学中最为重要的概念之一。



计算机系统中的一个重大主题就是提供不同层次的抽象表示，来隐藏实际实现的复杂性。



文件是对 I/0 设备的抽象，虚拟内存是对 程序存储器的抽象，而进程是对一个正在运行的程序的抽象。虚拟机，它提供对整个计算机的抽象，包括操作系统、处理器和程序。



## 1.10 小结

计算机系统由硬件和系统软件组成，共同协作以运行应用程序。



# 第一部分 —— 程序结构和执行



# 第2章 信息的表示和处理



无符号，unsigned

补码，two's-complement

浮点数，floating-point



整数的表示是精确的；浮点数的表示只是近似的。



## 2.1 信息存储

虚拟内存（virtual memory ）。

虚拟内存空间（virtual memory space）。

虚拟地址空间只是一个 机器级程序的概念性映像 实际的实现（见第 章）是将动 态随机访问存储器 DRAM 、闪存、磁盘存储器、特 硬件和 作系统软件结合起来，为程序提供一个看上去统一的字节数组。



指针包括值和类型。

- 值表示某个对象的位置；
- 类型表示那个位置上所存储对象的类型；



### 2.1.1 十六进制表示法

十六进制表示法：0x / 0X 开头。



### 2.1.2 字数据大小

64 位机器一般可以兼容运行 32 位程序，反之则不可以。



C99 提供了新的数据类型 int32_t / int64_t ，他们分别是 4 字节和 8 字节，是固定的，不随编译器和机器设置而变化。



有疑问，下边的几种形式，怎么是一样的意思？long int 没理解。。

```c
unsigned long
unsigned long int
long unsigned
long unsigned int
```



### 2.1.3 寻址和字节顺序

小端法，小端传输，little endian

大端法，大端传输，big endian



![image-20250518222914869](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202505182229078.png)



直接用 man 命令就可以查看 ASCII 表

```shell
man ascii
```

![image-20250518223207205](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202505182232330.png)



### 2.1.4 表示字符串

Unicode 联合会（Unicode Consortium）



### 2.1.5 表示代码

不同的机器类型使用不同的且不兼容的指令和编码方式。即使是完全一样的进程，运行在不同的操作系统上也会有不同的编码规则，因此二进制代码是不兼容的。二进制代码很少能在不同机器和操作系统组合之间移植。



### 2.1.6 布尔代数简介

布尔代数（Boolean algebra）

布尔环（Boolean ring）



### 2.1.7 C语言中的位级运算

| 就是 OR( 或），＆就是 AND( 与），～就是 NOT( 反），而＾就是 EXCLUSIVE-OR( 异或）。



### 2.1.8 C语言中的逻辑运算

逻辑运算符 || 、&& 、! ，注意与位运算的差异。

逻辑运算符＆＆和 II 与它们对应的位级运算＆和 之间第二个重要的区别是，如果对 第一个参数求值就能确定表达式的结果，那么逻辑运算符就不会对第二个参数求值。



### 2.1.9 C语言中的移位运算

移位运算是从左至右可结合的，x << j << k == (x << j) << k。



对于有符号数使用算数右移；对于无符号数，右移必须是逻辑的。



Java 对于如何进行右移有明确的定义。表达是 x>>k 会将 x 算术右移 k 个位置，而 x>>>k 会对 x 做逻辑右移。



加法（和减法）的优先级比移位运算要高，注意结合性问题。



## 2.2 整数表示

![image-20250623222235445](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202506232222966.png)



### 2.2.1 整数数据类型

有符号数，负数的范围比正数的范围大 1 。



C 和 C++ 都支持有符号（默认）和无符号数。Java 只支持有符号数。



### 2.2.2 无符号数的编码

B2U~w~（Binary to Unsigned 缩写，长度为 w）



原理：无符号数编码的定义



原理：无符号数编码的唯一性



### 2.2.3 补码编码

B2T~w~（Binary to Two's-complement）



书中这个补码示例图很有意思，之前从没这样想过。

![image-20250629104659979](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202506291047145.png)

由上述图片，就可以发现为啥 负数范围比正数的范围大 1 了。

1000 0000，-128

0111 1111，127



PRId32 / PRIu64

使用宏可以保证：不论代码是如何被编译的，都能生成正确的格式字符串。



正数数据类型的取值范围和表示，Java 标准非常明确，要求采用补码表示。单字节数据类型称为 byte ，而不是 char 。



### 2.2.4 有符号数和无符号数之间的转换

```c++
short int v = -12345;
unsigned short uv = (unsigned short)v;
printf("v = %d, uv = %u\n", v, uv);
```

![image-20250702082314033](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202507020823103.png)



### 2.2.5 C 语言中的有符号数与无符号数

大多数数字都默认为是有符号的。如果要创建一个无符号常量，必须加上后缀字符 U / u ;



注意最小值的写法，-2147483647-1 ，并不是 -2147483648 或 0 ，因为 limits.h 头文件中有类似写法；



### 2.2.6 扩展一个数字的位表示

要将一个无符号数转换为一个更大的数据类型，只需要在表示的开头添加 0 即可，这种运算被称为零扩展（zero extension）



### 2.2.7 截断数字

原理：截断无符号数



原理：截断补码数值



### 2.2.8 关于有符号数与无符号数的建议

有符号数到无符号数的隐式强制类型转换导致了某些非直观的 行为。而这些非直观的特性经常导致程序错误，并且这种包含隐式强制类型转换的细微差 别的错误很难被发现。



> 练习题 2.25

如下代码，直接运行会出现断错误。原因在于 length 为 0 ，再减一，就发生了隐式类型转换。

![image-20250705103135894](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202507051031323.png)



## 2.3 整数运算

问题一：两个正数相加，会得出一个负数；

问题二：比较表达式 x < y 和比较表达式 x - y < 0 会产生不同的结果；



### 2.3.1 无符号加法

两个 unsigned short 类型相加，其和需要一个 unsigned int 来存储。



正常情况下 x+y 的值保持不变，而溢出情况则是该和数减去 2^w^ 的结果。



### 2.3.2 补码加法

原理：补码加法



原理：检测补码加法中的溢出



### 2.3.3 补码的非

 C 语言中，我们 可以说，对于任意整数值 x, 计算表达式 -x 和 ~x+1 得到的结果完全一样。



### 2.3.4 无符号乘法

C 语言中的无符号乘法被定义为产生 w 位的值。



### 2.3.5 补码乘法

原理：无符号和补码乘法的位级等价性



### 2.3.6 乘以常数

大多数机器，整数乘法指令运行非常慢，可能需要 10 个或者更多时钟周期。

因此，编译器考虑使用移位和加法运算的组合来代替乘以常数因子的乘法。



原理：乘以 2 的幂

原理：与 2 的幂相乘的无符号乘法

原理：与 2 的幂相乘的补码乘法



```c
x * 14
14 = 2^3 + 2^2 + 2^1 = 2^4 - 2^1
x * 14 = (x << 3) + (x << 2) + (x << 1)
x * 14 = (x << 4) - (x << 1)
```



### 2.3.7 除以 2 的幂

在大多数机器上，整数除法比整数乘法更慢，可能需要 30 个或者更多的时钟周期。



除以 2 的幂，也可以用移位来实现，但是是右移。



原理：除以 2 的幂的无符号除法

原理：除以 2 的幂的补码除法，向下舍入



偏置（biasing）



原理：除以 2 的幂的补码除法，向上舍入



### 2.3.8 关于整数运算的最后思考

我们特别看到了 unsigned 数据类型，虽然它概念上很简 单，但可能导致即使是资深程序员都意想不到的行为。我们还看到这种数据类型会以出乎 意料的方式出现，比如，当书写整数常数和当调用库函数时。



## 2.4 浮点数

IEEE 标准 754 ，表示浮点数及其运算的标准。



### 2.4.1 二进制小数

二进制小数点向左移动一位，相当于这个数被 2 除。

二进制小数点向右移动一位，相当于将该数乘 2 。



### 2.4.2 IEEE 浮点表示

IEEE 浮点标准

- 符号（sign）
- 尾数（significand）
- 阶码（exponent）



规格化的值：E = e - Bias



非规格化的值：E = 1 - Bias

逐渐溢出



特殊值

NaN（Not a Number）



### 2.4.3 数字示例

IEEE 格式如此设计，就是为了浮点数能够使用整数排序函数来进行排序。



### 2.4.4 舍入

舍入（rounding）



IEEE 浮点格式定义了四种不同的舍入方式，默认的方法是找到最接近的匹配，而其他三种可用于计算上界和下界。

- 向偶数舍入
- 向零舍入
- 向下舍入
- 向上舍入



### 2.4.5 浮点运算

阿贝尔群，这又是啥？



### 2.4.6 C语言中的浮点数

当在int、float和double格式之间进行强制类型转换时，程序改变数值和位模式的原则如下（假设int是32位的）：

- 从int转换成float，数字不会溢出，但是可能被舍人入。
- 从int 或float转换成double，因为double有更大的范围（也就是可表示值的范围），也有更高的精度（也就是有效位数），所以能够保留精确的数值。
- 从double转换成float，因为范围要小一些，所以值可能溢出成+∞或一∞。另外，由于精确度较小，它还可能被舍人。
- 从float 或者double转换成int，值将会向零舍入。例如，1.999将被转换成1，而一1.999将被转换成—1。进一步来说，值可能会溢出。C语言标准没有对这种情况指定固定的结果。与Intel兼容的微处理器指定位模式[10··00]（字长为w时的TMin）为整数不确定（ （integer  indefinite）值。一个从浮点数到整数的转换，如果不能为该浮点数找到一个合理的整数近似值，就会产生这样一个值。因此，表达式（int）+le10会得到—21483648，即从一个正值变成了一个负值。



## 2.5 小结

编码为位。

64 位程序优势就是可以突破 32 位程序 4GB 地址空间的限制。



# 第3章 程序的机器级表示

逆向工程（reverse engineering）



## 3.1 历史观点

1978年，8086，29K 晶体管，x86

1980年，8087，浮点协处理器，x87



Pentium 4E，2004年，125M 晶体管，增加了超线程（hyperthreading），还增加了 EM64T ，它是 Intel AMD 提出的对 IA32 64 位扩展的实现，我们称之为 x86-64 。



## 3.2 程序编码

-Og 告诉编译器使用会生成符合原始 代码整体结构的机 器代码的优化等级。使用较高级别优化产生的代码会严重变形，以至于产生的机器代码和 初始源代码之间的关系非常难以理解。



### 3.2.1 机器级代码

指令集体系结构或指令集架构（Instruction Set Architecture, ISA），来定义机器级程序的格式和行为。



第二种抽象是，机器级程 序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。



### 3.2.2 代码示例

编译时，加上 -S 选项，就能看到 C 语言编译器产生的汇编代码。



GDB 可以看二进制文件反汇编之后的字节数据

```shell
(gdb) x/14xb multstore
```



反汇编器：objdump



### 3.2.3 关于格式的注解

所有以 . 开头的行，都是指导汇编器和链接器工作的伪指令。



条件码（condition code）

PF，parity flag（奇偶标志）



在 C 语言中，可以用 asm 的伪指令，包含简短的汇编代码。



## 3.3 数据格式

![image-20250727164228280](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202507271642414.png)



## 3.4 访问信息

x86-64 的 CPU ，包含一组 16 个存储 64 位值的通用目的寄存器。



### 3.4.1 操作数指示符

不同的操作数的可能性被分为三种类型。

- 立即数（immediate），用来表示常数值。
- 寄存器（register），表示某个寄存器的内容。
- 内存引用，它会根据计算出来的地址（通常称为有效地址）访问某个内存位置。



### 3.4.2 数据传送指令

指令类，MOV 类





### 3.4.3 数据传送示例

```c
long exchange(long *xp, long y)
{
    long x = *xp;
    *xp = y;
    return x;
}
```



### 3.4.4 压入和弹出栈数据

栈，是一种数据结构，遵循先进后出/后进先出的原则。



x86-64 中， 栈向低地址方向增长，所以压栈是减小栈指针（寄存器 %rsp) 的值，并将数据存放到 内存中，而出栈是从内存中读数据，并增加栈指针的值

![image-20250727165939236](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202507271704496.png)



## 3.5 算术和逻辑操作

指令类，以 ADD 加法为例，有字节加法、字加法、双字加法和四字加法。

操作被分为四组：加载有效地址、一元操作、二元操作和移位。



### 3.5.1 加载有效地址

加载有效地址（load effective address）



### 3.5.2 一元和二元操作

第一个操作数 可以是立即数、寄存器或是内存位置。第二个操作数可以是寄存器或是内存位置。注意， 当第二个操作数为内存地址时，处理器必须从内存读出值，执行操作，再把结果写回



### 3.5.3 移位操作

移位量可以是一个立即数，或者放在单字节寄存器 cl 中。



### 3.5.4 讨论

只有右移操作要求区分有符号和无符号数。



### 3.5.5 特殊的算术操作

IMUL 指令类



## 3.6 控制

直线代码的行为：指令一条接着一条顺序地执行。



jump 指令可以改变一组机器代码指令的执行顺序。



### 3.6.1 条件码

条件码（condition code）

- CF: 进位标志。最近的操作使最高位产生了进位。可用来检查无符号操作的溢出
- ZF: 零标志。最近的操作得出的结果为
- SF: 符号标志。最近的操作得到的结果为负数。
- OF: 溢出标志。最近的操作导致一个补码溢出 正溢出或负溢出



### 3.6.2 访问条件码

条件码常用的使用方法有三种：

- 可以根据条件码的某种组合， 将一个字节设置为 或者 1
- 可以条件跳转到程序的某个其他的部分
- 可以有条件地 传送数据。



同义名（synonym）



### 3.6.3 跳转指令

正常情况，指令是一条一条顺序执行。跳转（jump）会切换到程序中一个全新的位置。



### 3.6.4 跳转指令的编码

PC相对的（PC-relative）



### 3.6.5 用条件控制来实现条件分支

使用 goto 语句通常认为是一种不好的编程风格，因为它会使代码非常难以阅读和调试。



### 3.6.6 用条件传送来实现条件分支

实现条件操作的传统方法是通过使用控制的条件转移 。

一种替代的策略是使用数据的条件转移。



处理器采用非常精密的分支预测逻辑来猜测每条跳转指令是否会执行。



即使许多分支预测错误的开销会超 过更复杂的计算， GCC 还是会使用条件控制转移。



### 3.6.7 循环

do-while / while / for



### 3.6.8 switch语句

和使用一 组很长的 if-else 语句相比，使用跳转表的优点是执行开关语句的时间与开关情况的数量无关。



## 3.7 过程

过程是软件中一种很重要的抽象。

- 传递控制
- 传递数据
- 分配和释放内存



### 3.7.1 运行时栈

后进先出。



为了提高空间和时间效率，x86-64 过程只分配自己所需要的栈帧部分。



### 3.7.2 转移控制

程序计数器（PC）



call Q，该指令会把地址 A 压入栈中，并将 PC 设置为 Q 的起始地址。压入的地址 A 被称为返回地址，是紧跟在 call 指令后的那条指令的地址。



### 3.7.3 数据传送

![image-20250813103930522](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202508131039932.png)



### 3.7.4 栈上的局部存储

局部数据必须存放在内存中的常见情况如下：

- 寄存器不足够存放所有的本地数据；
- 对一个局部变量使用地址运算符 '&' ，因此必须能够为它产生一个地址；
- 某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到；



### 3.7.5 寄存器中的局部存储空间

寄存器组是唯一被所有过程共享的资源。



### 3.7.6 递归过程

每个过程调用在栈中都有它自己的私有空间，因此多个未完成调用的局部变量不会相互影响。



## 3.8 数组分配和访问

C语言一个特点就是可以产生指向数组中元素的指针，并对这些指针进行运算。



### 3.8.1 基本原则

数组，指针数组。



### 3.8.2 指针运算

C语言允许对指针进行运算，而计算出来的值会根据该指针引用的数据类型的大小进行伸缩。



Expr 与 * &Expr 是等价的。



### 3.8.3 嵌套的数组

创建数组时，数组分配和引用的一般原则也是成立的。

```c
int A[5][3];

// 等价于下列声明
typedef int row3_t[3];
row3_t A[5];
```



### 3.8.4 定长数组

良好的编程习惯：用常数作为数组的维度或者缓冲区的大小时，最好通过 # define 声明定义一个别名，后续都操作该名字。



### 3.8.5 变长数组

ISO C99 引入了一种功能，允许数组的维度是表达式，在数组被分配的时候才计算出来。



### 3.9 异质的数据结构

结构（structure），用关键字 struct 来声明；

联合（union），用关键字 union 来声明；



### 3.9.1 结构

结构的所有组成部分都存放在内存中一段连续的区域内，而指向结构的指针就是结构第一个字节的地址。



```c
struct rec
{
    int i;
    int j;
    int a[2];
    int *p;
};
```

如上结构内存分布如下图：

![image-20250817182546910](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202508171825483.png)



### 3.9.2 联合

```c
// 
struct S3
{
    char c;
    int i[2];
    double v;
};

// 
union U3
{
    char c;
    int i[2];
    double v;
};
```

如上结构体、联合体定义，x86-64 Linux 机器，内存偏移位置如下：

![image-20250817183123833](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202508171831939.png)



在结构体其他字段，与联合的元素之间，需要有 4 个字节的填充，所以 v 的起始地址是 16 ，而不是 12 。



对于有较多字段的数据结构，使用结构体 + 联合，可以节省很多内存空间。



### 3.9.3 数据对齐

对齐原则是任何 K 字节的基本对象的地址必须是 K 的倍数。



对于大多数 x86-64 指令，保持数据对齐能够提高效率，但是不会影响程序的行为。



## 3.10 在机器级程序中将控制与数据结合起来



### 3.10.1 理解指针

指针和映射到机器代码的关键原则

- 每个指针都对应一个类型。void * 类型代表通用指针。
- 每个指针都有一个值。
- 指针用 '&' 运算符创建。
- *操作符用于间接引用指针。间接引用是用内存引用来实现的，要么是存储到一个指定的地址，要么是从指定的地址读取。
- 数组与指针紧密联系。
- 将指针从一种类型强制转换成另一种类型，只改变它的类型，而不改变它的值。
- 指针也可以指向函数。



函数指针示例如下

```c
int (*f)(int*);

// *f 两侧的括号是必须的，否则会被解释为一个函数原型
int *f(int*);
// 声明了一个函数 f ，它以一个 int * 作为参数并返回一个 int *
(int *) f(int*);
```



### 3.10.2 应用：使用 GDB 调试器

用 objdump 获取程序的反汇编版本。



GDB 部分命令示例如下

![image-20250827100609576](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202508271006737.png)



DDD：是 GDB 的一个扩展，提供了图形用户界面。



### 3.10.3 内存越界引用和缓冲区溢出

对越界的数组元素的写操作会破坏存储在栈中的状态信息。



缓冲区溢出（buffer overflow）。



很多常用的库函数，包括 strcpy / strcat / sprintf 都不需要告诉它们目标缓冲区的大小，就产生一个字节序列，这样就很容易导致缓冲区溢出漏洞。



攻击代码（exploit code）



蠕虫（worm）可以自己运行，并且能够将自己的等效副本传播到其他机器。

病毒（virus）能将自己添加到包括操作系统在内的其他程序中，但它不能独立运行。



### 3.10.4 对抗缓冲区溢出攻击

1. 栈随机化

安全单一化（security monoculture）

栈随机化的思想使得栈的位置在程序每次运行时都有变化。

地址空间布局随机化（Address-Space Layout Randomization），简称 ASLR 。



nop ，读作 no op ，no operatioin 的缩写。



空操作雪橇（nop sled）



2. 栈破坏检测

栈保护者机制，stack protector



3. 限制可执行代码区域



### 3.10.5 支持变长栈帧

%rbp / base pointer 基指针。



## 3.11 浮点代码

处理器的浮点体系结构包括多个方面

- 如何存储和访问浮点数值。通常是通过某种寄存器方式来完成。
- 对浮点数据操作的指令。
- 向函数传递浮点数参数和从函数返回浮点数结果的规则。
- 函数调用过程中保存寄存器的规则。



### 3.11.1 浮点传送和转换操作

GCC 只用标量传送操作从内存传送数据到 XMM 寄存器，或从 XMM 寄存器传送数据到内存。



aligned（对齐的）



把浮点值转换成整数时，指令会执行截断（truncation），把值向 0 进行舍入。



### 3.11.2 过程中的浮点代码

x86-64 中，XMM 寄存器用来向函数传递浮点参数，以及从函数返回浮点值。



### 3.11.3 浮点运算操作

AVX2 浮点指令。



### 3.11.4 定义和使用浮点常数

AVX 浮点操作不能以立即数值作为操作数。相反，编译器必须为所有的常量值分配和初始化存储空间。然后代码再把这些值从内存读入。



### 3.11.5 在浮点代码中使用位级操作

GCC 生成的代码会在 XMM 寄存器上执行位级操作，得到有用的浮点结果。



### 3.11.6 浮点比较操作

浮点比较指令会设置三个条件码：零标志位 ZF 、进位标志位 CF 和奇偶标志位 PF 。

对于整数 操作，当最近的一次算术或逻辑运算产生的值的最低位字节是偶校验的（即这个字节中有 偶数个 1)，那么就会设置这个标志位。不过对于浮点比较，当两个操作数中任一个是 NaN 时，会设置该位。根据惯例，C 语言中如果有个参数为 NaN， 就认为比较失败了，这个标志位就被用来发现这样的条件。



当任一操作数为 NaN 时，就会出现无序的情况。



### 3.11.7 对浮点代码的观察结论

用 AVX2 为浮点数上的操作产生的机器代码风格类似于为整数上的操作产生的代码风格。



## 3.12 小结

及时编译（just-in-time compilation）



# 第4章 处理器体系结构

指令集体系结构（Instruction-Set Architecture, ISA）



为什么还需要了解处理器设计？

- 从智力方面来说，处理器设计是非常有趣而且很重要的。
- 理解处理器如何工作能帮助理解整个计算机系统如何工作。
- 虽然很少有人设计处理器，但是许多人设计包含处理器的硬件系统。
- 你的工作可能就是处理器设计。



HCL（Hardware Control Language，硬件控制语言）



## 4.1 Y86-64 指令集体系结构



### 4.1.1 程序员可见的状态

内存从概念上来说就是一个很大的字节数组，保存着程序和数据。



程序状态的最后一个部分是状态码 Stat ，它表明程序执行的总体状态。



### 4.1.2 Y86-64 指令

movq 、整数操作指令、跳转指令、条件传送指令等 



### 4.1.3 指令编码

第一个字节表明指令的类型。高四位是代码部分，低四位是功能部分。



寄存器指示符字节（register specifier byte）

常数字（constant word）



指令集的一个重要性质就是字节编码必须有唯一的解释。任意一个字节序列要么是一个唯一的指令序列的编码，要么就不是一个合法的字节序列。



复杂指令集计算机，CISC

精简指令集计算机，RISC



ARM，Acorn RISC Machine 缩写



### 4.1.4 Y86-64 异常

AOK / HLT / ADR / INS 



### 4.1.5 Y86-64 程序

汇编器伪指令（assembler directives）

```c
long sum(long *start, long count)
{
    long sum = 0;
    while (count)
    {
        sum += *start;
        start++;
        count--;
    }
    return sum;
}
```



### 4.1.6 一些 Y86-64 指令的详情

pushq 指令会把栈指针减 8, 并且将一个寄存器值写入内存中。因此，当执行 pushq %rsp 指令时，处理器的行为是不确定的，因为要入栈的寄存器会被同一条指令修改。通 常有两种不同的约定： 1) 压入 %rsp 的原始值， 2) 压入减去 %rsp 的值。



## 4.2 逻辑设计和硬件控制语言 HCL

HCL（Hardware Control Language，硬件控制语言）

HDL（Hardware Description Language，硬件描述语言）



逻辑合成（logic synthesis）



### 4.2.1 逻辑门

逻辑门总是活动的（active）。一旦一个门的输入变化了，在很短的时间内，输出就会相应地变化。



### 4.2.2 组合电路和 HCL布尔表达式

将很多逻辑门组合成一个网，就能构建计算块（computational block），称为组合电路（combinational circuits）。

- 每个逻辑门的输入必须连接到下述选项之一：
    - 一个系统输入（称为主输入）
    - 某个存储器单元的输出；
    - 某个逻辑门的输出；
- 两个或多个逻辑门的输出不能连接在一起。否则它们可能会使线上的信号矛盾，可能会导致一个不合法的电压或电路故障；
- 这个网必须是无环的。也就是在网中不能有路径经过一系列的门而形成一个回路，这样的回路会导致该网络计算的函数有歧义。



多路复用器（multiplexor，通常称为“MUX”）















