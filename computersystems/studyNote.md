

# 第1章 计算机系统漫游

hello world 程序



## 1.1 信息就是位 + 上下文

基本思想：系统中所有的信息 包括磁盘文件、内 存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。区 分不同数据对象的唯 方法是我们读到这些数据对象时的上下文 比如，在不同的上下文 中，一个同样的字节序列可能表示一个整数 浮点数、字符串或者机器指令。



## 1.2 程序被其他程序翻译成不同的格式

![image-20250420174021935](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202504211008449.png)



- 预处理阶段。预处理器 cpp ，替换 `#` 开头的预处理命令到当前源码文件，生成 *.i 文件。
- 编译阶段。编译器 ccl ，将 *.i 翻译成文本文件 *.s 。
- 汇编阶段。汇编器 as 。
- 链接阶段。链接器 ld 。



## 1.3 了解编译系统如何工作是大有益处的

原因：

- 优化程序性能。
- 理解链接时出现的错误。
- 避免安全漏洞。
    - 学习安全编程的第一步就是理解数据和控制信息存 储在程序栈上的方式会引起的后果。



## 1.4 处理器读并解释存储在内存中的指令

如果该命令不是内置的 shell 命令，那 shell 会假设这是一个可执行文件的名字。



### 1.4.1 系统的硬件组成

![image-20250422081939796](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202504220819874.png)



1. 总线

贯穿整个系统的是一组电子管道，称作总线，它携带信息字节并负责在各个部件间传 递。通常总线被设计成传送定长的字节块，也就是宇 (word) 。



2. I/O 设备（输入/输出）

每个 I/0 设备都通过一个控制器或适配器与 总线相连。功能都是在 I/O 总线和 I/O 设备之间传递信息。区别在于：

- 控制器：是 I/O 设备本身或者系统的主板上的芯片组。
- 适配器：则是一块插在主板插槽上的卡。



3. 主存

物理上：由动态随机存取存储器（DRAM）芯片组成。

逻辑上：存储器是一个线性的字节数组，每个字节都有其唯一的地址（数组索引）。



4. 处理器

中央处理单元（CPU），简称处理器，是解释（或执行）存储在主存中指令的引擎。



### 1.4.2 运行 hello 程序

在键盘上输入字符串后，会先将字符逐一读入寄存器，再存放到内存中。



按下回车后，认为输入结束，开始从磁盘中复制到主存。

如果使用直接存储器存取（DMA），数据可以不通过处理器，而直接从磁盘到达主存。



当目标文件被加载到主存后，处理器开始执行程序，会依次将字符传从主存复制到寄存器文件，再从寄存器文件中复制到显示设备，最终显示到屏幕上。



## 1.5 高速缓存至关重要

这个简单的示例揭示了一个重要的问题，即系统花费了大量的时间把信息从一个地方挪到另一个地方。

从程序员的角度来看，这些复制就是开销，减慢了程序“真正”的工作



根据机械原理，较大的存储设备要比较小的存储设备运行得慢，而快速设备的造价远高于同类的低速设备。

加快处理器的运行速度比加快主存的运行速度要容易和便宜得多。



高速缓存存储器（cache memory ，简称为 cache 或高速缓存）。

L1 和 L2 高速缓存是用一种叫做静态随机访问存储器（SRAM）的硬件技术实现的。



![image-20250423082609357](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202504230826469.png)



本书结论：意识到高速缓存存储器存在的应用程序员能够利用高速缓存将程序的性能提高一个数量级。



## 1.6 存储设备形成层次结构

![image-20250424081538744](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202504240815879.png)



存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。



## 1.7 操作系统管理硬件

操作系统有两个基本功能：

（1）防止硬件被失控的应用程序滥用；

（2）向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。

操作系统通过几个基本的抽象概念（进程、虚拟内存和文件）来实现这两个功能。



Posix 标准。



### 1.7.1 进程

进程是操作系统对一个正在运行的程序的一种抽象。



并发运行：一个进程的指令和另一个进程的指令是交错执行的。



无论是在单核还是多核系统中，一个CPU看上去都像是在并发地执行多个进程，这是通过处理器在进程间切换来实现的。操作系统实现这种交错执行的机制称为上下文切换。



从一个进程到另一个进程的转换是由操作系统内核（kernel）管理的。

内核不是一个独立的进程。相反，它是系统管理全部进程所用代码和数据结构的集合。



### 1.7.2 线程

现代系统，一个进程实际上可以有多个线程组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。



### 1.7.3 虚拟内存

地址从低到高，依次介绍：

- 程序代码和数据。
- 堆。
- 共享库。
- 栈。
- 内核虚拟内存。



虚拟内存的一个基本思想是：把一个进程虚拟内存的内容存储在磁盘上，然后用主存作为磁盘的高速缓存。



### 1.7.4 文件

文件就是字节序列。



## 1.8 系统之间利用网络通信

hello 示例，利用 telnet 在远端服务器执行，并在当前终端返回结果。



## 1.9 重要主题

### 1.9.1 Amdahl 定律

该定律的主要 思想是，当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要 性和加速程度。



Amdahl 定律的主要观点：要想显著加速整个系统，必须提升全系统中相当大的部分的速度。



### 1.9.2 并发和并行

并发，concurrency

并行，parallelism



1. 线程级并发

超线程，hyperthreading

别称：同时多线程，simultaneous multi-threading



![image-20250508081045867](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202505080810996.png)



多处理器的使用，可以从两个方面提高系统性能

- 减少了在执行多个任务时模拟并发的需要。
- 可以使应用程序运行得更快。



2. 指令级并行

在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为指令级并行。



流水线，pipelining

在 流水线中，将执行一条指令所需要的活动划分成不同的步骤，将处理器的硬件组织成一系 列的阶段，每个阶段执行一个步骤。这些阶段可以并行地操作，用来处理不同指令的不同 部分。



超标量处理器（super-scalar），指处理器达到比一个周期一条指令更快的执行速率。



3. 单指令、多数据并行

在最低层次上，许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执 行的操作，这种方式称为单指令、多数据，即 SIMD 并行。



### 1.9.3 计算机系统中抽象的重要性

抽象的使用是计算机科学中最为重要的概念之一。



计算机系统中的一个重大主题就是提供不同层次的抽象表示，来隐藏实际实现的复杂性。



文件是对 I/0 设备的抽象，虚拟内存是对 程序存储器的抽象，而进程是对一个正在运行的程序的抽象。虚拟机，它提供对整个计算机的抽象，包括操作系统、处理器和程序。



## 1.10 小结

计算机系统由硬件和系统软件组成，共同协作以运行应用程序。



# 第一部分 —— 程序结构和执行



# 第2章 信息的表示和处理



无符号，unsigned

补码，two's-complement

浮点数，floating-point



整数的表示是精确的；浮点数的表示只是近似的。



## 2.1 信息存储

虚拟内存（virtual memory ）。

虚拟内存空间（virtual memory space）。

虚拟地址空间只是一个 机器级程序的概念性映像 实际的实现（见第 章）是将动 态随机访问存储器 DRAM 、闪存、磁盘存储器、特 硬件和 作系统软件结合起来，为程序提供一个看上去统一的字节数组。



指针包括值和类型。

- 值表示某个对象的位置；
- 类型表示那个位置上所存储对象的类型；



### 2.1.1 十六进制表示法

十六进制表示法：0x / 0X 开头。



### 2.1.2 字数据大小

64 位机器一般可以兼容运行 32 位程序，反之则不可以。



C99 提供了新的数据类型 int32_t / int64_t ，他们分别是 4 字节和 8 字节，是固定的，不随编译器和机器设置而变化。



有疑问，下边的几种形式，怎么是一样的意思？long int 没理解。。

```c
unsigned long
unsigned long int
long unsigned
long unsigned int
```



### 2.1.3 寻址和字节顺序

小端法，小端传输，little endian

大端法，大端传输，big endian



![image-20250518222914869](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202505182229078.png)



直接用 man 命令就可以查看 ASCII 表

```shell
man ascii
```

![image-20250518223207205](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202505182232330.png)



### 2.1.4 表示字符串

Unicode 联合会（Unicode Consortium）



### 2.1.5 表示代码

不同的机器类型使用不同的且不兼容的指令和编码方式。即使是完全一样的进程，运行在不同的操作系统上也会有不同的编码规则，因此二进制代码是不兼容的。二进制代码很少能在不同机器和操作系统组合之间移植。



### 2.1.6 布尔代数简介

布尔代数（Boolean algebra）

布尔环（Boolean ring）



### 2.1.7 C语言中的位级运算

| 就是 OR( 或），＆就是 AND( 与），～就是 NOT( 反），而＾就是 EXCLUSIVE-OR( 异或）。



### 2.1.8 C语言中的逻辑运算

逻辑运算符 || 、&& 、! ，注意与位运算的差异。

逻辑运算符＆＆和 II 与它们对应的位级运算＆和 之间第二个重要的区别是，如果对 第一个参数求值就能确定表达式的结果，那么逻辑运算符就不会对第二个参数求值。



### 2.1.9 C语言中的移位运算

移位运算是从左至右可结合的，x << j << k == (x << j) << k。



对于有符号数使用算数右移；对于无符号数，右移必须是逻辑的。



Java 对于如何进行右移有明确的定义。表达是 x>>k 会将 x 算术右移 k 个位置，而 x>>>k 会对 x 做逻辑右移。



加法（和减法）的优先级比移位运算要高，注意结合性问题。



## 2.2 整数表示

![image-20250623222235445](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202506232222966.png)



### 2.2.1 整数数据类型

有符号数，负数的范围比正数的范围大 1 。



C 和 C++ 都支持有符号（默认）和无符号数。Java 只支持有符号数。



### 2.2.2 无符号数的编码

B2U~w~（Binary to Unsigned 缩写，长度为 w）



原理：无符号数编码的定义



原理：无符号数编码的唯一性



### 2.2.3 补码编码

B2T~w~（Binary to Two's-complement）



书中这个补码示例图很有意思，之前从没这样想过。

![image-20250629104659979](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202506291047145.png)

由上述图片，就可以发现为啥 负数范围比正数的范围大 1 了。

1000 0000，-128

0111 1111，127



PRId32 / PRIu64

使用宏可以保证：不论代码是如何被编译的，都能生成正确的格式字符串。



正数数据类型的取值范围和表示，Java 标准非常明确，要求采用补码表示。单字节数据类型称为 byte ，而不是 char 。



### 2.2.4 有符号数和无符号数之间的转换

```c++
short int v = -12345;
unsigned short uv = (unsigned short)v;
printf("v = %d, uv = %u\n", v, uv);
```

![image-20250702082314033](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202507020823103.png)



### 2.2.5 C 语言中的有符号数与无符号数

大多数数字都默认为是有符号的。如果要创建一个无符号常量，必须加上后缀字符 U / u ;



注意最小值的写法，-2147483647-1 ，并不是 -2147483648 或 0 ，因为 limits.h 头文件中有类似写法；



### 2.2.6 扩展一个数字的位表示

要将一个无符号数转换为一个更大的数据类型，只需要在表示的开头添加 0 即可，这种运算被称为零扩展（zero extension）



### 2.2.7 截断数字

原理：截断无符号数



原理：截断补码数值



### 2.2.8 关于有符号数与无符号数的建议

有符号数到无符号数的隐式强制类型转换导致了某些非直观的 行为。而这些非直观的特性经常导致程序错误，并且这种包含隐式强制类型转换的细微差 别的错误很难被发现。



> 练习题 2.25

如下代码，直接运行会出现断错误。原因在于 length 为 0 ，再减一，就发生了隐式类型转换。

![image-20250705103135894](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202507051031323.png)



## 2.3 整数运算

问题一：两个正数相加，会得出一个负数；

问题二：比较表达式 x < y 和比较表达式 x - y < 0 会产生不同的结果；



### 2.3.1 无符号加法

两个 unsigned short 类型相加，其和需要一个 unsigned int 来存储。



正常情况下 x+y 的值保持不变，而溢出情况则是该和数减去 2^w^ 的结果。



### 2.3.2 补码加法

原理：补码加法



原理：检测补码加法中的溢出



### 2.3.3 补码的非

 C 语言中，我们 可以说，对于任意整数值 x, 计算表达式 -x 和 ~x+1 得到的结果完全一样。



### 2.3.4 无符号乘法

C 语言中的无符号乘法被定义为产生 w 位的值。



### 2.3.5 补码乘法

原理：无符号和补码乘法的位级等价性



### 2.3.6 乘以常数

大多数机器，整数乘法指令运行非常慢，可能需要 10 个或者更多时钟周期。

因此，编译器考虑使用移位和加法运算的组合来代替乘以常数因子的乘法。



原理：乘以 2 的幂

原理：与 2 的幂相乘的无符号乘法

原理：与 2 的幂相乘的补码乘法



```c
x * 14
14 = 2^3 + 2^2 + 2^1 = 2^4 - 2^1
x * 14 = (x << 3) + (x << 2) + (x << 1)
x * 14 = (x << 4) - (x << 1)
```



### 2.3.7 除以 2 的幂

在大多数机器上，整数除法比整数乘法更慢，可能需要 30 个或者更多的时钟周期。



除以 2 的幂，也可以用移位来实现，但是是右移。



原理：除以 2 的幂的无符号除法

原理：除以 2 的幂的补码除法，向下舍入



偏置（biasing）



原理：除以 2 的幂的补码除法，向上舍入



### 2.3.8 关于整数运算的最后思考

我们特别看到了 unsigned 数据类型，虽然它概念上很简 单，但可能导致即使是资深程序员都意想不到的行为。我们还看到这种数据类型会以出乎 意料的方式出现，比如，当书写整数常数和当调用库函数时。



## 2.4 浮点数

IEEE 标准 754 ，表示浮点数及其运算的标准。



### 2.4.1 二进制小数

二进制小数点向左移动一位，相当于这个数被 2 除。

二进制小数点向右移动一位，相当于将该数乘 2 。



### 2.4.2 IEEE 浮点表示

IEEE 浮点标准

- 符号（sign）
- 尾数（significand）
- 阶码（exponent）



规格化的值：E = e - Bias



非规格化的值：E = 1 - Bias

逐渐溢出



特殊值

NaN（Not a Number）



### 2.4.3 数字示例

IEEE 格式如此设计，就是为了浮点数能够使用整数排序函数来进行排序。



### 2.4.4 舍入

舍入（rounding）



IEEE 浮点格式定义了四种不同的舍入方式，默认的方法是找到最接近的匹配，而其他三种可用于计算上界和下界。

- 向偶数舍入
- 向零舍入
- 向下舍入
- 向上舍入



### 2.4.5 浮点运算

阿贝尔群，这又是啥？



### 2.4.6 C语言中的浮点数

当在int、float和double格式之间进行强制类型转换时，程序改变数值和位模式的原则如下（假设int是32位的）：

- 从int转换成float，数字不会溢出，但是可能被舍人入。
- 从int 或float转换成double，因为double有更大的范围（也就是可表示值的范围），也有更高的精度（也就是有效位数），所以能够保留精确的数值。
- 从double转换成float，因为范围要小一些，所以值可能溢出成+∞或一∞。另外，由于精确度较小，它还可能被舍人。
- 从float 或者double转换成int，值将会向零舍入。例如，1.999将被转换成1，而一1.999将被转换成—1。进一步来说，值可能会溢出。C语言标准没有对这种情况指定固定的结果。与Intel兼容的微处理器指定位模式[10··00]（字长为w时的TMin）为整数不确定（ （integer  indefinite）值。一个从浮点数到整数的转换，如果不能为该浮点数找到一个合理的整数近似值，就会产生这样一个值。因此，表达式（int）+le10会得到—21483648，即从一个正值变成了一个负值。



## 2.5 小结

编码为位。

64 位程序优势就是可以突破 32 位程序 4GB 地址空间的限制。



# 第3章 程序的机器级表示

逆向工程（reverse engineering）



## 3.1 历史观点

1978年，8086，29K 晶体管，x86

1980年，8087，浮点协处理器，x87



Pentium 4E，2004年，125M 晶体管，增加了超线程（hyperthreading），还增加了 EM64T ，它是 Intel AMD 提出的对 IA32 64 位扩展的实现，我们称之为 x86-64 。



## 3.2 程序编码

-Og 告诉编译器使用会生成符合原始 代码整体结构的机 器代码的优化等级。使用较高级别优化产生的代码会严重变形，以至于产生的机器代码和 初始源代码之间的关系非常难以理解。



### 3.2.1 机器级代码

指令集体系结构或指令集架构（Instruction Set Architecture, ISA），来定义机器级程序的格式和行为。



第二种抽象是，机器级程 序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。



### 3.2.2 代码示例

编译时，加上 -S 选项，就能看到 C 语言编译器产生的汇编代码。



GDB 可以看二进制文件反汇编之后的字节数据

```shell
(gdb) x/14xb multstore
```



反汇编器：objdump



### 3.2.3 关于格式的注解

所有以 . 开头的行，都是指导汇编器和链接器工作的伪指令。



条件码（condition code）

PF，parity flag（奇偶标志）



在 C 语言中，可以用 asm 的伪指令，包含简短的汇编代码。



## 3.3 数据格式

![image-20250727164228280](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202507271642414.png)



## 3.4 访问信息

x86-64 的 CPU ，包含一组 16 个存储 64 位值的通用目的寄存器。



### 3.4.1 操作数指示符

不同的操作数的可能性被分为三种类型。

- 立即数（immediate），用来表示常数值。
- 寄存器（register），表示某个寄存器的内容。
- 内存引用，它会根据计算出来的地址（通常称为有效地址）访问某个内存位置。



### 3.4.2 数据传送指令

指令类，MOV 类





### 3.4.3 数据传送示例

```c
long exchange(long *xp, long y)
{
    long x = *xp;
    *xp = y;
    return x;
}
```



### 3.4.4 压入和弹出栈数据

栈，是一种数据结构，遵循先进后出/后进先出的原则。



x86-64 中， 栈向低地址方向增长，所以压栈是减小栈指针（寄存器 %rsp) 的值，并将数据存放到 内存中，而出栈是从内存中读数据，并增加栈指针的值

![image-20250727165939236](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202507271704496.png)



## 3.5 算术和逻辑操作

指令类，以 ADD 加法为例，有字节加法、字加法、双字加法和四字加法。

操作被分为四组：加载有效地址、一元操作、二元操作和移位。



### 3.5.1 加载有效地址

加载有效地址（load effective address）



### 3.5.2 一元和二元操作

第一个操作数 可以是立即数、寄存器或是内存位置。第二个操作数可以是寄存器或是内存位置。注意， 当第二个操作数为内存地址时，处理器必须从内存读出值，执行操作，再把结果写回



### 3.5.3 移位操作

移位量可以是一个立即数，或者放在单字节寄存器 cl 中。



### 3.5.4 讨论

只有右移操作要求区分有符号和无符号数。



### 3.5.5 特殊的算术操作

IMUL 指令类













