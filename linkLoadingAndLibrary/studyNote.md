# 第1部分 简介

## 第1章 温故而知新

### 1.1 从 Hello World 说起

从 Hello World 思考一些问题：

  ? 程序为什么要被编译器编译了之后才可以运行？

  ? 编译器在把C语言程序转换成可以执行的机器码的过程中做了什么，怎么做的？

  ? 最后编译出来的可执行文件里面是什么？除了机器码还有什么？它们怎么存放的，怎么组织的？

  ? #include <stdio.h>是什么意思？把stdio.h包含进来意味着什么？C语言库又是什么？它怎么实现的？

  ? 不同的编译器（Microsoft VC、GCC）和不同的硬件平台（x86、SPARC、MIPS、ARM），以及不同的操作系统（Windows、Linux、UNIX、Solaris），最终编译出来的结果一样吗？为什么？

  ? Hello World程序是怎么运行起来的？操作系统是怎么装载它的？它从哪儿开始执行，到哪儿结束？main函数之前发生了什么？main函数结束以后又发生了什么？

  ? 如果没有操作系统，Hello World可以运行吗？如果要在一台没有操作系统的机器上运行Hello World需要什么？应该怎么实现？

  ? printf是怎么实现的？它为什么可以有不定数量的参数？为什么它能够在终端上输出字符串？

  ? Hello World程序在运行时，它在内存中是什么样子的？



### 1.2 万变不离其宗

最为关键的三个部件：中央处理器 CPU 、内存和 I/O 控制芯片；



北桥（Northbridge，PCI Bridge）

南桥（Southbridge）



多核处理器（Multi-core Processor）

> “多处理器应用最多的场合也是这些商用的服务器和需要处理大量计算的环境。而在个人电脑中，使用多处理器则是比较奢侈的行为，毕竟多处理器的成本是很高的。于是处理器的厂商开始考虑将多个处理器“合并在一起打包出售”，这些“被打包”的处理器之间共享比较昂贵的缓存部件，只保留多个核心，并且以一个处理器的外包装进行出售，售价比单核心的处理器只贵了一点，这就是多核处理器（Multi-core Processor）的基本想法。”
>
> 摘录来自
> 程序员的自我修养：链接、装载与库
> 俞甲子 石凡 潘爱民
> 此材料可能受版权保护。



[Free Lunch is Over（免费午餐已经结束了）](http://www.gotw.ca/publications/concurrency-ddj.htm)



### 1.3 站得高，望得远

“Any problem in computer science can be solved by another layer of indirection.”

“计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决”



### 1.4 操作系统做什么

操作系统的一个功能是提供抽象的接口，另外一个主要功能是管理硬件资源。

让计算机硬件发挥所有潜能。



#### 1.4.1 不要让 CPU 打盹

分时系统（Time-Sharing System）



多任务（Multi-tasking）系统，操作系统接管了所有的硬件资源，并且本身运行在一个受硬件保护的级别。所有的应用程序都以进程（Process）的方式运行在比操作系统权限更低的级别，每个进程都有自己独立的地址空间，使得进程之间的地址空间相互隔离。CPU由操作系统统一进行分配，每个进程根据进程优先级的高低都有机会得到CPU，但是，如果运行时间超出了一定的时间，操作系统会暂停该进程，将CPU资源分配给其他等待运行的进程。这种CPU的分配方式即所谓的抢占式（Preemptive），操作系统可以强制剥夺CPU资源并且分配给它认为目前最需要的进程。如果操作系统分配给每个进程的时间都很短，即CPU在多个进程间快速地切换，从而造成了很多进程都在同时运行的假象。



#### 1.4.2 设备驱动

“DDA（一种画直线的图形算法）”

“硬件驱动（Device Driver）”

“现代的硬盘普遍使用一种叫做LBA（Logical Block Address）的方式，即整个硬盘中所有的扇区从0开始编号，一直到最后一个扇区，这个扇区编号叫做逻辑扇区号。”



### 1.5 内存不够怎么办

“? 地址空间不隔离 所有程序都直接访问物理地址，程序所使用的内存空间不是相互隔离的。”



“? 内存使用效率低 由于没有有效的内存管理机制，通常需要一个程序执行时，监控程序就将整个程序装入内存中然后开始执行。”



“? 程序运行的地址不确定 因为程序每次需要装入运行时，我们都需要给它从内存中分配一块足够大的空闲区域，这个空闲区域的位置是不确定的。”



#### 1.5.1 关于隔离

“地址空间分两种：虚拟地址空间（Virtual Address Space）和物理地址空间（Physical Address Space）。”



“物理地址空间是实实在在存在的，存在于计算机中，而且对于每一台计算机来说只有唯一的一个。”



“虚拟地址空间是指虚拟的、人们想象出来的地址空间，其实它并不存在，每个进程都有自己独立的虚拟空间，而且每个进程只能访问自己的地址空间，这样就有效地做到了进程的隔离。”



#### 1.5.2 分段（Segmentation）

“基本思路是把一段与程序所需要的内存空间大小的虚拟空间映射到某个地址空间。”



“根据程序的局部性原理，当一个程序在运行时，在某个时间段内，它只是频繁地用到了一小部分数据，也就是说，程序的很多数据其实在一个时间段内都是不会被用到的。人们很自然地想到了更小粒度的内存分割和映射的方法，使得程序的局部性原理得到充分的利用，大大提高了内存的使用率。这种方法就是分页（Paging）。”



#### 1.5.3 分页（Paging）

“我们把虚拟空间的页就叫虚拟页（VP，Virtual Page），把物理内存中的页叫做物理页（PP，Physical Page），把磁盘中的页叫做磁盘页（DP，Disk Page）。”



“MMU（Memory Management Unit）”



### 1.6 众人拾柴火焰高

#### 1.6.1 线程基础

“线程（Thread），有时被称为轻量级进程（Lightweight Process, LWP），是程序执行流的最小单元。一个标准的线程由线程ID、当前指令指针（PC）、寄存器集合和堆栈组成。通常意义上，一个进程由一个到多个线程组成，各个线程之间共享程序的内存空间（包括代码段、数据段、堆等）及一些进程级的资源（如打开文件和信号）。”



通常，使用多线程的原因有如下几点：

- 某个操作可能会陷入长时间等待，等待的线程会进入睡眠状态，无法继续执行。
- 某个操作（常常是计算）会消耗大量的时间，如果只有一个线程，程序和用户之间的交互会中断。多线程可以让一个线程负责交互，另一个线程负责计算。
- 程序逻辑本身就要求并发操作
- 多CPU或多核计算机（基本就是未来的主流计算机），本身具备同时执行多个线程的能力，因此单线程程序无法全面地发挥计算机的全部计算能力。
- 相对于多进程应用，多线程在数据共享方面效率要高很多。




**线程调度与优先级**

这样的一个不断在处理器上切换不同的线程的行为称之为线程调度（Thread Schedule）。在线程调度中，线程通常拥有至少三种状态，分别是：

- 运行（Running）：此时线程正在执行。
- 就绪（Ready）：此时线程可以立刻运行，但CPU已经被占用。
- 等待（Waiting）：此时线程正在等待某一事件（通常是I/O或同步）发生，无法执行。



我们一般把频繁等待的线程称之为IO密集型线程（IO Bound Thread），而把很少等待的线程称为CPU密集型线程（CPU Bound Thread）。IO密集型线程总是比CPU密集型线程容易得到优先级的提升。



在优先级调度的环境下，线程的优先级改变一般有三种方式。

- 用户指定优先级。
- 根据进入等待状态的频繁程度提升或降低优先级。
- 长时间得不到执行而被提升优先级。



**可抢占线程和不可抢占线程**

线程在用尽时间片之后会被强制剥夺继续执行的权利，而进入就绪状态，这个过程叫做抢占（Preemption）



fork ，复制当前进程

exec ，使用新的可执行映像覆盖当前可执行映像

clone ，创建子进程并从指定位置开始执行



fork产生新任务的速度非常快，因为fork并不复制原任务的内存空间，而是和原任务一起共享一个写时复制（Copy on Write, COW）的内存空间（见图1-10）。所谓写时复制，指的是两个任务可以同时自由地读取内存，但任意一个任务试图对内存进行修改时，内存就会复制一份提供给修改方单独使用，以免影响到其他的任务使用。



#### 1.6.2 线程安全

**竞争与原子操作**

多个线程同时访问一个共享数据，可能会造成很恶劣的后果。



自增（++）操作在多线程环境下会出现错误是因为这个操作被编译为汇编代码之后不止一条指令，因此在执行的时候可能执行了一半就被调度系统打断，去执行别的代码。我们把单指令的操作称为原子的（Atomic）



**同步与锁**

二元信号量（Binary Semaphore）是最简单的一种锁，只有两种状态：占用与非占用。



多元信号量简称信号量（Semaphore），它是一个很好的选择。一个初始值为N的信号量允许N个线程并发访问。

- 同一个信号量可以被系统中的一个线程获取之后由另一个线程释放；
- 任何进程可见



互斥量（Mutex）

- 要求哪个线程获取了互斥量，哪个线程就要负责释放这个锁；
- 任何进程可见；



临界区（Critical Section）是比互斥量更严格的同步手段。

临界区和互斥量与信号量的区别在于，互斥量和信号量在系统的任何进程里都是可见的，也就是说，一个进程创建了一个互斥量或信号量，另一个进程试图去获取该锁是合法的。然而，临界区的作用范围仅限于本进程，其他的进程无法获取该锁。除此之外，临界区具有和互斥量相同的性质。



读写锁（Read-Write Lock）。如上几种方式，对于读取频繁，而仅仅偶尔写入的情况，会显得非常低效。

| 读写锁状态 | 以共享方式获取 | 以独占方式获取 |
| :--------: | :------------: | :------------: |
|    自由    |      成功      |      成功      |
|    共享    |      成功      |      等待      |
|    独占    |      等待      |      等待      |



条件变量（Condition Variable）

对于条件变量，线程可以有两种操作，首先线程可以等待条件变量，一个条件变量可以被多个线程等待。其次，线程可以唤醒条件变量，此时某个或所有等待此条件变量的线程都会被唤醒并继续支持。也就是说，使用条件变量可以让许多线程一起等待某个事件的发生，当事件发生时（条件变量被唤醒），所有的线程可以一起恢复执行。



**可重入（Reentrant）与线程安全**

一个函数被重入，表示这个函数没有执行完成，由于外部因素或内部调用，又一次进入该函数执行。一个函数要被重入，只有两种情况：

（1）多个线程同时执行这个函数。

（2）函数自身（可能是经过多层调用之后）调用自身。



可重入是并发安全的强力保障，一个可重入的函数可以在多线程环境下放心使用。



**过度优化**

我们可以使用volatile关键字试图阻止过度优化，volatile基本可以做到两件事情：

（1）阻止编译器为了提高速度将一个变量缓存到寄存器内而不写回。

（2）阻止编译器调整操作volatile变量的指令顺序。



通常情况下是调用CPU提供的一条指令，这条指令常常被称为barrier。一条barrier指令会阻止CPU将该指令之前的指令交换到barrier之后，反之亦然。换句话说，barrier指令的作用类似于一个拦水坝，阻止换序“穿透”这个大坝。

```c++
#define barrier() __asm__ volatile (”lwsync”)


volatile T* pInst = 0;
T* GetInstance()
{
    if (!pInst)
    {
        lock();
        if (!pInst)
        {
            T* temp = new T;
            barrier(); // 确保对象构造在此之前执行
            pInst = temp;
        }
        unlock();
    }
    return pInst;
}
```



#### 1.6.3 多线程内部情况

**三种线程模型**

用户态线程并不一定在操作系统内核里对应同等数量的内核线程。



1. 一对一模型

对一对一模型来说，一个用户使用的线程就唯一对应一个内核使用的线程（但反过来不一定，一个内核里的线程在用户态不一定有对应的线程存在）

此时，线程之间的并发是真正的并发，一个线程阻塞，其他线程不会受影响。

缺点：

- 数量有限制；
- 内核线程调度，上下文切换开销较大，导致执行效率下降；



2. 多对一模型

多对一模型将多个用户线程映射到一个内核线程上，线程之间的切换由用户态的代码来进行，因此相对于一对一模型，多对一模型的线程切换要快速许多。



缺点：

- 有一个用户线程阻塞，所有线程都将无法执行。



3. 多对多模型

将多个用户线程映射到少数但不止一个内核线程上。



### 1.7 本章小结

对计算机的软硬件基本结构进行了回顾。



# 第2部分 静态链接

## 第2章 编译和链接

### 2.1 被隐藏了的过程

一个简单的 hello world 程序，在 gcc 编译的时候，包含：预处理（ Prepressing ）、编译（Compilation）、汇编（Assembly）和链接（Linking）。

![image-20240926225744315](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202409262257508.png)



#### 2.1.1 预编译

预编译过程主要处理代码中以 “#” 开始的预编译指令。比如 `#include` 、`#define` 等，主要处理规则如下：

- 将所有的 `#define` 删除，并且展开所有的宏定义。
- 处理所有条件预编译指令，比如“#if”、“#ifdef”、“#elif”、“#else”、“#endif”。
- 处理“#include”预编译指令，将被包含的文件插入到该预编译指令的位置。注意，这个过程是递归进行的，也就是说被包含的文件可能还包含其他文件。
- 删除所有的注释“//”和“/* */”。
- 添加行号和文件名标识，比如#2“hello.c”2，以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号。
- 保留所有的#pragma编译器指令，因为编译器须要使用它们。



> 经过预编译后的.i文件不包含任何宏定义，因为所有的宏已经被展开，并且包含的文件也已经被插入到.i文件中。所以当我们无法判断宏定义是否正确或头文件包含是否正确时，可以查看预编译后的文件来确定问题。
>



#### 2.1.2 编译

编译过程就是把预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后生产相应的汇编代码文件，这个过程往往是我们所说的整个程序构建的核心部分，也是最复杂的部分之一。



现代版本的 GCC 把预编译和编译两个步骤合并成一个步骤，用 cc1 来实现。



#### 2.1.3 汇编

汇编器 as 。

```shell
as hello.s -o hello.o
```



#### 2.1.4 链接

```shell
$ld -static /usr/lib/crt1.o /usr/lib/crti.o /usr/lib/gcc/i486-linux-gnu/4.1.3/crtbeginT.o -L/usr/lib/gcc/i486-linux-gnu/4.1.3 -L/usr/lib -L/lib hello.o --start-group -lgcc -lgcc_eh -lc --end-group /usr/lib/gcc/i486-linux-gnu/4.1.3/crtend.o /usr/lib/crtn.o
```



### 2.2 编译器做了什么

编译过程一般可以分为6步：扫描、语法分析、语义分析、源代码优化、代码生成和目标代码优化。

![image-20241009223857347](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202410092238622.png)



```c
array[index] = (index + 4) * (2 + 6)
```



#### 2.2.1 词法分析

词法分析产生的记号，一般可以有如下几类：关键字、标识符、字面量（包含数字、字符串等）和特殊符号（如加号、灯号）。



lex 程序可以实现词法扫描。



对一些有预处理的语言，比如 C 语言，宏替换和文件包含等工作一般不归入编译器的范围，而交给一个独立的预处理器。



#### 2.2.2 语法分析

参考上下文无关语法及下推自动机。



如果出现了表达式不合法，比如各种括号不匹配、表达式中缺少操作符等，编译器就会报告语法分析阶段的错误。



yacc （Yet Another Compiler Compiler），是一个现成的语法分析工具。



对于不同的编程语言，编译器的开发者只须改变语法规则，而无须为每个编译器编写一个语法分析器，所以它又被称为“编译器编译器（Compiler Compiler）”。



#### 2.2.3 语义分析

编译器所能分析的语义是静态语义（Static Semantic），所谓静态语义是指在编译期可以确定的语义，与之对应的动态语义（Dynamic Semantic）就是只有在运行期才能确定的语义。



#### 2.2.4 中间语言生成

源码级优化器（Source Code Optimizer）



常见的中间代码有：三地址码（Three-address Code）和P-代码（P-Code）。

基本的三地址码：

```c
x = y op z
```

之前的语法树，翻译成三地址码如下：

```c
t1 = 2 + 6
t2 = index + 4
t3 = t2 * t1
array[index] = t3
```

上述代码用了几个临时变量，编译器在优化时，可以将常量计算好，节省临时变量的使用。

```c
t2 = index + 4
t2 = t2 * 8
array[index] = t2
```

中间代码使得编译器可以被分为前端和后端。编译器前端负责产生机器无关的中间代码，编译器后端将中间代码转换成目标机器代码。这样对于一些可以跨平台的编译器而言，它们可以针对不同的平台使用同一个前端和针对不同机器平台的数个后端。

> 联想嵌入式开发，一套代码，运行在多个不同 SOC 芯片平台，使用交叉编译的方式即可。



#### 2.2.5 目标代码生成与优化

目标代码中有变量定义在其他模块，该怎么办？事实上，定义其他模块的全局变量和函数在最终运行时的绝对地址都要在最终链接的时候才能确定。所以现代的编译器可以将一个源代码文件编译成一个未链接的目标文件，然后由链接器最终将这些目标文件链接起来形成可执行文件。



### 2.3 链接器年龄比编译器长

重新计算各个目标的地址过程被叫做重定位（Relocation）。



用符号来标记位置。

后续汇编器在每次汇编程序的时候会重新计算对应符号的地址，然后把所有引用该符号的指令，修正到这个正确的地址。整个过程不需要人工参与。



一个程序被分割成多个模块以后，如何形成一个单一的程序是须解决的问题。

模块之间如何组合的问题可以归结为模块之间如何通信的问题。

最常见的属于静态语言的 C/C++ 模块之间通信有两种方式，如下所示，又可以归结为一种方式，即模块间符号的引用。

- 一种是模块间的函数调用
- 一种是模块间的变量访问



### 2.4 模块拼装——静态链接

人们把每个源代码模块独立地编译，然后按照需要将它们“组装”起来，这个组装模块的过程就是链接（Linking）。链接的主要内容就是把各个模块之间相互引用的部分都处理好，使得各个模块之间能够正确地衔接。



链接过程主要包括了地址和空间分配（Address and Storage Allocation）、符号决议（Symbol Resolution）和重定位（Relocation）等这些步骤。



符号决议有时候也被叫做符号绑定（Symbol Binding）、名称绑定（Name Binding）、名称决议（Name Resolution），甚至还有叫做地址绑定（Address Binding）、指令绑定（Instruction Binding）

“决议”更倾向于静态链接，而“绑定”更倾向于动态链接，在静态链接，我们将统一称为符号决议。



Object 称为中间目标文件比较合适，简称为目标文件。很多时候也会把目标文件称为模块。



使用链接器，你可以直接引用其他模块的函数和全局变量而无须知道它们的地址，因为链接器在链接的时候，会根据你所引用的符号 foo，自动去相应的func.c模块查找foo的地址，然后将main.c模块中所有引用到foo的指令重新修正，让它们的目标地址为真正的foo函数的地址。这就是静态链接的最基本的过程和作用。



重定位（Relocation）



### 2.5 本章小结

从程序源代码到最终可执行文件的 4 个步骤：预编译、编译、汇编、链接。



## 第3章 目标文件里有什么

### 3.1 目标文件的格式

当前 PC 平台流行的可执行文件格式（Executable）主要是 Windows 的 PE （Portable Executable）和 Linux 的 ELF（Executable Linkable Format）。都是 COFF （Common file format）格式的变种。

从广义上看，目标文件与可执行文件的格式其实几乎是一样的，所以我们可以广义地将目标文件与可执行文件看成是一种类型的文件，在Windows下，我们可以统称它们为PE-COFF文件格式。在Linux下，我们可以将它们统称为ELF文件。其他不太常见的可执行文件格式还有Intel/Microsoft的OMF（Object Module Format）、Unix a.out格式和MS-DOS .COM格式等。



动态链接库（DLL，Dynamic Linking Library ）

静态链接库（Static Linking Library）



ELF文件标准里面把系统中采用ELF格式的文件归为如下表所列举的4类。
![image-20241017230105764](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202410172301414.png)



COFF的主要贡献是在目标文件里面引入了“段”的机制，不同的目标文件可以拥有不同数量及不同类型的“段”。另外，它还定义了调试数据格式。



### 3.2 目标文件是什么样的

一般目标文件将这些信息按不同的属性，以“节”（Section）的形式存储，有时候也叫“段”（Segment）。



源代码编译后的机器指令放在代码段（Code Section），常见名字有 .code / .text 。

全局变量和局部静态变量数据经常放在数据段（Data Section），常见名字 .data 。



ELF 文件的开头是一个 “文件头” ，描述了整个文件的文件属性。

包括一个段表（Section Table），段表其实是一个描述文件中各个段的数组。段表描述了文件中各个段在文件中的偏移位置及段的属性等，从段表里面可以得到每个段的所有信息。



已初始化的全局变量和局部静态变量都保存在. data段；未初始化的全局变量和局部静态变量一般放在一个叫.“bss”的段里。

.bss 段只是为未初始化的全局变量和局部静态变量预留位置，并没有内容，所以在文件中也不占据空间。



BSS（Block Started by Symbol）



### 3.3 挖掘 SimpleSection.o

真正了不起的程序员对自己的程序的每一个字节都了如指掌。——佚名



#### 3.3.1 代码段

objdump 使用参数

- -h ：把 ELF 文件的各个段的基本信息打印出来；
- -x ：把更多的信息打印出来；—— macOS系统实测不支持；
- -s ：将所有段的内容以十六进制的方式打印出来；
- -d ：将所有包含指令的段反汇编；

```shell
zhaochen@zhaochendeAir code_3.01 % objdump -s -d SimpleSection.o 

SimpleSection.o:        file format mach-o arm64
Contents of section __TEXT,__text:
 0000 ff8300d1 fd7b01a9 fd430091 a0c31fb8  .....{...C......
 0010 a9c35fb8 e80309aa e9030091 280100f9  .._.........(...
 0020 00000090 00000091 00000094 fd7b41a9  .............{A.
 0030 ff830091 c0035fd6 ff8300d1 fd7b01a9  ......_......{..
 0040 fd430091 bfc31fb8 28008052 e80b00b9  .C......(..R....
 0050 08000090 080140b9 09000090 290140b9  ......@.....).@.
 0060 0801090b e90b40b9 0801090b e90740b9  ......@.......@.
 0070 0001090b 00000094 e00b40b9 fd7b41a9  ..........@..{A.
 0080 ff830091 c0035fd6                    ......_.
Contents of section __DATA,__data:
 0088 54000000 55000000                    T...U...
Contents of section __TEXT,__cstring:
 0090 25640a00                             %d..
Contents of section __DATA,__bss:
<skipping contents of bss section at [00d8, 00dc)>
Contents of section __LD,__compact_unwind:
 0098 00000000 00000000 38000000 00000004  ........8.......
 00a8 00000000 00000000 00000000 00000000  ................
 00b8 38000000 00000000 50000000 00000004  8.......P.......
 00c8 00000000 00000000 00000000 00000000  ................

Disassembly of section __TEXT,__text:

0000000000000000 <ltmp0>:
       0: d10083ff      sub     sp, sp, #0x20
       4: a9017bfd      stp     x29, x30, [sp, #0x10]
       8: 910043fd      add     x29, sp, #0x10
       c: b81fc3a0      stur    w0, [x29, #-0x4]
      10: b85fc3a9      ldur    w9, [x29, #-0x4]
      14: aa0903e8      mov     x8, x9
      18: 910003e9      mov     x9, sp
      1c: f9000128      str     x8, [x9]
      20: 90000000      adrp    x0, 0x0 <ltmp0>
      24: 91000000      add     x0, x0, #0x0
      28: 94000000      bl      0x28 <ltmp0+0x28>
      2c: a9417bfd      ldp     x29, x30, [sp, #0x10]
      30: 910083ff      add     sp, sp, #0x20
      34: d65f03c0      ret

0000000000000038 <_main>:
      38: d10083ff      sub     sp, sp, #0x20
      3c: a9017bfd      stp     x29, x30, [sp, #0x10]
      40: 910043fd      add     x29, sp, #0x10
      44: b81fc3bf      stur    wzr, [x29, #-0x4]
      48: 52800028      mov     w8, #0x1                ; =1
      4c: b9000be8      str     w8, [sp, #0x8]
      50: 90000008      adrp    x8, 0x0 <ltmp0>
      54: b9400108      ldr     w8, [x8]
      58: 90000009      adrp    x9, 0x0 <ltmp0>
      5c: b9400129      ldr     w9, [x9]
      60: 0b090108      add     w8, w8, w9
      64: b9400be9      ldr     w9, [sp, #0x8]
      68: 0b090108      add     w8, w8, w9
      6c: b94007e9      ldr     w9, [sp, #0x4]
      70: 0b090100      add     w0, w8, w9
      74: 94000000      bl      0x74 <_main+0x3c>
      78: b9400be0      ldr     w0, [sp, #0x8]
      7c: a9417bfd      ldp     x29, x30, [sp, #0x10]
      80: 910083ff      add     sp, sp, #0x20
      84: d65f03c0      ret
zhaochen@zhaochendeAir code_3.01 %
```



#### 3.3.2 数据段和只读数据段

分别对应代码中已初始化的变量 84 / 85 。

```shell
Contents of section __DATA,__data:
 0088 54000000 55000000                    T...U...
```



#### 3.3.3 BSS段

BSS 段存放未初始化的全局变量和局部静态变量。



```c
// 存放在 .bss 段中
static int x1 = 0;

// 存放在 .data 段中
static int x2 = 1;
```

上述代码，初始化值为 0 ，可以认为是未初始化的，因此放到 .bss ，这样可以节省磁盘空间。x2 初始化为 1 ，认为是初始化的，所以放在 .data 段中。



#### 3.3.4 其他段

ELF 一些常见段参考下表

![image-20241020152936975](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202410201529119.png)

这些段的名字都是由 “.” 做前缀，表示这些表的名字是系统保留的。应用程序也可以自定义短命，但不能用 “.” 做前缀，否则容易与系统保留段名冲突。



如下示例，可以将一个 image.jpg 图片，作为目标文件中的一个段。

```shell
$ objcopy -I binary -O elf32-i386 -B i386 image.jpg image.o 
$ objdump -ht image.o

image.o:     file format elf32-i386

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00081200  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
SYMBOL TABLE:
00000000 l    d  .data  00000000 .data
00000000 g       .data  00000000 _binary_image_jpg_start
00081200 g       .data  00000000 _binary_image_jpg_end
00081200 g       *ABS*  00000000 _binary_image_jpg_size
```

_binary_image_jpg_start / _binary_image_jpg_end / _binary_image_jpg_size，代表图片在内存中的起始地址、结束地址和大小。



**自定义段**

```c
__attribute__((section("FOO"))) int global = 42;

__attribute__((section("BAR"))) void foo()
{
}
```

在全局变量或函数之前加上 `__attribute__((section("name")))` 属性，就可以把相应的变量或函数放到以 `name` 作为段名的段中。



### 3.4 ELF文件结构描述

ELF 目标文件的总体结构如下图

![image-20241023230754113](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202410232307252.png)



ELF文件头（ELF Header），它包含了描述整个文件的基本属性，比如ELF文件版本、目标机器型号、程序入口地址等。

段表（Section Header Table），该表描述了ELF文件包含的所有段的信息，比如每个段的段名、段的长度、在文件中的偏移、读写权限及段的其他属性。



#### 3.4.1 文件头

可以使用 readelf -h 命令查看目标文件头。macOS系统用 `otool` 命令代替。

```shell
zhaochen@zhaochendeAir code_3.01 % otool -h SimpleSection.o 
SimpleSection.o:
Mach header
      magic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
 0xfeedfacf 16777228          0  0x00           1     4        600 0x00002000
zhaochen@zhaochendeAir code_3.01 % 
zhaochen@zhaochendeAir code_3.01 % 
zhaochen@zhaochendeAir code_3.01 % otool -hV SimpleSection.o
SimpleSection.o:
Mach header
      magic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64   ARM64        ALL  0x00      OBJECT     4        600 SUBSECTIONS_VIA_SYMBOLS
zhaochen@zhaochendeAir code_3.01 % 
```





ELF 魔数（幻数）解析如下

![image-20241023232556571](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202410232325686.png)



**各种魔数的由来**

“a.out格式的魔数为0x01、0x07，为什么会规定这个魔数呢？

  UNIX早年是在PDP小型机上诞生的，当时的系统在加载一个可执行文件后直接从文件的第一个字节开始执行，人们一般在文件的最开始放置一条跳转（jump）指令，这条指令负责跳过接下来的7个机器字的文件头到可执行文件的真正入口。而0x01 0x07这两个字节刚好是当时PDP-11的机器的跳转7个机器字的指令。



**ELF文件标准历史**

文件类型 `e_type` 成员表示 ELF 文件类型。

![image-20241023233726133](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202410232337264.png)



 #### 3.4.2 段表



**数组的存放方式**

`Elf32_Shdr` 定义可以参考 “/usr/include/elf.h”



![image-20241030231847131](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202410302318297.png)



#### 3.4.3 重定位表

`.rel.text`段，类型 `sh_type` 为 `SHT_REL` ，即重定位表（Relocation Table）。

.rel 是不同段，重定位表的前缀。比如 .data 段如果有重定位表，即为：.rel.data ；



#### 3.4.4 字符串表

ELF文件中用到了很多字符串，比如段名、变量名等。因为字符串的长度往往是不定的，所以用固定的结构来表示它比较困难。一种很常见的做法是把字符串集中起来存放到一个表，然后使用字符串在表中的偏移来引用字符串。



### 3.5 链接的接口——符号

链接过程只关心全局符号的相互“粘合”，局部符号、段名、行号等都是次要的，对于其他目标文件来说是“不可见”的，在链接过程中也是无关紧要的。



#### 3.5.1 ELF符号表结构

符号表的结构是一个 Elf32_Sym 结构的数组。



符号值，如果该符号是一个函数或变量的定义，那么符号的值就是这个函数或变量的地址。



#### 3.5.2 特殊符号

`__executable_start`，该符号为程序起始地址，注意，不是入口地址，是程序的最开始的地址。

`__etext`或`_etext`或`etext`，该符号为代码段结束地址，即代码段最末尾的地址。

`_edata`或`edata`，该符号为数据段结束地址，即数据段最末尾的地址。

`_end`或`end`，该符号为程序结束地址。





#### 3.5.3 符号修饰与函数签名

目的：防止符号名出现冲突。

GCC编译器也可以通过参数选项“-fleading-underscore”或“-fno-leading-underscore”来打开和关闭是否在C语言符号前加上下划线。



**C++符号修饰**

为了支持 C++ 更多的特性，比如函数重载等，发明了符号修饰（Name Decoration）或符号改编（Name Mangling）的机制。



```c++
int func(int);
float func(float);

class C
{
    int func(int);
    class C2
    {
        int func(int);
    };
};

namespace N
{
    int func(int);
    class C
    {
        int func(int);
    };
}


```



函数签名（Function Signature），函数签名包含了一个函数的信息，包括函数名、它的参数类型、它所在的类和名称空间及其他信息。

编译器在将C++源代码编译成目标文件时，会将函数和变量的名字进行修饰，形成符号名。

![image-20241102224517638](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202411022245794.png)



尝试在 macOS 下，用 `c++filt` 工具解析，没解析出来……

![image-20241102224839795](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202411022248879.png)



#### 3.5.4 extern "C"

使用 C++ 编译时的默认宏定义，避免 C 语言没有 extern 语法时的错误。

```c++
#ifdef __cplusplus
extern "C" {
#endif

void *memset (void *, int, size_t);

#ifdef __cplusplus
}
#endif
```



#### 3.5.5 弱符号与强符号

两个不同的文件，都定义了一个全局整形变量，并都做了初始化，那么链接器在链接时就会报错。这两种符号的定义可以称为强符号。

对于C/C++语言来说，编译器默认函数和初始化了的全局变量为强符号，未初始化的全局变量为弱符号。



规则1：不允许强符号被多次定义（即不同的目标文件中不能有同名的强符号）；如果有多个强符号定义，则链接器报符号重复定义错误。

规则2：如果一个符号在某个目标文件中是强符号，在其他文件中都是弱符号，那么选择强符号。

规则3：如果一个符号在所有目标文件中都是弱符号，那么选择其中占用空间最大的一个。



**弱引用和强引用**

目前我们所看到的对外部目标文件的符号引用在目标文件被最终链接成可执行文件时，它们须要被正确决议，如果没有找到该符号的定义，链接器就会报符号未定义错误，这种被称为强引用（Strong Reference）。与之相对应还有一种弱引用（Weak Reference），在处理弱引用时，如果该符号有定义，则链接器将该符号的引用决议；如果该符号未被定义，则链接器对于该引用不报错。

链接器处理强引用和弱引用的过程几乎一样，只是对于未定义的弱引用，链接器不认为它是一个错误。一般对于未定义的弱引用，链接器默认其为0，或者是一个特殊的值，以便于程序代码能够识别。



### 3.6 调试信息

调试信息通常比原版本大很多，在发布软件的时候，可以裁剪

```shell
strip foo
```



### 3.7 本章小结

ELF 文件；代码段、数据段、BSS段等。

无论是可执行文件、目标文件或库，都是一样基于段的文件或是这种文件的集合。



## 4 静态链接

以如下两个源代码文件为例，展开说明静态链接过程

```c
// a.c
extern int shared;

int main()
{
    int a = 100;
    swap(&a, &shared);
}
```



```c
// b.c
int shared = 1;

void swap(int *a, int *b)
{
    *a ^= *b ^= *a ^= *b;
}
```



### 4.1 空间与地址分配

问：对于多个输入目标文件，链接器如何将它们的各个段合并到输出文件？



#### 4.1.1 按序叠加

一个最简单的方案就是将输入的目标文件按照次序叠加起来。但是会造成大量资源浪费。

![image-20241110142839207](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202411101428326.png)



#### 4.1.2 相似段合并

将相同性质的段合并到一起，比如所有的 `.text` 合并到输出文件的 `.text` 段；其次还有 `.data` 和 `.bss` 段等。

![image-20241110143447077](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202411101434146.png)



地址和空间”其实有两个含义：第一个是在输出的可执行文件中的空间；第二个是在装载后的虚拟地址中的虚拟地址空间。



**两步链接（Two-pass Linking）**

第一步 空间与地址分配 扫描所有的输入目标文件，并且获得它们的各个段的长度、属性和位置，并且将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局符号表。这一步中，链接器将能够获得所有输入目标文件的段长度，并且将它们合并，计算出输出文件中各个段合并后的长度与位置，并建立映射关系。

第二步 符号解析与重定位 使用上面第一步中收集到的所有信息，读取输入文件中段的数据、重定位信息，并且进行符号解析与重定位、调整代码中的地址等。事实上第二步是链接过程的核心，特别是重定位过程。



使用如下命令执行链接过程

```shell
ld a.o b.o -e main -o ab

# -e main 表示将main函数作为程序入口，ld链接器默认的程序入口为_start。
# -o ab 表示链接输出文件名为ab，默认为a.out。
```



VMA（Virtual Memory Address），虚拟地址；优先关注。

LMA（Load Memory Address），加载地址；



在Linux下，ELF可执行文件默认从地址0x08048000开始分配。



#### 4.1.3 符号地址的确定

函数相对于段的位置偏移，当段的虚拟起始地址确定后，需要重新计算函数的虚拟地址偏移。



### 4.2 符号解析与重定位

#### 4.2.1 重定位

完成空间和地址分配后，链接器就进入了符号解析与重定位的步骤。



#### 4.2.2 重定位表

以 x86 处理器为例，重定位表是一个 Elf32_Rel 结构的数组

```c
typedef struct {
    Elf32_Addr r_offset;
    Elf32_Word r_info;
} Elf32_Rel;
```

![image-20241111223720299](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202411112237459.png)



#### 4.2.3 符号解析

如果只单独链接其中一个 .o 文件，就会报未定义错误。

```shell
$ ld a.o
a.o: In function `main':
a.c:(.text+0x1c): undefined reference to `shared'
a.c:(.text+0x27): undefined reference to `swap'
```

链接时符号未定义。导致这个问题的原因很多，最常见的一般都是链接时缺少了某个库，或者输入目标文件路径不正确或符号的声明与定义不一样。



#### 4.2.4 指令修正方式

> 有点没看懂，后续再继续深入理解。2024.11.12

绝对寻址修正和相对寻址修正的区别就是绝对寻址修正后的地址为该符号的实际地址；相对寻址修正后的地址为符号距离被修正位置的地址差。



### 4.3 COMMON块

多个符号定义类型不一致的情况，有如下三种：

- 两个或两个以上强符号类型不一致；
- 有一个强符号，其他都是弱符号，出现类型不一致；
- 两个或两个以上弱符号类型不一致；

第一种无需额外处理，因为多个强符号定义本身就是非法的，链接器会报符号多重定义错误。



都是弱符号时，最终链接后的输出文件中，以输入文件中占用空间最大的那个为准。



如果其中有一个符号为强符号，那么最终输出结果中的符号所占空间与强符号相同。如果链接过程中有弱符号大小大于强符号，那么 ld 链接器会报如下警告：

```shell
ld: warning: alignment 4 of symbol `global’ in a.o is smaller than 8 in b.o
```



使用 COMMON 块类似一种取巧的方式，原因是编译器和和链接器允许不同类型的弱符号存在，但最本质的原因还是链接器不支持符号类型，即链接器无法判断各个符号的类型是否一致。



GCC 的 `-fno-common` 选项，允许我们把所有未初始化的全局变量不以COMMON块的形式处理，或者使用“__attribute__”扩展：

```c
int global __attribute__((nocommon));
```

一旦一个未初始化的全局变量不是以COMMON块的形式存在，那么它就相当于一个强符号，如果其他目标文件中还有同一个变量的强符号定义，链接时就会发生符号重复定义错误。



### 4.4 C++相关问题

C++ 的一些语言特性需要编译器和链接器共同支持，主要有两个方面：

- C++ 的重复代码消除；
- 全局构造与析构；



#### 4.4.1 重复代码消除

C++ 编译器很多时候会产生重复的代码，比如模板、外部内联函数和虚函数表等。

如果不管这些重复代码，可能会造成如下问题：

- 空间浪费；
- 地址较易出错；
- 指令运行效率较低；



**函数级别链接**

VISUAl C++ 编译器提供了一个编译选项叫函数级别链接（Functional-Level Linking, /Gy）

GCC编译器也提供了类似的机制，它有两个选择分别是“-ffunction-sections”和“-fdata-sections”，这两个选项的作用就是将每个函数或变量分别保持到独立的段中。



#### 4.4.2 全局构造与析构

C++的全局对象的构造函数在main之前被执行，C++全局对象的析构函数在main之后被执行。



Linux 系统下一般程序的入口时 “_start” ，该函数是 Linux 系统库（Glibc）的一部分。

基于此，ELF 文件定义了两种特殊的段

- .init ，该段里面保存的是可执行指令，它构成了进程的初始化代码。
- .fint ，该段保存着进程终止代码指令。



#### 4.4.3 C++与ABI

ABI（Application Binary Interface），与可执行代码二进制兼容性相关

API（Application Programming Interface）

API 相同并不表示 ABI 相同。



> 目前并未彻底解决ABI的问题，由于现实的因素，这个问题还会长期地存在，这也是为什么有这么多像我们这样的程序员能够存在的原因。
>



### 4.5 静态库链接

很多 .o 会造成使用不方便，所以人们通常使用 ar 压缩程序将这些目标文件压缩到一起。

PS：联想到今天搞的 GDB 编译，也传进去了 AR 交叉编译工具；



Visual C++ 提供了类似 ar 的工具，叫 lib.exe 。



Q：为什么静态运行库里面一个目标文件只包含一个函数？比如libc.a里面printf.o只有printf()函数、strlen.o只有strlen()函数，为什么要这样组织？

A：我们知道，链接器在链接静态库的时候是以目标文件为单位的。比如我们引用了静态库中的printf()函数，那么链接器就会把库中包含printf()函数的那个目标文件链接进来，如果很多函数都放在一个目标文件中，很可能很多没用的函数都被一起链接进了输出结果中。由于运行库有成百上千个函数，数量非常庞大，每个函数独立地放在一个目标文件中可以尽量减少空间的浪费，那些没有被用到的目标文件（函数）就不要链接到最终的输出文件中。



### 4.6 链接过程控制

#### 4.6.1 链接控制脚本

链接器控制整个链接过程的方法，一般有如下三种

- 使用命令行来给链接器指定参数；
- 将链接指令存放在目标文件里面；
- 使用链接控制脚本；



#### 4.6.2 最“小”的程序

不实用 C 语言库，不实用默认 main 程序入口

```c
char *str = "Hello world!\n";

void print()
{
    asm( "movl $13,%%edx \n\t"
       	 "movl %0,%%ecx  \n\t"
         "movl $0,%%ebx  \n\t"
         "movl $4,%%eax  \n\t"
         "int $0x80      \n\t"
       ::"r"(str):"edx","ecx","ebx");
}

void exit()
{
    asm( "movl $42,%ebx  \n\t"
         "movl $1,%eax   \n\t"
         "int $0x80      \n\t");
}

void nomain()
{
    print();
    exit();
}
```



编译链接命令如下：

```shell
gcc -c -fno-builtin TinyHelloWorld.c
ld -static -e nomain -o TinyHelloWorld TinyHelloWorld.o
```



`-fno-builtin` GCC编译器提供了很多内置函数（Built-in Function），它会把一些常用的C库函数替换成编译器的内置函数，以达到优化的功能。比如GCC会将只有字符串参数的printf函数替换成puts，以节省格式解析的时间。exit()函数也是GCC的内置参数之一，所以我们要使用-fno-builtin参数来关闭GCC内置函数功能。

`static` 这个参数表示ld将使用静态链接的方式来链接程序，而不是使用默认的动态链接的方式。

`-e nomain` 表示该程序的入口函数为nomain，还记得ELF文件头Elf32_Ehdr的e_entry成员吗？这个参数就是将ELF文件头的e_entry成员赋值成nomain函数的地址。

`-o TinyHelloWorld` 表示指定输出可执行文件名为TinyHelloWorld。





#### 4.6.3 使用ld链接脚本

可以用 -s 参数禁止链接器产生符号表；也可以使用 strip 命令来去除程序中的符号表。

> PS：联想到 strip 裁剪过程，应该是把可执行文件或动态库中，不需要的段删掉，以此节省空间。



42 为进程退出码正常退出进程，没有任何输入和输出。



#### 4.6.4 ld链接脚本语法简介

链接脚本由一系列语句组成，语句分两种

- 命令语句
- 赋值语句

ENTRY（nomain）即为命令语句。



![image-20241120081807632](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202411200818761.png)



### 4.7 BFD库

BFD库（Binary File Descriptor library）



### 4.8 本章小结

静态链接的步骤。

各个段合并到输出文件，链接器分配段在输出文件中的空间和地址。



## 5 Windows PE/COFF

### 5.1 Windows的二进制文件格式PE/COFF

要实现程序员将变量或函数放到自定义的段，在 GCC 中可以使用 `__attribute__((section("name")))` 扩展属性；在 VISUAL C++ 中可以使用 `#pragma` 编译器指示。



### 5.2 PE的前身——COFF

Linux 下的 objdump ，类比到 Windows 下，替换为 dumpbin 。



**COFF文件结构**

COFF 目标文件格式如下

![image-20241127082226988](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202411270822704.png)



### 5.3 链接指示信息

LIBCMT（Library C Multithreaded），表示 VC 的静态链接的多线程 C 库。



### 5.4 调试信息

COFF 中所有 `.debug` 开始的段都包含着调试信息。



### 5.5 大家都有符号表

COFF 文件的符号表包含的内容几乎跟 ELF 文件的符号表一样，主要就是符号名、符号的类型、所在的位置。



### 5.6 Windows下的ELF——PE

PE 是基于 COFF 的扩展。在设计之初，就为了兼容 DOS 环境独立运行。PE 文件格式如下图所示：

![image-20241203081613804](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202412030816961.png)



DOS Stub 是一段可以在 DOS 下运行的一小段代码。



#### 5.6.1 PE 数据目录

导入表、导出表、资源、重定位表等。这些常用的数据的位置和长度都被保存在了一个叫数据目录（Data Directory）的结构里面



### 5.7 本章小结

COFF文件有一个很有意思的段叫“.drectve段”，这个段中保存的是编译器传递给链接器的命令行参数，可以通过这个段实现指定运行库等功能。



# 第3部分 转载与动态链接

## 第6章 可执行文件的装载与进程

通过 ELF 文件在 Linux 下的装载过程，学习整个流程。



### 6.1 进程虚拟地址空间

**程序和进程有什么区别**

程序（或者狭义上讲可执行文件）是一个静态的概念，它就是一些预先编译好的指令和数据集合的一个文件；进程则是一个动态的概念，它是程序运行时的一个过程，很多时候把动态库叫做运行时（Runtime）也有一定的含义。



每个程序运行起来后，都将拥有自己独立的虚拟地址空间（Virtual Address Space），大小由硬件平台决定。

硬件决定了地址空间的最大理论上限，即硬件的寻址空间大小，比如32位的硬件平台决定了虚拟地址空间的地址为 0 到 2^32-1，即0x00000000～0xFFFFFFFF，也就是我们常说的4 GB虚拟空间大小；而64位的硬件平台具有64位寻址能力，它的虚拟地址空间达到了264字节，即0x0000000000000000～0xFFFFFFFFFFFFFFFF，总共17 179 869 184 GB



Linux 下的 Segmentation fault 很多时候是因为进程访问了未经允许的地址。



Windows 可以通过修改系统盘根目录的 Boot.ini ，加上 `/3G` 参数，实现操作系统从原来的 2GB 改为只占用 1GB 。

```shell
[boot loader]
timeout=30
default=multi(0)disk(0)rdisk(0)partition(1)\WINDOWS
[operating systems]
multi(0)disk(0)rdisk(0)partition(1)\WINDOWS="Microsoft Windows XP Professional" /3G /fastdetect /NoExecute=OptIn
```



**PAE**

Pyhsical Address Extension ，地址扩展方式。



### 6.2 装载的方式

内存太贵，如何在有限的内存空间下，让更多的程序跑起来？

根据程序运行时的局部性原理，将最常用的部分驻留在内存中，而将一些不太常用的数据存放在磁盘里面，这就是动态装入的基本原理。

覆盖装入（Overlay）和页映射（Paging）是两种很典型的动态装载方法。



#### 6.2.1 覆盖装入

覆盖装入的方法把挖掘内存潜力的任务交给了程序员，程序员在编写程序的时候必须手工将程序分割成若干块，然后编写一个小的辅助代码来管理这些模块何时应该驻留内存而何时应该被替换掉。这个小的辅助代码就是所谓的覆盖管理器（Overlay Manager）。



禁止跨树间调用。



由于跨模块间的调用都需要经过覆盖管理器，以确保所有被调用到的模块都能够正确地驻留在内存，而且一旦模块没有在内存中，还需要从磁盘或其他存储器读取相应的模块，所以覆盖装入的速度肯定比较慢，不过这也是一种折中的方案，是典型的利用时间换取空间的方法。



#### 6.2.2 页映射

FIFO，先进先出算法

LUR，最少使用算法



### 6.3 从操作系统角度看可执行文件的装载



#### 6.3.1 进程的建立

创建一个进程，然后装载相应的可执行文件并且执行。在有虚拟存储的情况下，上述过程最开始只需要做三件事情：

- 创建一个独立的虚拟地址空间。
- 读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系。
- 将CPU的指令寄存器设置成可执行文件的入口地址，启动运行。



Linux中将进程虚拟空间中的一个段叫做虚拟内存区域（VMA, Virtual Memory Area）；在Windows中将这个叫做虚拟段（Virtual Section）。



#### 6.3.2 页错误

延伸：内核打印出来的错误信息，其实应该是某些段的与内存中地址的映射。即，通过打印出来的地址，可以反向找到在哪个库哪个代码出现了问题。



### 6.4 进程虚存空间分布

#### 6.4.1 ELF文件链接视图和执行视图

ELF文件中，段的权限往往只有为数不多的几种组合，基本上是三种：

- 以代码段为代表的权限为可读可执行的段。

- 以数据段和BSS段为代表的权限为可读可写的段。

- 以只读数据段为代表的权限为只读的段。



#### 6.4.2 堆和栈

在 Linux 下，可以通过 `/proc` 来查看进程的虚拟空间分布。

匿名虚拟内存区域（Anonymous Virtual Memory Area）

堆（Heap）和栈（Stack）



操作系统通过给进程空间划分出一个个VMA来管理进程的虚拟空间；基本原则是将相同权限属性的、有相同映像文件的映射成一个VMA；一个进程基本上可以分为如下几种VMA区域：

- 代码VMA，权限只读、可执行；有映像文件。
- 数据VMA，权限可读写、可执行；有映像文件。
- 堆VMA，权限可读写、可执行；无映像文件，匿名，可向上扩展。
- 栈VMA，权限可读写、不可执行；无映像文件，匿名，可向下扩展。



#### 6.4.3 堆的最大申请数量

拷贝测试代码如下

```c
#include <stdio.h>
#include <stdlib.h>

unsigned maximum = 0;

int main(int argc, char *argv[]) 
{
    unsigned blocksize[] = { 1024 * 1024, 1024, 1 };
    int i, count;
    for(i = 0; i < 3; i++) {
        for(count = 1;; count++) {
            void *block = malloc( maximum + blocksize[i] * count); 
            if (block) {
                maximum = maximum + blocksize[i] * count;”
                free(block);
            } else {
                break;
            }
        }
    }

    printf("maximum malloc size = %u bytes\n", maximum);
}
```



#### 6.4.4 段地址对齐

在ELF文件中，对于任何一个可装载的“Segment”，它的p_vaddr除以对齐属性的余数等于p_offset除以对齐属性的余数。比如前面例子中，第二个“Segment”的p_vaddr为0x080b99e8，对齐属性为0x1000字节，所以0x080b99e8 % 0x1000 = 0x9e8；而p_offset为0x0709e8，所以0x0709e8 % 0x1000 = 0x9e8。



#### 6.4.5 进程栈初始化

linux 进程初始堆栈

![image-20241209225007066](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202412092250217.png)



### 6.5 Linux内核装载ELF过程简介

每种可执行文件的格式的开头几个字节都是很特殊的，特别是开头 4 个字节，常常被称作魔术（Magic Number）

ELF 的可执行文件格式的头 4 个字节：0x7F 、'e' 、'l' 、'f'；

Java 的可执行文件格式的头 4 个自己为：'c' / 'a' / 'f' / 'e'

如果是可执行脚本，开头前两个字节通常为 `#!` 。



load_elf_binary() 被定义在 fs/binfmt_elf.c 

参考：https://github.com/torvalds/linux/blob/master/fs/binfmt_elf.c



### 6.6 Windows PE的装载

RVA（Relative Virtual Address ），表示一个相对虚拟地址。相当于文件中的偏移量。



### 6.7 本章小结

程序运行时如何使用内存空间？

- 全部读取
- 中间代码控制，只在内存放用到的；树状结构；
- ……



## 第7章 动态链接

### 7.1 为什么要动态链接

静态链接使用到后边会有一些缺点：浪费内存和磁盘空间、模块更新困难等；



**内存和磁盘空间**

使用静态链接，有多少个程序，就会存在多少个副本。



**程序开发和发布**

如果程序使用静态链接，有任何一个小的改动，都要更新整个程序。



**动态链接**

就是不对那些组成程序的目标文件进行链接，等到程序要运行时才进行链接。也就是说，把链接这个过程推迟到了运行时再进行，这就是动态链接（Dynamic Linking）的基本思想。



在内存中共享一个目标文件模块的好处不仅仅是节省内存，它还可以减少物理页面的换入换出，也可以增加CPU缓存的命中率，因为不同进程间的数据和指令访问都集中在了同一个共享模块上。



动态链接的方式，使得开发过程中各个模块更加独立，耦合度更小，便于不同的开发者和开发组织之间独立进行开发和测试。



**程序可扩展性和兼容性**

程序的插件（Plug-in）



DDL Hell



**动态链接的基本实现**

在Linux系统中，ELF动态链接文件被称为动态共享对象（DSO，Dynamic Shared Objects），简称共享对象，它们一般都是以“.so”为扩展名的一些文件；而在Windows系统中，动态链接文件被称为动态链接库（Dynamical Linking Library），它们通常就是我们平时很常见的以“.dll”为扩展名的文件。



据估算，动态链接与静态链接相比，性能损失大约在5%以下。当然经过实践的证明，这点性能损失用来换取程序在空间上的节省和程序构建和升级时的灵活性，是相当值得的。



### 7.2 简单的动态链接例子

程序清单 7-1 

```c
/* Program1.c */
#include "Lib.h"

int main()
{   
    foobar(1);
    return 0;
}

/* Program2.c */
#include "Lib.h"

int main()
{   
  foobar(2);
    return 0;
}

/* Lib.c */
#include <stdio.h>

void foobar(int i) 
{
    printf("Printing from Lib.so %d\n", i);
}

/* Lib.h */
#ifndef LIB_H
#define LIB_H

void foobar(int i);

#endif
```

使用如下 GCC 命令编译

```shell
gcc -fPIC -shared -o Lib.so Lib.c
```

`-shared`：表示产生共享对象



**关于模块（Module）**

对于函数，可以从输入文件的 *.so 中找到对应符号，这样链接器在解析符号的时候，就可以知道是一个动态符号。



**动态链接程序运行时地址空间分布**

```shell
cat /proc/12985/maps
```

通过如上命令，即可看到进程的虚拟地址空间分布。



共享对象的最终装载地址在编译时是不确定的，而是在装载时，装载器根据当前地址空间的空闲情况，动态分配一块足够大小的虚拟地址空间给相应的共享对象。



### 7.3 地址无关代码

#### 7.3.1 固定装载地址的困扰

早期竟然还有一种静态共享库（Static Shared Library）的东西。



#### 7.3.2 装载时重定位

静态链接时提到过重定位，那时的重定位叫做链接时重定位（Link Time Relocation），而现在这种情况经常被称为装载时重定位（Load Time Relocation），在Windows中，这种装载时重定位又被叫做基址重置（Rebasing）



#### 7.3.3 地址无关代码

`-fPIC`，是什么参数

目的很简单，希望程序模块中共享的指令部分在装载时不需要因为装载地址的改变而改变，所以实现的基本想法就是把指令中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。这种方案就是目前被称为地址无关代码（PIC, Position-independent Code）的技术。



**关于模块内部和模块外部**

对于 extern 的变量/函数，编译时不缺堤ing时模块内部还是外部，因此会默认当作模块外部的函数和变量来处理。

MSVC 编译器提供了 __declspec(dllimport) 编译器扩展指令来表示一个符号是模块内部的还是模块外部的。



**类型一 模块内部调用或跳转**

模块内部的跳转、函数调用都可以是相对地址调用，或者是基于寄存器的相对调用，所以对于这种指令是不需要重定位的。



共享对象全局符号介入（Global Symbol Interposition）





**类型二 模块内部数据访问**

相对寻址 + 偏移量即可。



**类型三 模块间数据访问**

全局偏移表（Global Offset Table, GOT）



**类型四 模块间调用、跳转**

GOT中相应的项保存的是目标函数的地址，当模块需要调用目标函数时，可以通过GOT中的项进行间接跳转。



**地址无关代码小结**

![image-20241221101328774](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202412211013911.png)



**-fpic和-fPIC**

该选项可以产生地址无关代码。



"-fPIC" ，产生的代码要大，而 "-fpic" 产生的代码相对较小，而且较快。



但为何选用 "-fPIC" 呢？

原因是，由于地址无关代码都是跟硬件平台相关的，不同的平台有着不同的实现，“-fpic”在某些平台上会有一些限制，比如全局符号的数量或者代码的长度等，而“-fPIC”则没有这样的限制。所以为了方便起见，绝大部分情况下我们都使用“-fPIC”参数来产生地址无关代码。



**如何区分一个DSO是否为PIC**

```shell
readelf -d foo.so | grep TEXTREL
```

如果上面的命令有任何输出，那么foo.so就不是PIC的，否则就是PIC的。PIC的DSO是不会包含任何代码段重定位表的，TEXTREL表示代码段重定位表地址。



**PIC与PIE**

地址无关代码技术除了可以用在共享对象上面，它也可以用于可执行文件，一个以地址无关方式编译的可执行文件被称作地址无关可执行文件（PIE, Position-Independent Executable）。与GCC的“-fPIC”和“-fpic”参数类似，产生PIE的参数为“-fPIE”或“-fpie”。



#### 7.3.4 共享模块的全局变量问题

ELF共享库在编译时，默认都把定义在模块内部的全局变量当作定义在其他模块的全局变量，也就是说当作前面的类型四，通过GOT来实现变量的访问。

- 如果该全局变量在可执行文件中有副本，动态链接器就把 GOT 中的相应模块指向该副本。
    - 如果该全局变量在共享模块中被初始化，动态链接起需要复制该初始化值到可执行文件主模块中。
- 如果该变量在程序主模块中没有副本，GOT  中的相应地址就指向模块内部的该变量副本。



**Q&A**

进程A 与进程 B，访问的是同一个 lib.so 的不同副本，所以数据是分开的。

但是同一个进程里边的，线程A和线程B，访问的是同一个进程地址空间，也就是同一个副本，所以对于数据/变量的修改，对方是都可以看得到的。



线程私有存储（Thread Local Storage）



#### 7.3.5 数据段地址无关性

如果数据段中有绝对地址引用，那么编译器和链接器就会产生一个重定位表，这个重定位表里面包含了“R_386_RELATIVE”类型的重定位入口



### 7.4 延迟绑定（PLT）

动态链接比静态链接慢的主要原因是

- 动态链接下对于全局和静态的数据访问都要进行复杂的GOT定位，然后间接寻址；对于模块间的调用也要先定位GOT。
- 动态链接的链接工作在运行时完成。



**延迟绑定实现**

延迟绑定（Lazy Binding），当函数第一次被用到的时候才进行绑定（符号查找、重定位）



PLT（Procedure Linkage Table）



PLT 在 ELF 中以独立的段存放，段名通常叫做 .plt ，本身是一些地址无关的代码，所以可以跟代码段等一起合并成同一个可读可执行的 segmeng 被装载入内存。



### 7.5 动态链接相关结构

动态链接器（Dynamic Linker）



加载完可执行文件之后，回先加载动态链接器，然后会把控制权交给动态链接器。之后动态链接器会开始一系列自身的初始化操作。之后会把控制权转移到可执行文件的入口地址，程序开始正式执行。



#### 7.5.1 ".interp"段

interp 是 interpreter 解释器的缩写。



#### 7.5.2 ".dynamic"段

"elf.h"

```c
typedef struct {
    Elf32_Sword d_tag;
    union {
        Elf32_Word d_val;
        Elf32_Addr d_ptr;
    } d_un;
} Elf32_Dyn;
```



ldd 命令可以用来查看一个程序主模块、或一个共享库依赖于哪些共享库。



#### 7.5.3 动态符号表

符号表，Symbol Table，.symtab

动态符号表，Dynamic Symbol Table，.dynsym



#### 7.5.4 动态链接重定位表

PIC 模式的共享对象也需要重定位。



**动态链接重定位相关结构**

```shell
readelf -r Lib.so
```



#### 7.5.5 动态链接时进程堆栈初始化信息

```c
#include <stdio.h>
#include <elf.h>

int main(int argc, char* argv[])
{
    int* p = (int*)argv;
    int i;
    Elf32_auxv_t* aux;    
    
    printf("Argument count: %d\n", *(p-1));
    
for(i = 0; i < *(p-1); ++i) {
        printf("Argument %d : %s\n", i, *(p + i) );
}

    p += i;
    p++; // skip 0
    
    printf("Environment:\n");
    while(*p) {
        printf("%s\n",*p);
        p++;
    }

    p++; // skip 0

    printf("Auxiliary Vectors:\n");
    aux = (Elf32_auxv_t*)p;
    while(aux->a_type != AT_NULL) {
        printf("Type: %02d Value: %x\n", aux->a_type, aux->a_un.a_val);
        aux++;
    }

    return 0;
}
```





### 7.6 动态链接的步骤和实现

动态链接的步骤基本分为三步：

- 启动动态链接器本身
- 装载所有需要的共享对象
- 重定位和初始化



#### 7.6.1 动态链接器自举

为避免动态链接器仍可以链接其他共享库的问题，提出了两点要求

- 动态链接器本身不可以依赖于其他任何共享对象；
- 动态链接器本身所需要的全局和静态变量的重定位工作由他本身完成；



第二个条件，用到的启动代码，被称为自举（Bootstrap）

自举代码不可以使用任何全局变量，也不可以调用函数。



#### 7.6.2 装载共享对象

深度优先、或广度优先、或其他顺序来遍历整个图。比较常见的算法一般都是广度优先。



当一个新的共享对象被装载进来的时候，它的符号表会被合并到全局符号表中。



**符号的优先级**

这种一个共享对象里面的全局符号被另一个共享对象的同名全局符号覆盖的现象又被称为共享对象全局符号介入（Global Symbol Interpose）。



由于这种重名符号被直接忽略的问题，开发代码时要注意下，后边的如果被覆盖，但又是不同的功能，就会有问题。



**全局符号介入与地址无关代码**

用 static 关键字定义为编译单元私有函数。后续编译器就可以用模块内部调用指令，加快函数的调用速度。



#### 7.6.3 重定位和初始化

完成上面的步骤之后，链接器开始重新遍历可执行文件和每个共享对象的重定位表，将 GOT / PLT 中的每个需要重定位的位置进行修正。



#### 7.6.4 Linux动态链接器实现

Linux 动态链接器，本身是一个软链接。



1. 动态链接器本身是动态链接的还是静态链接的？

动态链接器本身应该是静态链接的，它不能依赖于其他共享对象，动态链接器本身是用来帮助其他ELF文件解决共享对象依赖问题的



2. 动态链接器本身必须是PIC的吗？

 是不是PIC对于动态链接器来说并不关键，动态链接器可以是PIC的也可以不是，但往往使用PIC会更加简单一些。



3. 动态链接器可以被当作可执行文件运行，那么的装载地址应该是多少？

ld.so的装载地址跟一般的共享对象没区别，即为0x00000000。这个装载地址是一个无效的装载地址，作为一个共享库，内核在装载它时会为其选择一个合适的装载地址。





### 7.7 显式运行时链接

显式运行时链接（Explicit Run-time Linking），有时也叫运行时加载。



动态装载库（Dynamic Loading Library）



动态库的装载则是通过一系列由动态链接器提供的API，具体地讲共有4个函数：打开动态库（dlopen）、查找符号（dlsym）、错误处理（dlerror）以及关闭动态库（dlclose）



#### 7.7.1 `dlopen()`

第一个参数是被加载动态库的路径。/ 开头，会直接打开；相对路径开头，会进行查找：

- LD_LIBRARY_PATH 指定的路径；
- /etc/ld.so.cache 指定的共享库路径；
- /lib 、/usr/lib 路径；

如果第一个参数为 0 ，那么 dlopen 返回的将是全局符号表的句柄。



第二个参数 flag 表示函数符号的解析方式。

- RTLD_LAZY，延迟绑定，函数第一次用到时才进行绑定，即 PLT 机制；
- RTLD_NOW，在加载时即完成函数绑定；

RTLD_GLOBAL 可以用或的方式，与上边两个一块使用。



返回值是被加载模块的句柄。



模块 A 以来模块 B ，则需要手动先加载模块 B ，再加载模块 A 。



#### 7.7.2 `dlsym()`

对于函数，返回函数地址；

对于变量，返回变量地址；

对于常量，返回常量的值；



**符号优先级**

是当多个同名符号冲突时，先装入的符号优先，我们把这种优先级方式称为装载序列（Load Ordering）



`dlsym()` 对符号的查找优先级分两种类型。

- filename 如果是 NULL ，那就用全局符号表的装载序列。
- 如果是某个特定的共享对象，采用的依赖序列（Dependency Ordering）。



依赖序列：被dlopen()打开的那个共享对象为根节点，对它所有依赖的共享对象进行广度优先遍历，直到找到符号为止。



#### 7.7.3 `dlerror()`

dlerror()的返回值类型是char*，如果返回NULL，则表示上一次调用成功；如果不是，则返回相应的错误消息。



#### 7.7.4 `dlclose()`

`dlopen()`使计数器加一，`dlclose()`使计数器减一。只有当计数器减到 0 时，模块才被真正的卸载。



```c++
#include <stdio.h>
#include <dlfcn.h>

int main(int argc, char* argv[])
{
    void* handle;
    double (*func)(double);
    char* error;
    handle = dlopen(argv[1],RTLD_NOW);
    if(handle == NULL) {
        printf("Open library %s error: %s\n", argv[1], dlerror());
        return -1;
    }

    func = dlsym(handle,"sin");
    if( (error = dlerror()) != NULL ) {
        printf("Symbol sin not found: %s\n", error);
        goto exit_runso;
    }

    printf( "%f\n", func(3.1415926 / 2) );

    exit_runso:
    dlclose(handle);
}
```

执行结果如下

```shell
$gcc –o RunSoSimple RunSoSimple.c –ldl
$./RunSoSimple /lib/libm-2.6.1.so
1.000000
```



#### 7.7.5 运行时装载的演示程序

runso 程序

基本的步骤就是：由命令行给出共享对象路径、函数名和相关参数，然后程序通过运行时加载将该模块加载到进程中，查找相应的函数，并且执行它，然后将执行结果打印出来。



TODO：runso 的代码待完全了解



### 7.8 本章小结

动态链接可以更加有效地利用内存和磁盘资源，可以更加方便地维护升级程序，可以让程序的重用变得更加可行和有效。



## 第8章 Linux共享库的组织

共享库（Shared Library），目前与共享对象，基本没啥差别。



### 8.1 共享库版本

#### 8.1.1 共享库兼容性

更新有两种

- 兼容更新
- 不兼容更新

接口，目前指二进制接口，即 ABI （Application Binary Interface）11

![image-20241229222501473](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202412292225389.png)



导致C语言的共享库 ABI 改变的行为主要有如下 4 个：

- 导出函数的行为发生改变。调用后产生的结果和之前不一样；
- 导出函数被删除；
- 导出数据的结构发生变化，比如结构体变量的结构发生改变；
- 导出函数的接口发生变化，比如函数返回值、参数被更改；



最好不要使用 C++ 作为共享库的接口！



#### 8.1.2 共享库版本命名

Linux 有一套规则来命名系统中的共享库，如下：

```shell
libname.so.x.y.z
```

“x”表示主版本号（Major Version Number），“y”表示次版本号（Minor Version Number），“z”表示发布版本号（Release Version Number）。

主版本号表示库的重大升级，不同主版本号的库之间是不兼容的，依赖于旧的主版本号的程序需要改动相应的部分，并且重新编译，才可以在新版的共享库中运行；或者，系统必须保留旧版的共享库，使得那些依赖于旧版共享库的程序能够正常运行。



次版本号表示库的增量升级，即增加一些新的接口符号，且保持原来的符号不变。



发布版本号表示库的一些错误的修正、性能的改进等，并不添加任何新的接口，也不对接口进行更改。



#### 8.1.3 SO-NAME

在Linux系统中，系统会为每个共享库在它所在的目录创建一个跟“SO-NAME”相同的并且指向它的软链接（Symbol Link）。比如系统中有存在一个共享库“/lib/libfoo.so.2.6.1”，那么Linux中的共享库管理程序就会为它产生一个软链接“/lib/libfoo.so.2”指向它。

> PS：解释了，为啥会有软链接到同名库的现象。



为什么要用 SO-NAME 建立软链接？实际上该软链接会指向目录中主版本号相同、次版本号和发布版本号最新的共享库。



**链接名**

在实际编译的时候，只需要指定前边的名字即可，不需要后边的版本号。



### 8.2 符号版本

次版本号交会问题（Minor-revision Rendezvous Problem）



符号版本机制

共享库的 SO-NAME 不变，指示内部符号，添加相应的版本标记；

> 联想当前在做的项目，会用 attribute 增加版本号声明用作区分；



#### 8.2.2 Solaris中的符号版本机制

```c++
SUNW_1.2 { 
    global: 
    swap; 
} SUNW_1.1;
```



#### 8.2.3 Linux中的符号版本

**GCC对Solaris符号版本机制的扩展**

第一个扩展是，除了可以在符号版本脚本中指定符号的版本之外，GCC还允许使用一个叫做“.symver”的汇编宏指令来指定符号的版本，这个汇编宏指令可以被用在GAS汇编中，也可以在GCC的C/C++源代码中以嵌入汇编指令的模式使用。

第二个扩展是GCC允许多个版本的同一个符号存在于一个共享库中，也就是说，在链接层面提供了某种形式的符号重载机制



**Linux系统中符号版本机制实践**

`--version-script` 与 `-Xlinker` 参数。



### 8.3 共享库系统路径

FHS（File Hierarchy Standard）

FHS规定，一个系统中主要有两个存放共享库的位置，如下：

- `/lib`，这个位置主要存放系统最关键和基础的共享库，比如动态链接器、C语言运行库、数学库等，这些库主要是那些/bin和/sbin下的程序所需要用到的库，还有系统启动时需要的库。
- `/usr/lib`，这个目录下主要保存的是一些非系统运行时所需要的关键性的共享库，主要是一些开发时用到的共享库，这些共享库一般不会被用户的程序或shell脚本直接用到。这个目录下面还包含了开发时可能会用到的静态库、目标文件等。
- `/usr/local/lib`，这个目录用来放置一些跟操作系统本身并不十分相关的库，主要是一些第三方的应用程序的库。



### 8.4 共享库查找过程

动态链接器对于模块的查找有一定的规则：如果DT_NEED里面保存的是绝对路径，那么动态链接器就按照这个路径去查找；如果DT_NEED里面保存的是相对路径，那么动态链接器会在/lib、/usr/lib和由/etc/ld.so.conf配置文件指定的目录中查找共享库。



### 8.5 环境变量

LD_LIBRARY_PATH



动态链接器会按照下列顺序依次装载或查找共享对象（目标文件）：

  由环境变量LD_LIBRARY_PATH指定的路径。

  由路径缓存文件/etc/ld.so.cache指定的路径。

  默认共享库目录，先/usr/lib，然后/lib。



**LD_PRELOAD**

可以指定预先装载的一些共享库甚或是目标文件。



**LD_DEBUG**

可以打开动态链接器的调试功能，在运行时会输出各种有用的信息。



LD_DEBUG还可以设置成其他值，比如：

  “bindings”显示动态链接的符号绑定过程。

  “libs”显示共享库的查找过程。

  “versions”显示符号的版本依赖关系。

  “reloc”显示重定位过程。

  “symbols”显示符号表查找过程。

  “statistics”显示动态链接过程中的各种统计信息。



### 8.6 共享库的创建和安装

#### 8.6.1 共享库的创建

不要把输出共享库中的符号和调试信息去掉，也不要使用GCC的“-fomit-frame-pointer”选项，这样做虽然不会导致共享库停止运行，但是会影响调试共享库，给后面的工作带来很多麻烦。



#### 8.6.2 清除符号信息

strip 清除共享库或可执行文件的所有符号和调试信息。



ld 的 “-s”和“-S” 参数，区别是：“-S”消除调试符号信息，而“-s”消除所有符号信息。



#### 8.6.3 共享库的安装

如果要在系统路径 /lib 、/usr/lib 中，可能需要 root 权限，另外一种方法就是建立相应的 SO-NAME 软链接。



#### 8.6.4 共享库构造和析构函数

GCC提供了一种共享库的构造函数，只要在函数声明时加上“__attribute__((constructor))”的属性，即指定该函数为共享库构造函数，拥有这种属性的函数会在共享库加载时被执行，即在程序的main函数之前执行。



与共享库构造函数相对应的是析构函数，我们可以使用在函数声明时加上“__attribute__((destructor))”的属性，这种函数会在main()函数执行完毕之后执行（或者是程序调用exit()时执行）。



如果我们使用了这种析构或构造函数，那么必须使用系统默认的标准运行库和启动文件，即不可以使用GCC的“-nostartfiles”或“-nostdlib”这两个参数。因为这些构造和析构函数是在系统默认的标准运行库或启动文件里面被运行的，如果没有这些辅助结构，它们可能不会被运行。



```c++
void __attribute__((constructor(5))) init_function1(void);
void __attribute__((constructor(10))) init_function2(void);
```

对于构造函数来说，属性中优先级数字越小的函数将会在优先级大的函数之前运行；而对于析构函数来讲，则刚好相反。这种安排有利于构造函数和析构函数能够匹配，比如某一对构造函数和析构函数分别用来申请和释放某个资源，那么它们可以拥有一样的优先级。这样做的结果往往是先申请的资源后释放，符合资源释放的一般规则。



#### 8.6.5 共享库脚本

```shell
GROUP( /lib/libc.so.6 /lib/libm.so.2)
```



### 8.7 本章小结

共享库的维护、命名方式、符号版本机制、共享库路径、查找过程、环境变量、共享库创建与安装等。



## 第9章 Windows下的动态链接

### 9.1 DLL 简介

Windows下的DLL文件和EXE文件实际上是一个概念，它们都是有PE格式的二进制文件，稍微有些不同的是PE文件头部中有个符号位表示该文件是EXE或是DLL，而DLL文件的扩展名不一定是.dll，也有可能是别的比如.ocx（OCX控件）或是.CPL（控制面板程序）。



#### 9.1.1 进程地址空间和内存管理

最开始没有进程概念的时候，DLL 数据可以被所有访问。

后来 32 位系统的时候，才有了进程独立地址空间的概念。



#### 9.1.2 基地址和RVA

PE 中有两个常用的概念

- 基地址（Base Address）
- 相对地址（RVA，Relative Virtual Address）



#### 9.1.3 DLL共享数据段

用 DLL 的方式，两个数据段，一个进程间共享，另外一个私有。



#### 9.1.4 DLL的简单例子

ELF 中，共享库中所有的全局函数和变量在默认情况下都可以被其他模块使用，即 ELF 默认导出所有的全局符号。

但是在 DLL 中，需要显式的声明该符号需要导出。



#### 9.1.5 创建DLL

用 MSVC 的编译器 cl 编译后，即可产生 DLL 文件。

> 上面的编译结果生成了“Math.dll”、“Math.obj”、“Math.exp”和“Math.lib”这4个文件
>



#### 9.1.6 使用DLL

Math.lib”中并不真正包含“Math.c”的代码和数据，它用来描述“Math.dll”的导出符号，它包含了TestMath.o链接Math.dll时所需要的导入符号以及一部分“桩”代码，又被称作“胶水”代码，以便于将程序与DLL粘在一起。像“Math.lib”这样的文件又被称为导入库（Import Library）

![image-20250105105934809](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202501051059858.png)



#### 9.1.7 使用模块定义文件

用 .def 文件，优点如下：

- 可以控制导出符号的符号名；
- 可以控制一些链接的过程；



#### 9.1.8 DLL显式运行时链接

DLL 也支持运行时链接，Windows 提供了 3 个 API 为：

- LoadLibrary （或者 LoadLibraryEx），用来装载一个 DLL 到进程的地址空间，作用跟 dlopen 类似；
- GetProcAddress ，用来查找某个符号的地址，与 dlsym 类似；
- FreeLibrary ，用来卸载某个已加载的模块，与 dlclose 类似；



### 9.2 符号导出导入表

#### 9.2.1 导出表

Export Table ，导出表。



**序号（Ordinals）**

内存不够的时代，用序号代替。

缺点是，函数名/序号，会变化



一个DLL中的每一个导出函数都有一个对应唯一的序号值，而导出函数名却是可选的，也就是说一个导出函数肯定有一个序号值（序号值是肯定有的，因为函数在EAT的下标加上Base就是序号值），但是可以没有函数名。



有了序号之后，就必须第三个表，名字序号对应表。



#### 9.2.2 EXP文件

是链接器在创建 DLL 时的临时文件。

.edata 段，即 EXP 文件；

现在链接器很少会在DLL中单独保留“.edata”段，而是把它合并到只读数据段“.rdata”中。



#### 9.2.3 导出重定向

```shell
EXPORTS

# 重定向后的 DLL 文件名和符号名
HeapAlloc = NTDLL.RtlAllocHeap
```



#### 9.2.4 导入表

符号导入，Symbol Importing



在 Windows 中，系统的装载器会确保任何一个模块的依赖条件都得到满足，即每个 PE 文件所依赖的文件都将被装载。



PE 的导入表一般是只读的。此时，就有一个问题，一个只读的段，动态链接器怎么改写？

答案：Windows 做法，在装载时，将导入表所在的位置的页面，改成可读写的，一旦导入表的 IAT 被改写完毕，在改回只读。



**延迟载入（Delayed Load）**



#### 9.2.5 导入函数的调用

**PE DLL的地址无关性**

重定基地址



### 9.3 DLL优化

#### 9.3.1 重定基地址（Rebasing）

Windows PE 采用装载时重定位的方法。



缺点：每个进程都需要有一份单独的 DLL 代码段副本，会浪费内存，但该机制比 ELF 的 PIC 有更快的运行速度。

因为PE的DLL对数据段的访问不需要通过类似于GOT的机制，对于外部数据和函数的引用不需要每次都计算GOT的位置，所以理论上会比ELF的PIC的方案快一些。



**改变默认基地址**



**系统DLL**

Windows 系统本身自带的，比如 Kernel32.dll 、ntdll.dll、shell32.dll 、user32.dll 、msvcrt.dll 等，会专门在进程空间中划出一块区域，用于映射这些常用的系统 DLL 。



#### 9.3.2 序号

一个 DLL 中，每一个导出的函数都有一个对应的序号（Ordinal Number）。我们从另一个 DLL 中导入一个函数时，可以使用函数名，也可以使用序号。



另外，一般来说，仅供内部使用的导出函数，只有序号没有函数名。



因为在现在的DLL中，导出函数表中的函数名是经过排序的，查找的时候可以使用二分查找法。最初在16位的Windows下，DLL的导出函数名不是排序的，所以查找过程会比较慢。所以综合来看，一般情况下并不推荐使用序号作为导入导出的手段。



#### 9.3.3 导入函数绑定

DLL绑定，DLL Binding。



### 9.4 C++与动态链接

C语言编写的动态库，更新会很方便。但如果是 C++ 编写的，由于 C++ 只规定了语言层面的规则，对二进制级别却没有任何规定。



组件对象模型（COM，Component object model），作者推荐《COM本质论》。



C++ 编写动态链接库，需要遵循以下指导意见：

- 所有的接口函数都应该是抽象的。所有的方法都应该是纯虚的。（或者inline的方法也可以）。
- 所有的全局函数都应该使用extern“C”来防止名字修饰的不兼容。并且导出函数的都应该是__stdcall调用规范的（COM的DLL都使用这样的规范）。这样即使用户本身的程序是默认以__cdecl方式编译的，对于DLL的调用也能够正确。
- 不要使用C++标准库STL。
- 不要使用异常。
- 不要使用虚析构函数。可以创建一个destroy()方法并且重载delete操作符并且调用destroy()。
- 不要在DLL里面申请内存，而且在DLL外释放（或者相反）。不同的DLL和可执行文件可能使用不同的堆，在一个堆里面申请内存而在另外一个堆里面释放会导致错误。比如，对于内存分配相关的函数不应该是inline的，以防止它在编译时被展开到不同的DLL和可执行文件。
- 不要在接口中使用重载方法（Overloaded Methods，一个方法多重参数）。因为不同的编译器对于vtable的安排可能不同。




### 9.5 DLL HELL

原因可能有如下三种：

一是由使用旧版本的DLL替代原来一个新版本的DLL而引起。这个原因最普遍，是Windows 9x用户通常遇到的问题DLL错误之一。

二是由新版DLL中的函数无意发生改变而引起。尽管在设计DLL时候应该“向下”兼容，然而要保证DLL完全“向下”兼容却是不可能的。

三是由新版DLL的安装引入一个新BUG.。这个原因发生的概率最小，但是它仍然会发生。



预防方法：

- 静态链接（Static linking）。缺点：丧失使用动态链接带来的优势。
- 防止DLL覆盖（DLL Stomping）
- 避免DLL冲突（Conflicting DLLs）



### 9.6 本章小结

Windows 的 API 也是以 DLL 的形式提供给程序开发者。Linux 则是直接用系统调用。



## 第10章 内存

### 10.1 程序的内存布局

在 32 位系统里，用户可以直接使用 32 位的地址进行寻址。



默认有内核空间，会占用一部份内存。



栈：栈用于维护函数调用的上下文，离开了栈函数调用就没法实现。栈通常在用户空间的最高地址处分配，通常有数兆字节的大小。

堆：堆是用来容纳应用程序动态分配的内存区域，当程序使用malloc或new分配内存时，得到的内存来自堆里。堆通常存在于栈的下方（低地址方向），在某些时候，堆也可能没有固定统一的存储区域。堆一般比栈大很多，可以有几十至数百兆字节的容量。

可执行文件映像：存储可执行文件在内存中的映像，由装载器在装载时将可执行文件的内存读取或映射到这里。

保留区：不是单一一个区域，而是内存中受到保护而禁止访问的内存区域的总称。

![image-20250113082515292](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202501130825512.png)



Q：我写的程序常常出现“段错误(segment fault)”或者“非法操作，该内存地址不能read/write”的错误信息，这是怎么回事？

  A：这是典型的非法指针解引用造成的错误。当指针指向一个不允许读或写的内存地址，而程序却试图利用指针来读或写该地址的时候，就会出现这个错误。在Linux或Windows的内存布局中，有些地址是始终不能读写的，例如0地址。还有些地址是一开始不允许读写，应用程序必须事先请求获取这些地址的读写权，或者某些地址一开始并没有映射到实际的物理内存，应用程序必须事先请求将这些地址映射到实际的物理地址（commit），之后才能够自由地读写这片内存。当一个指针指向这些区域的时候，对它指向的内存进行读写就会引发错误。造成这样的最普遍原因有两种：

1. 程序员将指针初始化为NULL，之后却没有给它一个合理的值就开始使用指针。

  2. 程序员没有初始化栈上的指针，指针的值一般会是随机数，之后就直接开始使用指针。



### 10.2 栈与调用惯例

#### 10.2.1 什么是栈

栈被定义为一个特殊的容器，用户可以将数据压入栈中（入栈，push），也可以将已经压入栈中的数据弹出（出栈，pop），但栈这个容器必须遵守一条规则：先入栈的数据后出栈（First In Last Out, FIFO）。

![image-20250114082500141](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202501140825270.png)



栈在程序运行中具有举足轻重的地位。最重要的，栈保存了一个函数调用所需要的维护信息，这常常被称为堆栈帧（Stack Frame）或活动记录（Activate Record）。堆栈帧一般包括如下几方面内容：

- 函数的返回地址和参数。
- 临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量。
- 保存的上下文：包括在函数调用前后需要保持不变的寄存器。
- 在i386中，一个函数的活动记录用ebp和esp这两个寄存器划定范围。esp寄存器始终指向栈的顶部，同时也就指向了当前函数的活动记录的顶部。而相对的，ebp寄存器指向了函数活动记录的一个固定位置，ebp寄存器又被称为帧指针（Frame Pointer）。



GCC编译器有一个参数叫做-fomit-frame-pointer可以取消帧指针，即不使用任何帧指针，而是通过esp直接计算帧上变量的位置。这么做的好处是可以多出一个ebp寄存器供使用，但是坏处却很多，比如帧上寻址速度会变慢，而且没有帧指针之后，无法准确定位函数的调用轨迹（Stack Trace）。所以除非你很清楚你在做什么，否则请尽量不使用这个参数。



使用 VC 调试时，默认初始化为 0xCC 的话，两个连续的 CCCC 就是汉字 **烫** 的编码。有的用 CDCD ，就是汉字 **屯** 的编码。



nop 本身作为汇编的一个占位符使用。这种机制可以用来实现一种叫做钩子（Hook）的技术，允许用户在某些时刻截获特定函数的调用。



#### 10.2.2 调用惯例

函数调用方和被调用方，对函数是有着统一的理解。



该约定被称为调用惯例，Calling Convention ，一般会规定如下内容：

- 函数参数的传递顺序和方式
- 栈的维护方式
- 名字修饰（Name-mangling）的策略



如下是几种常见的调用惯例

![image-20250114084451395](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202501140844529.png)



#### 10.2.3 函数返回值传递

eax 低 4 字节，edx 高 4 字节；



在C++里返回一个对象的时候，对象要经过2次拷贝构造函数的调用才能够完成返回对象的传递。1次拷贝到栈上的临时对象里，另一次把临时对象拷贝到存储返回值的的对象里。在某些编译器里，返回一个对象甚至要经过更多的步骤。

这样带来的恶果就是返回一个较大对象会有非常多的额外开销。因此C++程序中都尽量避免返回对象。



### 10.3 堆与内存管理

#### 10.3.1 什么是堆

光有栈对于面向过程的程序设计还远远不够，因为栈上的数据在函数返回的时候就会被释放掉，所以无法将数据传递至函数外部。而全局变量没有办法动态地产生，只能在编译的时候定义，有很多情况下缺乏表现力。在这种情况下，堆（Heap）是唯一的选择。



具体来讲，管理着堆空间分配的往往是程序的运行库。

如果用操作系统内核实现，则会产生大量的开销，严重影响程序性能。



#### 10.3.2 Linux进程堆管理

`brk()` 与 `mmap()` 两种系统调用方式，实现堆空间分配。



#### 10.3.3 Windows进程堆管理

VirtualAlloc()

使用该函数向操作系统申请内存的时候，必须是 4096 字节的整数倍，这样的话，就容易造成很多内存浪费。



**Windows 堆管理器的位置**

Q：malloc申请的内存，进程结束以后还会不会存在？

  A：这是一个很常见的问题，答案是很明确的：不会存在。因为当进程结束以后，所有与进程相关的资源，包括进程的地址空间、物理内存、打开的文件、网络链接等都被操作系统关闭或者收回，所以无论malloc申请了多少内存，进程结束以后都不存在了。

  Q：malloc申请的空间是不是连续的？

  A：在分析这个问题之前，我们首先要分清楚“空间”这个词所指的意思。如果“空间”是指虚拟空间的话，那么答案是连续的，即每一次malloc分配后返回的空间都可以看做是一块连续的地址；如果空间是指“物理空间”的话，则答案是不一定连续，因为一块连续的虚拟地址空间有可能是若干个不连续的物理页拼凑而成的。



#### 10.3.4 堆分配算法

1. 空闲链表



2. 位图



3. 对象池



### 10.4 本章小结

内存结构，堆栈等



## 第11章 运行库

### 11.1 入口函数和程序初始化

#### 11.1.1 程序从 main 开始吗

在运行 main 之前，会有一些代码负责准备好 main 函数执行所需要的环境。



#### 11.1.2 入口函数如何实现

**GLIBC入口函数**

_start



**环境变量**

C语言使用 getenv ；

Linux 下使用 export ；



mainCRTStartup的总体流程就是：

（1）初始化和OS版本有关的全局变量。

（2）初始化堆。

（3）初始化I/O。

（4）获取命令行参数和环境变量。

（5）初始化C库的一些数据。

（6）调用main并记录返回值。

（7）检查错误并将main的返回值返回。



#### 11.1.3 运行库与I/O

IO （或 I/O ）的全称是 Input / Output ，即输入和输出。



首先I/O初始化函数需要在用户空间中建立stdin、stdout、stderr及其对应的FILE结构，使得程序进入main之后可以直接使用printf、scanf等函数。



#### 11.1.4 MSVC CRT 的入口函数初始化

系统堆初始化

I/O 初始化



### 11.2 C/C++运行库

#### 11.2.1 C语言运行库

运行时库（Runtime Library ），C语言的运行库，被称为 C 运行库（CRT）。



#### 11.2.2 C语言标准库

变长参数。



变长参数宏，可以用 ## 实现。

```c++
#define printf(args...) fprintf(stdout, ##args)
```



#### 11.2.3 glibc 与 MSVC CRT

所以glibc和MSVCRT事实上是标准C语言运行库的超集，它们各自对C标准库进行了一些扩展。

不能在A中申请内存然后在B中释放，因为它们分属于不同的CRT，即拥有不同的堆，这包括C++里面所有对象的申请和释放；

在A中打开的文件不能在B中使用，比如FILE*之类的，因为它们依赖于CRT的文件操作部分。



### 11.3 运行库与多线程

#### 11.3.1 CRT的多线程困扰

线程局部存储（Thread Local Storage, TLS）

C 角度看，数据在线程之间是否私有如下表：

![image-20250217225728339](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202502172257245.png)



在 Linux 下的 glibc 也提供了 pthread(POSIX Thread) 线程库。这些函数都不属于标准的运行库，都是跟平台相关的。



#### 11.3.2 CRT改进

**使用 TLS （线程局部存储）**

errno 被定义为一个宏。



**加锁**

多线程版本的运行库中，线程不安全的函数内部都会自动地进行加锁。包括 malloc 、printf 等函数。



**改进函数调用方式**

MSVC CRT 与 Glibc，都提供了线程安全版本的函数

- strtok，非线程安全函数；
- strtok_s，MSVC CRT 提供线程安全版本；
- strtok_r，Glibc 提供线程安全版本；



#### 11.3.3 线程局部存储实现

要定义一个变量为线程局部存储的，GCC 里边，可以在变量前加关键字：__thread 。

```c++
// GCC
__thread int number;

// MSVC
__declspec(thread) int number;
```



线程环境块（TEB, Thread Environment Block）。



隐式 TLS ，显式 TLS 。



Windows API 与 MSVC 的 CRT 函数混用，可能会导致内存泄漏。



### 11.4 C++全局构造与析构

#### 11.4.1 glibc全局构造与析构

把每个目标文件的复杂全局/静态对象构造的函数地址放在一个特殊的段里面有什么好处呢？当然不为别的，为的是能够让链接器把这些特殊的段收集起来，收集齐所有的全局构造函数后就可以在初始化的时候进行构造了。



测试代码，在 .ctors 段添加自定义函数，实现在 main 之前执行自定义代码。

![image-20250218235813720](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202502182358897.png)



#### 11.4.2 MSVC CRT的全局构造和析构

与 Glibc 有异曲同工之妙，处了函数名，基本逻辑是一致的。



### 11.5 fread实现

#### 11.5.1 缓冲

fflush，将写缓冲的内容，同步到文件中。

![image-20250219234447517](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202502192344644.png)



#### 11.5.2 fread_s

fread_s 最后的 s 是 safe 安全的意思。



#### 11.5.3 fread_nolock_s

fread_s 内部调用的该函数。



#### 11.5.4 _read



#### 11.5.5 文本换行

在Windows的文本文件中，回车（换行）的存储方式是0x0D（用CR表示），0x0A（用LF表示）这两个字节，以C语言字符串表示则是“\r\n”。

Linux/Unix：回车用\n表示。

Mac OS：回车用\r表示。

Windows：回车用\r\n表示。



![image-20250220000111464](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202502200001578.png)



### 11.6 本章小结

Linux 与 Windows 下的 CRT 。



## 第12章 系统调用与API

用户层面与内核层面，即系统调用（System Call）。



### 12.1 系统调用介绍

#### 12.1.1 什么是系统调用

比如延时 1 秒，系统调用可以匹配不同频率的 CPU ，兼容硬件带来的差异。



#### 12.1.2 Linux 系统调用

EAX 寄存器，用来表示系统调用的接口号。

Linux 系统调用的 read ，与 C 运行库中的 fread 。



#### 12.1.3 系统调用的弊端

第一章介绍的万能法则：解决计算机的问题可以通过增加层来实现。



运行时库将不同的操作系统的系统调用包装为统一固定的接口，使得同样的代码，在不同的操作系统下都可以直接编译，并产生一致的效果。这就是源代码级上的可移植性。



### 12.2 系统调用原理

#### 12.2.1 特权级与中断

高可以转低，但低转高，就得用一些安全的方法。



Windows 下使用 int 0x2e 触发，Linux 下则使用 int 0x80 来触发所有的系统调用。



#### 12.2.2 基于int的Linux的经典系统调用

以 fork 为例

![image-20250224234853562](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202502242348711.png)

1. 触发中断

C 语言中使用的系统函数，是对系统函数的封装

```c
_syscall0(pid_t, fork);
```



__NR_fork 是一个宏，x86 的可以在 unistd_32.h 中找到。



当用户调用某个系统调用的时候，实际是执行了以上一段汇编代码。CPU执行到int $0x80时，会保存现场以便恢复，接着会将特权状态切换到内核态。然后CPU便会查找中断向量表中的第0x80号元素。



2. 切换堆栈

在Linux中，用户态和内核态使用的是不同的栈，两者各自负责各自的函数调用，互不干扰。

所谓的“当前栈”，指的是ESP的值所在的栈空间。如果ESP的值位于用户栈的范围内，那么程序的当前栈就是用户栈，反之亦然。此外，寄存器SS的值还应该指向当前栈所在的页。



3. 中断处理程序

nr_syscalls 是比最大的有效系统调用号大 1 的值。



#### 12.2.3 Linux的新型系统调用机制

linux-gate.so.1 是 Linux 用于支持新型系统调用的 “虚拟” 共享库。

`cat /proc/self/maps`，可以查看 cat 命令自己的内存布局。

```shell
# 用dd命令，从进程对应地址偏移导出虚拟共享库。
$dd if=/proc/self/mem of=linux-gate.dso bs=4096 skip=1048574 count=1
```



### 12.3 Windows API

API的全称为Application Programming Interface，即应用程序编程接口。

![image-20250227090955705](https://cdn.jsdelivr.net/gh/FightingBoom/AllPicture@master/img/202502270909879.png)



#### 12.3.1 Windows API 概览

Software Development Kit（SDK）



**Windows API 版本**

NTDLL.DLL



#### 12.3.2 为什么要使用 Windows API

PS：突然想到之前用 Windows 系统，安装某个软件，总是提示缺少某 DLL 库，看来就是缺少了运行以来的环境，或者是说用的 Windows API 没找到。



DLL基本上是Windows系统上很多高级接口和程序设计方法的基石，包括内核与驱动程序、COM、OLE、ActiveX等都是基于DLL技术的。



银弹







