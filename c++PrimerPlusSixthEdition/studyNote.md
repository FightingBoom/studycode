# 未归类

1、signed 、unsigned 单独使用时，默认为 int 类型；

```c++
signed = signed int
unsigned = unsigned int
```



## 名词缩写

多重继承（multiple inheritance，MI）



### 10.3.5 构造函数

如果可以通过初始化，也可以通过赋值来设置对象的值，则应采用初始化的方式，通常这种方式的效率更高；

可以将列表初始化语法，用于类；只需要提供与某个构造函数的参数列表匹配的内容，并用大括号将他们括起；【C++11及以上支持】

可以通过将函数参数声明为 const 引用或指向 const 的指针，保证函数不会修改调用对象

```c++
// 函数声明
void show() const;
// 函数定义
void stock::show() const;
```

以这种方式声明和定义的类函数被称为 const 成员函数。应尽可能将 const 引用和指针用作函数形参，只要类方法不修改调用对象，就应将其声明为 const 。



### 10.3.6 构造函数和析构函数小结

如果构造函数使用了 new ，则必须提供使用 delete 的析构函数；



## 10.4 this 指针

一般来说，所有的类方法都将 this 指针设置为调用它的对象的地址。

*this，将解除引用运算符 * 用于指针，将得到指针指向的值。



## 10.8 总结

由于 this 指针被设置为调用对象的地址，因此 *this 是该对象的别名；



# 11 使用类

## 11.2 计算时间：一个运算符重载示例

将参数声明为引用的目的是为了提高效率。

个人理解：如果不需要修改值，请加上 const 限定符；

不要返回指向局部变量或临时对象的引用。函数执行完毕后，局部变量和临时对象将消失，引用将指向不存在的数据。



### 11.2.1 添加加法运算符

编译器将根据操作数的类型来确定做

```c++
int a, b, c;
Time A, B, C;
c = a + b;
C = A + B;
```

同时可以将两个以上的对象相加

```c++
t4 = t1 + t2 + t3;

t4 = t1.operator+(t2 + t3);

t4 = t1.operator+(t2.operator + (t3));
```



### 11.2.2 重载限制

C++ 对用户定义的运算符重载的限制，2023/03/26 17:22

1、重载后的运算符必须至少有一个操作数是用户定义的类型，这将防止用户为标准类型重载运算符；

2、使用运算符时， 不能违反运算符原来的句法规则。同样，不能修改运算符的优先级。

3、不能创建新运算符。

4、不能重载下面的运算符

- **sizeof** ：sizeof 运算符。
- **.** ：成员运算符。
- **. \*** ：成员指针运算符。
- **::** ：作用域解析运算符。
- **?;** ：条件运算符。
- **typeid** ：一个 RTTI 运算符。
- **const_cast** ：强制类型转换运算符。
- **dynamic_cast** ：强制类型转换运算符。
- **reinterpret_cast** ：强制类型转换运算符。
- **static_cast** ：强制类型转换运算符。

5、如下运算符只能通过成员函数进行重载

- **=** ：复制运算符。
- **()** ：函数调用运算符。
- **[]** ：下标运算符。
- **->** ：通过指针访问类成员的运算符。



## 11.3 友元

类的友元函数是非成员函数，其访问权限与成员函数相同。

应将友元函数看作类的扩展接口的组成部分。

只有类声明可以决定哪一个函数是友元，因此类声明仍然控制了哪些函数可以访问私有数据。

总之，类方法和友元只是表达类接口的两种不同机制。



### 11.3.1 创建友元

如果要为类重载运算符，并将非类的项作为其第一个操作数，则可以用友元函数来反转操作数的顺序。



### 11.3.2 常用的友元：重载<<运算符

<< 运算符是 C 和 C++ 的位运算符，将值中的位左移。2023/03/27 22:57

cout 是一个 ostream 对象，可以识别所有的 C++ 基本类型。因为对于每种基本类型，ostream 类声明中都包含了相应的重载的 operator<<() 定义。

按引用传递使用的内存和时间都比按值传递少。

```c++
int x = 5;
int y = 8;

cout << x << y;
// 上下两条语句等价
(cout << x) << y;
```

<< 运算符左边是一个 ostream 对象。

ostream 类将 operator <<() 函数实现为返回一个指向 ostream 对象的引用。具体地说，他返回一个指向调用对象（这里是 cout ）的引用。因此，表达式 (cout << x) 本身就是 ostream 对象 cout，从而可以位于 << 运算符的左侧。



## 11.4 重载运算符：作为成员函数还是非成员函数

非成员版本的重载运算符函数所需的形参数目，与运算符使用的操作数数目相同；而成员版本所需的参数数目少一个，因为其中的一个操作数是被隐式地传递给调用对象。

```c++
T1 = T2 + T3 // 编译器转换
T1 = T2.operator+(T3);
T1 = operator+(T2, T3);
```



## 11.5 再谈重载：一个矢量类

函数尾部的 const 限定符，用于声明那些不会对其显式访问的对象进行修改的函数。



### 11.5.2 为 Vector 类重载算术运算符

如果方法通过计算得到一个新的类对象，则应考虑是否可以使用类构造函数来完成这种工作。这样做不仅可以避免麻烦，而且可以确保新的对象是按照正确的方式创建的。

因为运算符重载是通过函数来实现的，所以只要运算符函数的特征标不同，使用的运算符数量与相应的内置 C++ 运算符相同，就可以多次重载同一个运算符。



## 11.6 类的自动转换和强制类型转换

类可使用等号的方式，调用构造函数。有两种情况（2023/04/02 18:43）

- 只有一个（整形）参数
- 有多个参数，除第一个外，后面的参数都有默认值。

使用关键字 explicit 可以关闭自动隐式转换的特性，但允许使用 类名(值) 的方式显式转换。

只接受一个参数的构造函数定义了从参数类型到类类型的转换。如果使用关键字 explicit 限定了这种构造函数，则它只能用于显式转换，否则也可以用于隐式转换。



### 11.6.1 转换函数

构造函数只能实现其他类型到类类型的转换，要想实现从其他类型（比如 double ）到类类型的转换，则需要对应的 **转换函数** ，注意：

- 转换函数必须是类方法；
- 转换函数不能指定返回类型；
- 转换函数不能有参数；

标准格式

```c++
// typeName: 对象将被转换成的类型。
// 将类对象赋值给typeName变量或将其强制转换为typeName类型时，该转换函数将自动被调用。
operator typeName()
```

应谨慎地使用隐式转换函数。通常，最好选择仅在被显式地调用时才会执行的函数。



## 11.7 总结

一般访问私有类成员的唯一方法是使用类方法。C++ 可以使用友元函数避开这种限制，需在声明前加上关键字 friend 。

C++ 扩展了对运算符的重载，允许自定义特殊的运算符函数。

C++ 允许指定在类和基本类型之间进行转换的方式。

1. 任何接受唯一一个参数的构造函数都可被用作转换函数，将类型与该参数相同的值转换为类。
2. 如果将类型与该参数相同的值赋给对象，则C++将自动调用该构造函数。
3. 如果在该构造函数的声明前加上了关键字 explicit ，则该构造函数将只能用于显式转换
4. 要将类对象转换为其他类型，必须定义转换函数，指出如何进行这种转换。转换函数必须是成员函数。
5. 经验表明：最好不要依赖于隐式转换函数。
6. 自己总结：如果一定需要转换，可以自定义接口进行转换操作；
7. 与简单的C-风格结构相比，使用类时，必须更谨慎、更小心；



# 12 类和动态内存分配

## 12.1 动态内存和类

### 12.1.1 复习示例和静态类成员

将 num_strings 成员声明为静态存储类。静态存储类的特点：无论创建了多少对象，程序都只创建一个静态类变量副本。也就是说，类的所有对象共享同一个静态成员，就像家中的电话可供全体家庭成员共享一样。

这对于所有类对象都具有相同值的类私有数据是非常方便。例如，num_strings 成员可以记录所创建的对象数目。

不能在类声明中初始化静态成员变量，因为声明描述了如何分配内存，但并不分配内存。

但静态类成员，可以在类声明之外，使用单独的语句来进行初始化，因为静态类成员是单独存储的，而不是对象的组成部分。

注意：初始化语句指出了类型，并使用了作用域运算符，但没有使用关键字 static 。

```c++
static int num_strings; // 方便说明静态数据成员，实际字符串类并不需要

int StringBad::num_strings = 0; // 静态成员初始化
```

初始化是在方法文件中，而不是在类声明文件中进行的，因为类声明位于头文件中，程序可能将头文件包括在其他几个文件中。如果在头文件中进行初始化，将出现多个初始化语句副本，从而引发错误。

在构造函数中使用 new 来分配内存时，必须在相应的析构函数中使用 delete 来释放内存。如果使用 new[] （包括中括号）来分配内存，则应使用 delete[]（包括中括号）来释放内存。

```c++
StringBad sailor = sports; // <=> 等价与如下代码

StringBad sailor = StringBad(sports); // 此时调用的原型为
```



### 12.1.3 回到 Stringbad：复制构造函数的哪里出了问题

如果类中包含了使用 new 初始化的指针成员，应当定义一个复制构造函数，以复制指向的数据，而不是指针，这被称为深度复制。

复制的另一种形式（成员复制或浅复制）只是复制指针值。浅复制仅浅浅地复制指针信息，而不会深入“挖掘”以复制指针引用的结构。



### 12.2.4 静态成员函数

可以将成员函数声明为静态的，但有两个重要后果

1. 不能通过对象调用静态成员函数；实际上，静态成员函数甚至不能使用 this 之神。
2. 由于静态成员函数不与特定的对象相关联，因此只能使用静态数据成员。例如，静态方法 HowMany() 可以访问静态成员num_string。



## 12.3 在构造函数中使用 new 时应注意的事项

使用 new 初始化对象的指针成员，需注意如下几点（2023/04/16 16:38）

1. 如果在构造函数中使用 new 来初始化指针成员，则应在析构函数中使用 delete 。
2. new 和 delete 必须相互兼容。new 对应于 delete ，new[] 对应于 delete[] 。
3. 如果有多个构造函数，则必须以相同的方式使用 new ，要么都带中括号，要么都不带。
4. 应定义一个复制构造函数，通过深度复制将一个对象初始化为另一个对象。
5. 应当定义一个赋值运算符，通过深度复制将一个对象复制给另一个对象。



## 12.4 有关返回对象的说明

成员函数或独立的函数返回对象时，有几种选择：

1. 返回指向对象的引用
2. 指向对象的 const 引用或 const 对象

直接返回对象，会调用复制构造函数，但是返回引用不会。因此返回引用所做的工作更少，效率更高。

引用指向的对象应该在调用函数执行时存在。

如果方法活函数要返回局部对象，则应返回对象，而不是指向对象的引用。



## 12.5 使用指向对象的指针

如果对象是用 new 创建的，则仅当您显式使用 delete 删除对象时，其析构函数才会被调用。



## 12.7 队列模拟

1、使用成员初始化列表，注意：

- 这种格式只能用于构造函数
- 非静态 const 类成员
- 声明为引用的类成员

2、对于本身就是类对象的成员来说，使用成员初始化列表的效率更高。

3、成员初始化列表的初始化工作是在对象创建时完成的，此时还未执行构造函数括号中的任何代码。

链表在使用时，先用临时变量获取当前值，然后 front 指向自己的下一个地址，最后再删除临时变量的引用值，即删除了最开始的元素；

```c++
temp = front;
front = front->next;
delete temp;
```



## 12.8 总结

C++ 允许类内初始化。



# 13 类继承

## 13.1 一个简单的基类

1、如果是 firstname = fn 这种形式，将先为 firstname 调用 string 类的默认构造函数，再调用 string 类的赋值运算符将 firstname 设置为 fn 。

但用构造函数这种初始化列表语法，可减少一个步骤，直接使用 string 类的复制构造函数将 firstname 初始化为 fn 。



### 13.1.2 构造函数：访问权限的考虑

除非要使用默认构造函数，否则应显式调用正确的基类构造函数。



## 13.3 多态公有继承

1、希望同一个方法在派生类和基类中的行为是不同的。方法的行为应取决于调用该方法的对象。这种复杂的行为称为多态 —— 具有多种形态。

2、有两种重要的机制可用于实现多态公有继承：

- 在派生类中重新定义基类的方法；
- 使用虚方法（虚函数）；



如果方法是通过引用或指针而不是对象调用的，它将确定使用哪一种方法。

如果没有使用关键字 virtual ，程序将根据引用类型或指针类型选择方法；

如果使用了 virtual ，程序将根据引用或指针指向的对象的类型来选择方法；

```c++
// ViewAcct 不是虚函数
Brass dom("Dominic Banker", 11224, 4183.45);
BrassPlus dot("Dorothy Banker", 12118, 2592.00);
Brass & b1_ref = dom;
Brass & b2_ref = dot;
b1_ref.ViewAcct();    // use Brass::ViewAcct()
b2_ref.ViewAcct();    // use Brass::ViewAcct()
```



```c++
// ViewAcct 是虚函数
Brass dom("Dominic Banker", 11224, 4183.45);
BrassPlus dot("Dorothy Banker", 12118, 2592.00);
Brass & b1_ref = dom;
Brass & b2_ref = dot;
b1_ref.ViewAcct();    // use Brass::ViewAcct()
b2_ref.ViewAcct();    // use BrassPlus::ViewAcct()
```

方法在基类中被声明为虚的后，它在派生类中将自动成为虚方法。然而，在派生类中使用 virtual 指出哪些是虚函数也挺好。

如果要在派生类中重新定义基类的方法，通常应将基类方法声明为虚的。这样，程序将根据对象类型而不是引用或指针的类型来选择方法版本。为基类声明一个虚析构函数也是一种惯例。

关键字 virtual 只用于类声明的方法原型中，没有用于方法定义中。

在派生类方法中，标准技术是使用作用域解析运算符来调用基类方法。



## 13.4 静态联编和动态联编

### 13.4.1 指针和引用类型的兼容性

对于使用基类引用或指针作为参数的函数调用，将进行向上转换。如下代码，假定每个函数都调用虚方法 ViewAcct() ；

```c++
// 引用、指针，可以隐式向上转换
void fr(Brass & rb);   // uses rb.ViewAcct()
void fp(Brass * pb);   // uses pb->ViewAcct()
void fv(Brass b);      // uses b.ViewAcct()

int main()
{
    Brass b("Billy Bee", 123432, 10000.0);
    BrassPlus bp("Betty Beep", 232313, 12345.0);

    fr(b);    // uses Brass::ViewAcct()
    fr(bp);   // uses BrassPlus::ViewAcct()
    fp(b);    // uses Brass::ViewAcct()
    fp(bp);   // uses BrassPlus::ViewAcct()
    fv(b);    // uses Brass::ViewAcct()
    fv(bp);   // uses Brass::ViewAcct()
}
```



### 13.4.2 虚成员函数和动态联编

编译器对非虚方法，使用静态联编。

编译器对虚方法，使用动态联编。因为通常只有在运行程序时才能确定对象的类型。

C++的指导原则之一：不要为不使用的特性付出代价（内存或者处理时间）

使用虚函数时，在内存和执行速度方面有一定的成本，包括：

- 每个对象都将增大，增大量为存储地址的空间；
- 对于每个类，编译器都创建一个虚函数地址表（数组）；
- 对于每个函数调用，都需要执行一项额外的操作，即到表中查找地址。

虽然非虚函数的效率比虚函数稍高，但不具备动态联编功能。



### 13.4.3 有关虚函数注意事项

构造函数不能是虚函数。

析构函数应当是虚函数，除非类不用做基类。

派生类中存在 new 等内存，需要在派生类销毁时，回收对应内存，因此析构函数应当是虚函数，这样派生类可以有自己的实现。

当 delete 派生类的内存时，会先调用派生类的析构函数，再调用基类的析构函数。

通常应该给类定义一个虚析构函数，即使他并不需要析构函数。

友元不能是虚函数，因为友元不是类成员，只有成员才能是虚函数。如果有设计问题，可以让友元函数使用虚成员函数来解决。



5. 重新定义将隐藏方法

基类有一个虚函数，派生类重新实现，但参数不同，此时会隐藏基类的同名函数

```c++
class Dwelling
{
public:
    virtual void showperks(int a) const;
...
};


class Hovel : public Dwelling
{
public:
    virtual void showperks() const;
...
}
```

重新定义不会生成函数的两个重载版本，而是隐藏了接受一个 int 参数的基类版本。

总之，重新定义继承的方法并不是重载。如果重新定义派生类中的函数，将不只是使用相同的函数参数列表覆盖基类声明，无论参数列表是否相同，该操作将隐藏所有的同名基类方法。



此引出来两条规则

第一，如果重新定义继承的方法，应确保与原来的原型完全相同，但如果返回类型是基类引用或指针，则可以修改为指向派生类的引用或指针。这种特性被称为返回类型协变，因为允许返回类型随类类型的变化而变化。

需要注意，这种例外只适用于返回值，而不适用于参数。

```c++
class Dwelling
{
public:
    virtual Dwelling & build(int n);
...
};


class Hovel : public Dwelling
{
public:
    virtual Hovel & build(int n); // 同名虚函数，只是返回值类型不同
...
}
```

第二，如果基类声明被重载了，则应在派生类中重新定义所有的基类版本。

```c++
class Dwelling
{
public:
    virtual void showperks(int a) const;
    virtual void showperks(double x) const;
    virtual void showperks() const;
...
};


class Hovel : public Dwelling
{
public:
    virtual void showperks(int a) const;
    virtual void showperks(double x) const;
    virtual void showperks() const;
...
}
```

如果只重新定义一个版本，则另外两个版本将被隐藏，派生类对象将无法使用它们。如果不需要修改，新定义可以只调用基类版本。

```c++
void Hovel::showperks() const {Dwelling::showperks();}
```





## 13.5 访问控制：protected

protected 与 private ，在 类外 只能用公有类成员来访问。

派生类的成员，可以直接访问基类的保护成员，但不能直接访问基类的私有成员。

| 基类关键字类型 | 派生类访问权限 | 外部类访问权限 |
| :------------: | :------------: | :------------: |
|    private     |    无法访问    |    无法访问    |
|    protected     |    可以访问    |    无法访问    |
|     public     |    可以访问    |    可以访问    |
|                |                |                |

注意：最好对类数据成员采用私有访问控制，不要使用保护访问控制；同时通过基类方法使派生类能够访问基类数据；

另外对于成员函数来说，保护访问控制很有用，它让派生类能够访问公众不能使用的内部函数。



## 13.6 抽象基类

ABC：abstract base class

真正的 ABC ，必须至少包含一个纯虚函数。

当类声明中包含纯虚函数时，则不能创建该类的对象。

理念：包含纯虚函数的类只用作基类。



## 13.7 继承和动态内存分配

### 13.7.1 第一种情况：派生类不使用 new

可以不需要为派生类定义显式析构函数、复制构造函数和赋值运算符。



### 13.7.2 第二种情况：派生类使用 new

如果派生类有使用 new ，则必须为派生类定义显式析构函数、复制构造函数和赋值运算符。

派生类析构函数自动调用基类的析构函数，故其自身的职责是对派生类构造函数执行工作的进行清理。因此，hasDMA （派生类）的析构函数必须释放指针 style 管理的内存，并依赖于 baseDMA （基类）的析构函数来释放指针 label 管理的内存。

hasDMA （派生类）复制构造函数只能访问 hasDMA 的数据，因此必须调用 baseDMA 复制构造函数来处理共享的 baseDMA 数据。

当基类和派生类都采用动态内存分配时，派生类的析构函数、复制构造函数、赋值运算符都必须使用相应的积累方法来处理基类元素。

这种要求是通过三种不同的方式来满足的。

对于析构函数，这是自动完成的；

对于构造函数，这是通过在初始化成员类表中调用基类的复制构造函数来完成的；如果不这样做，将自动调用基类的默认构造函数。

对于复制运算符，这是通过使用作用域解析运算符显式地调用基类的复制运算符来完成的。



## 13.8 类设计回顾

### 13.8.1 编译器生成的成员函数

如果定义了某种构造函数，则编译器将不会定义默认构造函数。如果有需要，则必须自己提供。

提供构造函数的动机之一是确保对象总能被正确地初始化。如果类包含指针成员，则必须初始化这些成员。因此，最好提供一个显式默认构造函数，将所有的类数据成员都初始化为合理的值。



复制构造函数接受其所属类的对象作为参数。

Star(const Star &);

在下述情况下，将使用复制构造函数：

- 将新对象初始化为一个同类对象；
- 按值将对象传递给函数；
- 函数按值返回对象；
- 编译器生成临时对象；



默认的赋值运算符用于处理同类对象之间的赋值。

PS：不要将赋值与初始化混淆了。如果语句创建新的对象，则使用初始化；如果语句修改已有对象的值，则是赋值；

默认赋值为成员赋值。



### 13.8.2 其他的类方法

1. 构造函数

构造函数不同于其他类方法，因为它创建新的对象，而其他类方法只是被现有的对象调用。这是构造函数不被继承的原因之一。

继承意味着派生类对象可以使用基类的方法，但构造函数在完成其工作之前，对象并不存在。



2. 析构函数

一定要定义显式析构函数来释放类构造函数使用 new 分配的所有内存，并完成类对象所需的任何特殊的清理工作。

对于基类，即使它不需要析构函数，也应提供一个虚析构函数。



3. 转换

在带一个参数的构造函数原型中使用 explicit 将禁止进行隐式转换，但仍允许显式转换：

```c++
class star
{
...
public:
    explicit Star(const char *);
...
};

...

Star north;
north = "polaris";        // not allowed
north = Star("polaris");  // allowed
```



另外，对于某些类，包含转换函数将增加代码的二义性。

C++11 支持将关键字 explicit 用于转换函数。与构造函数一样，explicit 允许使用强制类型转换进行显式转换，但不允许隐式转换。



4. 按值传递对象与传递引用

通常，编写使用对象作为参数的函数时，应按引用而不是按值来传递对象。

原因之一是为了提高效率。按值传递对象涉及到生成临时拷贝，即调用复制构造函数，然后调用析构函数。调用这些函数需要时间，复制大型对象比传递引用花费的时间要多得多。如果函数不修改对象，应将参数声明为 const 引用。

按引用传递对象的另外一个原因是，在继承使用虚函数时，被定义为接受基类引用参数的函数可以接受派生类。



5. 返回对象和返回引用

有些类方法返回对象。有些成员函数直接返回对象，另一些返回引用。有时方法必须返回对象，但如果可以不返回对象，则应返回引用。

```c++
// 返回对象
Star nova1(const Star &);

// 返回引用
Star & nova2(const Star &);
```

返回对象涉及生成调用函数的程序，可以使用的临时副本。因此，返回对象的时间成本包括调用复制构造函数来生成副本所需的时间和调用析构函数删除副本所需的时间。

返回引用可以节省时间和内存。

直接返回对象与按值传递对象相似：都生成临时副本。

返回引用与按引用传递对象相似：调用和被调用的函数对同一个对象进行操作。



函数不能返回在函数中创建的临时对象的引用，因为当函数结束时，临时对象将消失，因此这种引用将是非法的。在这种情况下，应返回对象，以生成一个调用程序可以使用的副本。



6. 使用 const

使用 const 可以确保方法不修改参数；可以确保方法不修改调用它的对象；

可以使用 const 来确保引用或指针返回的值不能用于修改对象中的数据：
```c++
const Stock & Stock::topval(const Stock & s) const
{
	if (s.total_val > total_val)
        return s;
    else
        return *this;
}
```

该方法返回对 this 或 s 的引用，且因为 this 与 s 都被声明为 const ，所以函数不能对它们进行修改，同时意味着返回的引用也必须被声明为 const 。

如果函数将参数声明为指向 const 的引用或指针，则不能将该参数传递给另一个函数，除非后者也确保了参数不会被修改。



### 13.8.3 公有继承的考虑因素

1. is-a 关系

要遵循 is-a 关系。如果派生类不是一种特殊的基类，则不要使用公有派生。

在某些情况下，最好的方法可能是创建包含纯虚函数的抽象数据类，并从它派生出其他的类。

表示 is-a 关系的方式之一：

- 无需进行显式类型转换，基类指针就可以指向派生类对象，基类引用可以引用派生类对象。
- 反过来行不通，即不能在不进行显式类型转换的情况下，将派生类指针或引用指向基类对象。不安全。



2. 什么不能被继承

构造函数是不能继承的。

析构函数也是不能继承的。在释放对象时，程序将首先调用派生类的析构函数，然后调用基类的析构函数。通常对于基类，析构函数应该设置为虚函数。

赋值运算符是不能继承的。派生类继承的方法的特征标与基类完全相同，但赋值运算符的特征标随类而异，因为它包含一个类型为其所属类的形参。



3. 赋值运算符

如果编译器发现程序将一个对象赋给同一个类的另一个对象，它将自动为这个类提供一个赋值运算符。



4. 私有成员与保护成员

对派生类而言，保护成员类似于公有成员；但对于外部而言，保护成员与私有成员类似。

讲基类成员设置为私有的可以提高安全性，而将它们设置为保护成员则可简化代码的编写工作，并提高访问速度。

Stroustrup：使用私有数据成员比使用保护数据成员更好，但保护方法很有用。



5. 虚方法

设计基类时，必须确定是否将类方法声明为虚的。

如果希望派生类能够重新定义方法，则应在基类中将方法定义为虚的，这样可以启用晚期联编（动态联编）；

如果不希望重新定义方法，则不必将其声明为虚的；



6. 析构函数

基类的析构函数应当是虚的。

这样，当通过指向对象的基类指针或引用来删除派生类对象时，程序将首先调用派生类的析构函数，然后调用基类的析构函数，而不仅仅是调用基类的析构函数。



7. 友元函数

由于友元函数并非类成员，因此不能继承。

然而，可以通过强制类型转换，将派生类引用或指针转换为基类引用或指针，然后使用转换后的指针或引用来调用基类的友元函数。



8. 有关使用基类方法的说明

以公有方式派生的类的对象可以通过多种方式来使用基类的方法。

- 派生类对象自动使用继承而来的基类方法，如果派生类没有重新定义该方法。
- 派生类的构造函数自动调用基类的构造函数。
- 派生类的构造函数自动调用基类的默认构造函数，如果没有在成员初始化列表中指定其他构造函数。
- 派生类构造函数显式地调用成员初始化列表中指定的基类构造函数。
- 派生类方法可以使用作用域解析运算符来调用公有的和受保护的基类方法。
- 派生类的友元函数可以通过强制类型转换，将派生类引用或指针转换为基类引用或指针，然后使用该引用或指针来调用基类的友元函数。

PS：今天，2024年01月26日，农历腊月十六，是我的生日，哈哈哈哈，太开心啦



### 13.8.4 类函数小节

C++类函数有很多不同的变体，其中有些可以继承，有些不可以。

参考下表，其中 op= 表示诸如 += 、*= 等格式的赋值运算符。


|    函数    | 能否继承 | 成员还是友元 | 默认能否生成 | 能否为虚函数 | 是否可以有返回类型 |
| :--------: | :------: | :----------: | :----------: | :----------: | :----------------: |
|  构造函数  |    否    |     成员     |      能      |      否      |         否         |
|  析构函数  |    否    |     成员     |      能      |      能      |         否         |
|     =      |    否    |     成员     |      能      |      能      |         能         |
|     &      |    能    |     任意     |      能      |      能      |         能         |
|  转换函数  |    能    |     成员     |      否      |      能      |         否         |
|     ()     |    能    |     成员     |      否      |      能      |         能         |
|     []     |    能    |     成员     |      否      |      能      |         能         |
|     ->     |    能    |     成员     |      否      |      能      |         能         |
|    op=     |    能    |     任意     |      否      |      能      |         能         |
|    new     |    能    |   静态成员   |      否      |      否      |       void*        |
|   delete   |    能    |   静态成员   |      否      |      否      |        void        |
| 其他运算符 |    能    |     任意     |      否      |      能      |         能         |
|  其他成员  |    能    |     成员     |      否      |      能      |         能         |
|    友元    |    否    |     友元     |      否      |      否      |         能         |



# 14 C++ 中的代码重用

## 14.1 包含对象成员的类

### 14.1.1 valarray 类简介

valarray 类，包含在头文件 <valarray> 中，参考链接：[valarray](https://zh.cppreference.com/w/cpp/numeric/valarray)

支持将数组中所有元素的值相加以及在数组中找出最大和最小的值等操作。

valarray 是一个模板类，便于处理不同的数据类型。在声明对象时，必须指定具体的数据类型。

```c++
// int数组
valarray<int> q_values;

// double数组
valarray<double> weights;
```

构造函数使用方法举例

```c++
double gpa[5] = {3.1, 3.5, 3.8, 2.9, 3.3};

// 一个空的double类型数组
valarray<double> v1;

// 拥有8个元素的int类型数组
valarray<int> v2(8);

// 拥有8个元素的int类型数组，均被初始化为10
valarray<int> v3(10, 8);

// 拥有4个元素的double类型数组，被初始化为gpa数组前四个元素值
valarray<double> v4(gpa, 4);

// C++11可以使用初始化列表
valarray<int> v5 = {20, 32, 17, 9};
```

类方法举例

- `operator[]()`：可以直接访问各个元素；
- `size()`：返回包含的元素数；
- `sum()`：返回所有元素的总和；
- `max()`：返回最大的元素；
- `min()`：返回最小的元素；

### 14.1.2 Student 类的设计

学生不是姓名，也不是一组考试成绩。这里的关系是 has-a ，学生有姓名，也有一组考试分数。通常，用于建立 has-a 关系的 C++ 技术是组合（包含），即创建一个包含其他类对象的类。

> **接口和实现**
>
> 使用公有继承时，类可以继承接口，可能还有实现（基类的纯虚函数提供接口，但不提供实现）。获得接口是 is-a 关系的组成部分。而使用组合，类可以获得实现，但不能获得接口。不继承接口是 has-a 关系的组成部分。

### 14.1.3 Student 类示例

代码参考对应小节练习代码。



> **C++和约束**
>
> C++包含让程序员能够限制程序结构的特性——使用 explicit 防止单参数构造函数的隐式转换，使用 const 限制方法修改数据，等等。这样做的根本原因是：在编译阶段出现错误优于在运行阶段出现错误。



**初始化顺序**

当初始化列表包含多个项目时，这些项目被初始化的顺序为它们被声明的顺序，而不是它们在初始化列表中的顺序。例如，假设 Student 构造函数如下：

```c++
Student(const char * str, const double * pd, int n)
	: scores(pd, n), name(str) {}
```

则 name 成员仍将首先被初始化，因为在类定义中它首先被声明。对于这个例子来说，初始化顺序并不重要，但如果代码使用一个成员的值作为另一个成员的初始化表达式的一部分时，初始化顺序就非常重要了。



## 14.2 私有继承

使用私有继承，基类的公有成员和保护成员都将成为派生类的私有成员。这意味着基类方法将不会成为派生对象公有接口的一部分，但可以在派生类的成员函数中使用它们。

省略关键字则默认为私有继承，private 是默认值，因此省略访问限定符也将导致私有继承。



### 14.2.2 使用包含还是私有继承

大部分首选使用包含

- 易于理解；
- 继承会引起很多问题，尤其从多个基类继承时，可能必须处理很多问题，如包含同名方法的独立的基类或共享祖先的独立基类；
- 包含能够包括多个同类的子对象。如果使用继承 string 类对象，则只能有一个对象，但使用包含，则可以使用多个；

另一种需要使用私有继承的情况是需要重新定义虚函数。派生类可以重新定义虚函数，但包含类不能。使用私有继承，重新定义的函数将只能在类中使用，而不是公有的。

> **提示：**
>
> 通常，应使用包含来建立has-a关系；如果新类需要访问原有类的保护成员，或需要重新定义虚函数，则应使用私有继承。



### 14.2.3 保护继承

保护继承，使用关键字 protected 。下表为各种继承方式：

|       特征       |       公有继承       |        保护继承        |       私有继承       |
| :--------------: | :------------------: | :--------------------: | :------------------: |
|   公有成员变量   |   派生类的公有成员   |    派生类的保护成员    |   派生类的私有成员   |
|   保护成员变量   |   派生类的保护成员   |    派生类的保护成员    |   派生类的私有成员   |
|   私有成员变量   | 只能通过基类接口访问 |  只能通过基类接口访问  | 只能通过基类接口访问 |
| 能否隐式向上转换 |          是          | 是（但只能在派生类中） |          否          |



### 14.2.4 使用 using 重新定义访问权限

设要让基类的方法在派生类外面可用，方法之一是定义一个使用该基类方法的派生类方法。

PS：基本像是把基类方法（STL标准库/其他自定义基类私有/保护方法），重新封装对外接口；



第二种方法，使用 using ，但 using 声明只适用于继承，并不适用于包含。

```c++
class Student : private std::string, private std::valarray<double>
{
public:
    using std::valarray<double>::min;
    using std::valarray<double>::max;
}
```



## 14.3 多重继承



### 14.3.1 有多少 Worker

此时如果从 Singer 和 Waiter 公有派生出 SingingWaiter ，如下

```c++
class SiingingWaiter : public Singer, public Waiter
{
    
};
```

因为 Singer 和 Waiter 都继承自 Worker ，因此 SingingWaiter 将包含两个 Worker 组件。

如果将派生类对象的地址赋给基类指针，将出现二义性：

```C++
SingingWaiter ed;
Worker * pw = &ed; // 不知道是Singer还是Waiter的指针
```

此时应该使用类型转换来指定对象：

```c++
Worker * pw1 = (Waiter *) &ed;
Worker * pw2 = (Singer *) &ed;
```



1. 虚基类

虚基类使得从多个类（它们的基类相同）派生出的对象只继承一个基类对象。例如，通过在类声明中使用关键字 virtual ，可以使 Worker 被用作 Singer 和 Waiter 的虚基类（ virtual 和 public 的次序无关紧要）：

```c++
// 虚基类
class Singer : virtual public Worker
{
    
};

// 虚基类，与顺序无关
class Waiter : public virtual Worker
{
    
};

class SiingingWaiter : public Singer, public Waiter
{
    
};
```

SingingWaiter 对象将只包含 Worker 对象的一个副本。从本质上说，继承的 Singer 和 Waiter 对象共享一个 Worker 对象，而不是各自引入自己的 Worker 对象副本。因为 SingingWaiter 现在只包含了一个 Worker 子对象，所以可以使用多态。



为什么使用术语虚？

毕竟，在虚函数和虚基类之间并不存在明显的联系。C++ 用户强烈反对引入新的关键字，因为这将给他们带来很大的压力。例如，如果新关键字与重要程序中的重要函数或变量的名称相同，这将非常麻烦。因此，C++ 对这种新特性也使用关键字 virtual ——有点像关键字重载。



为什么不抛弃将基类声明为虚的这种方式，而使虚行为成为 MI 的准则呢？

第一，在一些情况下，可能需要基类的多个拷贝；

第二，将基类作为虚的要求程序完成额外的计算，为不需要的工具付出代价是不应当的；

第三，这样做有其缺点；



是否存在麻烦？

是的。为使虚基类能够工作，需要对 C++ 规则进行调整，必须以不同的方式编写一些代码。另外，使用虚基类还可能需要修改已有的代码。例如，将 SingingWaiter 类添加到 Worker 集成层次中时，需要在 Singer 和 Waiter 类中添加关键字 virtual 。



2. 新的构造函数规则

如果 Worker 是虚基类，构造函数默认的信息传递是无效的，如下

```c++
SingingWaiter(const Worker & wk, int p = 0, int v = Singer::other)
    : Waiter(wk, p), Singer(wk, v)
{
        
}
```

此时，如果需要自动传递信息给基类，将通过两条不同的途径（Waiter / Singer）将 wk 传递给 Worker 对象。

因此为了避免冲突，C++ 在基类是虚的时，禁止信息通过中间类自动传递给基类。

但编译器必须在构造派生对象之前构造基类对象组件，此时编译器将使用 Worker 的默认构造函数。

如果不想用默认的，则需要显式地调用所需的基类构造函数

```c++
SingingWaiter(const Worker & wk, int p = 0, int v = Singer::other)
    : Worker(wk), Waiter(wk, p), Singer(wk, v)
{
        
}
```

如上代码将显式的调用构造函数 worker (const Worker &)。此时这种用法是合法的，对于虚基类，必须这样做；但对于非虚基类，则是非法的。

> 警告：
>
> 如果类有间接虚基类，则除非只需使用该虚基类的默认构造函数，否则必须显式地调用该虚基类的某个构造函数。



### 14.3.2 哪个方法

对于单继承，如果没有重新定义Show( )，则将使用最近祖先中的定义。而在多重继承中，每个直接祖先都有一个Show( )函数，这使得上述调用是二义性的。

类似之前的构造函数，普通继承而来的函数，也会存在多重继承的二义性问题。

> 警告：
>
> 多重继承可能导致函数调用的二义性。例如，BadDude 类可能从 Gunslinger 类和 PokerPlayer 类那里继承两个完全不同的 Draw( ) 方法。

解决方法：

- 用作用域运算符显式指出类；
- 在当前类中封装接口，内部使用合适的基类接口实现；

总之，在祖先相同时，使用 MI 必须引入虚基类，并修改构造函数初始化列表的规则。另外，如果在编写这些类时没有考虑到 MI ，则还可能需要重新编写它们。



1. 混合使用虚基类和非虚基类

当类通过多条虚途径和非虚途径继承某个特定的基类时，该类将包含一个表示所有的虚途径的基类子对象和分别表示各条非虚途径的多个基类子对象。

2. 虚基类和支配

派生类中的名称优先于直接或间接祖先类中的相同名称。



### 14.3.3 MI 小结

主要变化（同时也是使用虚基类的原因）是，从虚基类的一个或多个实例派生而来的类将只继承了一个基类对象。为实现这种特性，必须满足其他要求：

- 有间接虚基类的派生类包含直接调用间接基类构造函数的构造函数，这对于间接非虚基类来说是非法的；

- 通过优先规则解决名称二义性。

正如您看到的，MI会增加编程的复杂程度。然而，这种复杂性主要是由于派生类通过多条途径继承同一个基类引起的。避免这种情况后，唯一需要注意的是，在必要时对继承的名称进行限定。



## 14.4 类模板

简单模板类声明如下

```c++
template <typename Type>

// 头文件声明类型，应该替换为 Type
Type items[MAX];

// 成员函数实现，要增加模板类变量；内联函数则可以省略模板前缀及类限定符
template <typename Type>
bool Stack<Type>::push(const Type & item)
{

}
```



栈的析构函数对字符串有何影响呢？

没有。构造函数使用new创建一个用于保存指针的数组，析构函数删除该数组，而不是数组元素指向的字符串。



### 14.4.4 数组模板示例和非类型参数

模板常用作容器类，这是因为类型参数的概念非常适合于将相同的存储方案用于不同的类型。

比如常见的 array / map / vector / list 等等，都属于容器类，可以存储不同的类型。



致编译器定义名为ArrayTP<double, 12>的类，并创建一个类型为ArrayTP<double, 12>的eggweight对象。定义类时，编译器将使用double替换T，使用12替换n。

表达式参数有一些限制。表达式参数可以是整型、枚举、引用或指针。因此，double m是不合法的，但double * rm和double * pm是合法的。另外，模板代码不能修改参数的值，也不能使用参数的地址。所以，在ArrayTP模板中不能使用诸如n++和&n等表达式。另外，实例化模板时，用作表达式参数的值必须是常量表达式。

与Stack中使用的构造函数方法相比，这种改变数组大小的方法有一个优点。构造函数方法使用的是通过new和delete管理的堆内存，而表达式参数方法使用的是为自动变量维护的内存栈。这样，执行速度将更快，尤其是在使用了很多小型数组时。



表达式参数的缺点是，每个数组大小都将生成自己的模板，如下为两个独立的类声明

```c++
ArrayTP<double, 12> eggweights;
ArrayTP<double, 13> donuts;
```

但是如下声明，只生成一个类声明，并将数组大小信息传递给类的构造函数：

```c++
Stack<int> eggs(12);
Stact<int> dunkers(13);
```



另一个区别是，构造函数方法更通用，这是因为数组大小是作为类成员（而不是硬编码）存储在定义中的。这样可以将一种尺寸的数组赋给另一种尺寸的数组，也可以创建允许数组大小可变的类。



### 14.4.5 模板多功能性

1. 递归使用模板。

```c++
// twodee是一个包含10个元素的数组，其中每个元素都是一个包含5个int元素的数组。
ArrayTP< ArrayTP<int,5> , 10> twodee;

// 等价的常规数组声明
int twodee[10][5];
```



2. 使用多个类型参数。参考 code_14.19 。



3. 默认类型模板参数。

虽然可以为类模板类型参数提供默认值，但不能为函数模板参数提供默认值。然而，可以为非类型参数提供默认值，这对于类模板和函数模板都是适用的。



### 14.4.6 模板的具体化

1. 隐式实例化。

且编译器在需要对象之前，不会生成类的隐式实例化。比如只有变量的声明，未具体使用时，编译器不会实例化。

2. 显式实例化。

当使用关键字template并指出所需类型来声明类时，编译器将生成类声明的显式实例化（explicit instantiation）。

3. 显式具体化。

显式具体化（explicit specialization）是特定类型（用于替换模板中的泛型）的定义。有时候，可能需要在为特殊类型实例化时，对模板进行修改，使其行为不同。在这种情况下，可以创建显式具体化。

当具体化模板和通用模板都与实例化请求匹配时，编译器将使用具体化版本

4. 部分具体化

类似于函数参数一样，可以指定形参默认值，当无实参传入时，使用默认参数。

如果有多个模板可供选择，编译器将使用具体化程度最高的模板。



### 14.4.7 成员模板

练习代码参考 code_14.20 。

如果用的编译器接受类外边的模板定义，则可以在外边实现，需要分行多层嵌套模板头。



### 14.4.8 将模板用作参数

可以混合使用模板参数和常规参数，代码如下

```c++
template <template <typename T> class Thing, typename U, typename V>
class Crab
{
private:
    Thing<U> s1;
    Thing<V> s2;
}
```

如上代码，s1 / s2 可存储的数据类型为泛型，不是固定类型。此时在程序中声明 Crab 类变量时，应如下操作

```c++
Crab<Stack, int, double> nebula;
```

模板参数 T 表示一种模板类型，类型参数 U 和 V 表示非模板类型。



### 14.4.9 模板类和友元

模板类声明也可以有友元。模板的友元分3类：

- 非模板友元；
- 约束（bound）模板友元，即友元的类型取决于类被实例化时的类型；
- 非约束（unbound）模板友元，即友元的所有具体化都是类的每一 个具体化的友元。



### 14.4.10 模板别名（C++11）

通常，使用 typedef 定义类型别名，但 c++11 提供了另外一种选择

```c++
typedef std::array<double, 12> arrd;

// c++11
template <typename T>
using arrtype = std::array<T, 12>;
```

c++11 允许将语法 using= 用于非模板，参考如下

```c++
typedef const char * pc1;
using pc2 = const char *;

typedef const int *(*pa1)[10];
using pa2 = const int *(*)[10];
```

这种新语法可读性更强一些，可以让类型名和类型信息更清晰。



# 15 友元、异常和其他

## 15.1 友元

### 15.1.1 友元类

什么时候希望一个类成为另一个类的友元呢？我们来看一个例子。假定需要编写一个模拟电视机和遥控器的简单程序。决定定义一个Tv类和一个Remote类，来分别表示电视机和遥控器。很明显，这两个类之间应当存在某种关系，但是什么样的关系呢？遥控器并非电视机，反之亦然，所以公有继承的is-a关系并不适用。遥控器也非电视机的一部分，反之亦然，因此包含或私有继承和保护继承的has-a关系也不适用。事实上，遥控器可以改变电视机的状态，这表明应将Romote类作为Tv类的一个友元。



参考《code_15.01_02_03》，目的在于，类友元是一种自然用语，用于表示一些关系。如果不使用某些形式的友元关系，则必须将Tv类的私有部分设置为公有的，或者创建一个笨拙的、大型类来包含电视机和遥控器。这种解决方法无法反应这样的事实，即同一个遥控器可用于多台电视机。



### 15.1.2 友元成员函数

参考实现头文件 tvfm.h 。



### 15.1.3 其他友元关系

如果两个类需要互相成为友元，则类似步骤如下

```c++
class Tv
{
    friend class Remote;
public:
    void buzz(Remote & r); // 之前已声明Remote为友元类，所以可直接使用
};

class Remote
{
    friend class Tv;
public:
    void Bool volup(Tv & t) { t.volup(); } // 之前已声明Tv为友元类，所以可直接使用
};

inline void Tv::buzz(Remote & r)
{
    // buzz函数用到了Remote类，因此必须在Remote类声明之后定义
}
```

由于Remote的声明位于Tv声明的后面，所以可以在类声明中定义 Remote::volup( )，但Tv::buzz( )方法必须在Tv声明的外部定义，使其位 于Remote声明的后面。如果不希望buzz( )是内联的，则应在一个单独的 方法定义文件中定义它。



### 15.1.4 共同的友元

需要使用友元的另一种情况是，函数需要访问两个类的私有数据。 示例代码如下

```c++
// 前向声明
class Analyzer;

class Probe
{
    friend void sync(Analyzer & a, const Probe & p);
    friend void sync(Probe & p, const Analyzer & a);
};

class Analyzer
{
    friend void sync(Analyzer & a, const Probe & p);
    friend void sync(Probe & p, const Analyzer & a);
};

inline void sync(Analyzer & a, const Probe & p)
{
    
}

inline void sync(Probe & p, const Analyzer & a)
{
    
}
```



## 15.2 嵌套类

struct 结构体内部也可存在构造函数，与 class 类有点相似；

如果要在方法文件中定义构造函数，则需要通过多次作用域解析运算符实现，类似下属代码

```c++
Queue::Node::Node(const Item & i)
    : item(i), next(0)
{
        
}
```



### 15.2.1 嵌套类和访问权限

类的默认访问权限是私有的，且派生类不能直接访问基类的私有部分。

1. 作用域

嵌套类、结构和枚举的作用域特征参考下表

| 声明位置 | 包含它的类是否可以使用它 | 从包含它的类派生而来的类是否可以使用它 |   在外部是否可以使用   |
| :------: | :----------------------: | :------------------------------------: | :--------------------: |
| 私有部分 |            是            |                   否                   |           否           |
| 保护部分 |            是            |                   是                   |           否           |
| 公用部分 |            是            |                   是                   | 是，通过类限定符来使用 |

2. 访问控制

类声明的位置决定了类的作用域或可见性。类可见后，访问 控制规则（公有、保护、私有、友元）将决定程序对嵌套类成员的访问 权限。

即类放在哪个地方，决定别人能不能看到它；但类内部成员仍然遵循控制规则，决定看到这个类的地方，能不能用这些成员数据。



### 15.2.2 模板中的嵌套

参考练习代码《code_15.05_06》。



## 15.3 异常

### 15.3.1 调用 abort()

参考代码 15.07 运行结果。

### 15.3.2 返回错误码

参考代码 15.08 运行结果。

### 15.3.3 异常机制

如果函数引发了异常，而没有try块或没有匹配的处理 程序时，将会发生什么情况？

在默认情况下下，程序最终将调用abort( ) 函数，但可以修改这种行为。

### 15.3.4 将对象用作异常类型



### 15.3.6 栈解退



### 15.3.7 其他异常特性

p将指向oops的副本而不是oops本身。这是件好事，因为函数super( )执行完毕后，oops将不复存在。

```c++
try
{
	super();
}
catch(problem & p)
{
    // 代码块
}
```



既然throw语句将生成副本，为何代码中使用引用 呢？毕竟，将引用作为返回值的通常原因是避免创建副本以提高效率。

答案是，引用还有另一个重要特征：基类引用可以执行派生类对象。假 设有一组通过继承关联起来的异常类型，则在异常规范中只需列出一个 基类引用，它将与任何派生类对象匹配。



```c++
class bad_1 {};
class bad_2 : public bad_1 {};
class bad_3 : public bad_2 {};

void duper()
{
    if (oh_no)
        throw bad_1();
    if (rats)
        throw bad_2();
    if (drat)
        throw bad_3();
}

try
{
    duper();
}
catch (bad_3 & be)
{
    // 代码块
}
catch (bad_2 & be)
{
    // 代码块
}
catch (bad_1 & be)
{
    // 代码块
}
```

如果将bad_1 &处理程序放在最前面，它将捕获异常bad_1、bad_2 和bad_3；通过按相反的顺序排列，bad_3异常将被bad_3 &处理程序所捕获。

> 如果有一个异常类继承层次结构，应这样排列catch块：将捕获位于层次结构最下面的异常类 的catch语句放在最前面，将捕获基类异常的catch语句放在最后面。



```c++
// 捕获所有异常
catch (...)
{
    // 类似于switch的default语句
}
```



### 15.3.8 exception 类

1. stdexcept异常类
2. bad_alloc异常和new
3. 空指针和new

```c++
// 为兼容老代码处理new失败时返回空指针，C++提供了关键字std::nothrow，让用户可以选择自己的行为。
int * pi = new (std::nothrow) int;
int * pa = new (std::nothrow) int[500];

// 此时判断语句可以改为如下形式
Big * pb;
pb = new Big[10000];
if (NULL == pb)
{
    exit(EXIT_FAILURE);
}
```



### 15.3.9 异常、类和继承

见练习代码，code_15.14_15_16



### 15.3.10 异常何时会迷失方向



### 15.3.11 有关异常的注意事项

从前面关于如何使用异常的讨论可知，应在设计程序时就加入异常 处理功能，而不是以后再添加。这样做有些缺点。例如，使用异常会增 加程序代码，降低程序的运行速度。异常规范不适用于模板，因为模板 函数引发的异常可能随特定的具体化而异。异常和动态内存分配并非总 能协同工作。



> **异常处理**
>
> 在现代库中，异常处理的复杂程度可能再创新高——主要原因在于文档没有对异常处理 例程进行解释或解释得很蹩脚。任何熟练使用现代操作系统的人都遇到过未处理的异常导致 的错误和问题。这些错误背后的程序员通常面临一场艰难的战役，需要不断了解库的复杂 性：什么异常将被引发，它们发生的原因和时间，如何处理它们，等等。
>
>  程序员新手很快将发现，理解库中异常处理像学习语言本身一样困难，现代库中包含的 例程和模式可能像C++语法细节一样陌生而困难。要开发出优秀的软件，必须花时间了解库和 类中的复杂内容，就像必须花时间学习C++本身一样。通过库文档和源代码了解到的异常和错 误处理细节将使程序员和他的软件受益。



## 15.4 RTTI

RTTI是运行阶段类型识别（Runtime Type Identification）的简称。

RTTI旨在为程序在运行阶段确定对象的类型提供一种标准方式。



### 15.4.1 RTTI 的用途

RTTI 可以解决派生对象包含非继承而来的方法，或者出于调试目的获取对象类型的场景。



### 15.4.2 RTTI 的工作原理

C++ 有 3 个支持 RTTI 的元素。

- 如果可能的话，dynamic_cast 运算符将使用一个指向基类的指针来生成一个指向派生类的指针；否则，该运算符返回 0 ——空指针。
- typeid 运算符返回一个指出对象的类型的值。
-  type_info 结构存储了有关特定类型的信息。

 只能将 RTTI 用于包含虚函数的类层次结构，原因在于只有对于这种类层次结构，才应该将派生对象的地址赋给基类指针。

> **警告**
>
> RTTI只适用于包含虚函数的类。



1. dynamic_cast 运算符

dynamic_cast 我更多用来将基类指针转换为特定派生类指针。



2. typeid 运算符和 type_info 类

typeid 运算符使得能够确定两个对象是否为同种类型。它与 sizeof 有些相像，可以接受两种参数：

- 类名；
- 结果为对象的表达式。



3. 误用 RTTI 的例子

使用 typeid 会导致有很长的 if...else... 判断，且基类如果有新增派生类的话，还需要再新增分支判断结构，导致代码冗长。

如果发现在扩展的 if else 语句系列中使用了 typeid ，则应考虑是否应该使用虚函数和 dynamic_cast 。



## 15.5 类型转换运算符

C++ 提供的类型转换运算符

- dynamic_cast
- const_cast
- static_cast
- reinterpret_cast



dynamic_cast 用途是，使得能够在类层次结构中进行向上转换（由于 is-a关系，这样的类型转换是安全的），而不允许其他转换。使用方法如下

```c++
dynamic_cast < type-name > (expression)
```



const_cast 运算符用于执行只有一种用途的类型转换，即改变值为 const 或 volatile ，其语法与 dynamic_cast 运算符相同：

```c++
const_cast < type-name > (expression)
```

如果类型的其他方面也被修改，则上述类型转换将出错。也就是说，除了 const 或 volatile 特征（有或无）可以不同外，type_name 和 expression 的类型必须相同。



static_cast 运算符的语法与其他类型转换运算符相同

```c++
static_cast < type-name > (expression)
```

仅当 type_name 可被隐式转换为 expression 所属的类型或 expression 可被隐式转换为 type_name 所属的类型时，上述转换才是合法的，否则将出错。

由于无需进行类型转换，枚举值就可以被转换为整型，所以可以用 static_cast 将整型转换为枚举值。同样，可以使用 static_cast 将 double 转换为 int、将 float 转换为 long 以及其他各种数值转换。



reinterpret_cast 运算符用于天生危险的类型转换。

```c++
reinterpret_cast < type-name > (expression)
```

代码示例如下

```c++
struct dat {short a; short b;};
long value = 0xA224B118;
dat * pd = reinterpret_cast<dat *>(&value);
std::cout << std::hex << pd->a;

/* 代码运行结果
b118
*/
```



# 16 string 类和标准模板库

STL：标准模板库



## 16.1 string 类

### 16.1.1 构造字符串

<center>
    表16.1 string类的构造函数
</center>

| 序号 | 构造函数                                                     | 描述                                                         |
| :--: | :----------------------------------------------------------- | :----------------------------------------------------------- |
|  1   | string(const char * s)                                       | 将 string 对象初始化为 s 指向的 NBTS                         |
|  2   | string(size_type n, char c)                                  | 创建一个包含 n 个元素的 string 对象，其中每个元素都被初始化为字符 c |
|  3   | string(const string & str)                                   | 将一个 string 对象初始化为 string 对象 str （复制构造函数）  |
|  4   | string()                                                     | 创建一个默认的 string 对象，长度为 0 （默认构造函数）        |
|  5   | string(const char * s, size_type n)                          | 将 string 对象初始化为 s 指向的 NBTS 的前 n 个字符，即使超过了 NBTS 结尾 |
|  6   | template<class Iter><br />string(Iter begin, Iter end)       | 将 string 对象初始化为区间 [begin, end] 内的字符，其中 begin 和 end 的行为就像指针，用于指定位置，范围包括 begin 在内，但不包括 end 。 |
|  7   | string(const string & str, string size_type pos = 0, size_type n = npos) | 将一个 string 对象初始化为对象 str 中从位置 pos 开始到结尾的字符，或从位置 pos 开始的 n 个字符。（省略后两个参数时，与#3一样） |
|  8   | string(string && str) noexcept                               | 这是 C++11 新增的，它将一个 string 对象初始化为 string 对象 str ，并可能修改 str （移动构造函数） |
|  9   | string(initializer_list<char> il)                            | 这是 C++11 新增的，它将一个 string 对象初始化为初始化列表 il 中的字符 |



### 16.1.2 string 类输入

string 版本的 getline( ) 函数从输入中读取字符，并将其存储到目标 string 中，直到发生下列三种情况之一：

- 到达文件尾，在这种情况下，输入流的 eofbit 将被设置，这意味着方法 fail( ) 和 eof( ) 都将返回 true ；
- 遇到分界字符（默认为 \n ），在这种情况下，将把分界字符从输入流中删除，但不存储它；
- 读取的字符数达到最大允许值（ string::npos 和可供分配的内存字节数中较小的一个），在这种情况下，将设置输入流的 failbit ，这意味着方法 fail( ) 将返回 true 。



### 16.1.3 使用字符串

<center>
    表16.2 重载的 find() 方法
</center>

| 方法原型                                                     | 描述                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| size_type find(const string & str, size_type pos = 0) const  | 从字符串的 pos 位置开始，查找子字符串 str 。如果找到，则返回该子字符串首次出现时其首字符的索引；否则，返回 string::npos |
| size_type find(const char * s, size_type pos = 0) const      | 从字符串的 pos 位置开始，查找子字符串 s 。如果找到，则返回该子字符串首次出现时其首字符的索引；否则，返回 string::npos |
| size_type find(const char * s, size_type pos = 0, size_type n) | 从字符串的 pos 位置开始，查找 s 的前 n 个字符组成的子字符串。如果找到，则返回该子字符串首次出现时其首字符的索引；否则，返回 string::npos |
| size_type find(char ch, size_type pos = 0) const             | 从字符串的 pos 位置开始，查找字符 ch 。如果找到，则返回该字符首次出现的位置；否则，返回 string::npos |



### 16.1.4 string 还提供了哪些功能

如果字符串不断增大，超过了内 存块的大小，程序将分配一个大小为原来两倍的新内存块，以提供足够的增大空间，避免不断地分配新的内存块。方法 capacity( ) 返回当前分配给字符串的内存块的大小，而 reserve( ) 方法让您能够请求内存块的最小长度。



### 16.1.5 字符串种类

string 库实际上是基于一个模板类

```c++
template<class charT, class traits = char _traits<charT>, class Allocator = allocator<charT> >
basic_string
{
    // ...
};
```

模板 basic_string 有 4 个具体化

```c++
typedef basic_string<char> string;
typedef basic_string<wchar_t> wstring;
typedef basic_string<char16_t> u16string;	// C++11
typedef basic_string<char32_t> u32string;	// C++11
```



## 16.2 智能指针模板类

auto_ptr、unique_ptr 和 shared_ptr

### 16.2.1 使用智能指针

智能指针使用头文件 memory 。

```c++
#include <memory>
```



### 16.2.2 有关智能指针的注意事项

```c++
auto_ptr<string> ps (new string("I reigned lonely as a cloud."));
auto_ptr<string> vocation;
vocation = ps;
```

上述代码，如果 ps 和 vocation 是常规指针， 则两个指针将指向同一个 string 对象。这是不能接受的，因为程序将试图删除同一个对象两次——一次是 ps 过期时，另一次是 vocation 过期时。

解决方法

- 定义赋值运算符，使之执行深复制。这样两个指针将指向不同的对象，其中的一个对象是另一个对象的副本。
- 建立所有权（ownership）概念，对于特定的对象，只能有一个智能指针可拥有它，这样只有拥有对象的智能指针的构造函数会删除该 对象。然后，让赋值操作转让所有权。这就是用于 auto_ptr 和 unique_ptr 的策略，但 unique_ptr 的策略更严格。
- 创建智能更高的指针，跟踪引用特定对象的智能指针数。这称为引用计数（reference counting）。例如，赋值时，计数将加1，而指针过期时，计数将减1。仅当最后一个指针过期时，才调用 delete 。这 是 shared_ptr 采用的策略。



### 16.2.3 unique_ptr 为何优于 auto_ptr

```c++
auto_ptr<string> p1(new string("auto"));	// #1
auto_ptr<string> p2;						// #2
p2 = p1;									// #3
```

在语句#3中，p2接管string对象的所有权后，p1的所有权将被剥 夺。前面说过，这是件好事，可防止p1和p2的析构函数试图删除同一个 对象；但如果程序随后试图使用p1，这将是件坏事，因为p1不再指向有 效的数据。



```c++
unique_ptr<string> p3(new string("auto"));	// #4
unique_ptr<string> p4;						// #5
p4 = p3;									// #6
```

编译器认为语句#6非法，避免了p3不再指向有效数据的问题。因 此，unique_ptr比auto_ptr更安全（编译阶段错误比潜在的程序崩溃更安 全）。



> 警告： 
>
> 使用new分配内存时，才能使用auto_ptr和shared_ptr，使用new [ ]分配内存时，不能使用它 们。不使用new分配内存时，不能使用auto_ptr或shared_ptr；不使用new或new []分配内存时， 不能使用unique_ptr。





### 16.2.4 选择智能指针

如果程序要使用多个指向同一个对象的指针，应选择shared_ptr。这样的情况包括：有一个指针数组，并使用一些辅助指针来标识特定的元素，如最大的元素和最小的元素；两个对象包含都指向第三个对象的指针；STL容器包含指针。



在满足unique_ptr要求的条件时，也可使用auto_ptr，但unique_ptr是 更好的选择。如果您的编译器没有提供unique_ptr，可考虑使用BOOST 库提供的scoped_ptr，它与unique_ptr类似。



## 16.3 标准模板库

STL提供了一组表示容器、迭代器、函数对象和算法的模板。容器 是一个与数组类似的单元，可以存储若干个值。STL容器是同质的，即 存储的值的类型相同；算法是完成特定任务（如对数组进行排序或在链 表中查找特定值）的处方；迭代器能够用来遍历容器的对象，与能够遍 历数组的指针类似，是广义指针；函数对象是类似于函数的对象，可以 是类对象或函数指针（包括函数名，因为函数名被用作指针）。STL使 得能够构造各种容器（包括数组、队列和链表）和执行各种操作（包括 搜索、排序和随机排列）。



### 16.3.1 模板类 vector

>  分配器：
>
> 与string类相似，各种STL容器模板都接受一个可选的模板参数，该参数指定使用哪个分 配器对象来管理内存。例如，vector模板的开头与下面类似：
>
> ```c++
> template <class T, class Allocator = allocator<T>>
> class vector
> {
>     
> }
> ```
>
> 如果省略该模板参数的值，则容器模板将默认使用allocator类。这个类使用new和 delete。



### 16.3.2 可对矢量执行的操作

了解STL如何使用两个迭代器来定义区间至关重要。第一个迭代器指向区间的起始处，第二个迭代器位于区间终止处的后一个位置。

> **注意：**
>
> 区间[it1, it2)由迭代器it1和it2指定，其范围为it1到it2（不包括it2）。



### 16.3.3 对矢量可执行的其他操作

STL从更广泛 的角度定义了非成员（non-member）函数来执行这些操作，即不是为每 个容器类定义find( )成员函数，而是定义了一个适用于所有容器类的非 成员函数find( )。这种设计理念省去了大量重复的工作。例如，假设有8 个容器类，需要支持10种操作。如果每个类都有自己的成员函数，则需 要定义80（8*10）个成员函数。但采用STL方式时，只需要定义10个非 成员函数即可。在定义新的容器类时，只要遵循正确的指导思想，则它 也可以使用已有的10个非成员函数来执行查找、排序等操作。



for_each() 函数可以用来代替 for 循环，这样可以避免显式地使用迭代器变量。

```c++
vector<Review>::iterator pr;
for (pr = books.begin(); pr != books.end(); pr++)
    ShowReview(*pr);

// 上述代码可替换为如下内容
for_each(books.begin(), books.end(), ShowReview);
```



for_each( )函数可用于很多容器类，它接受3个参数。前两个 是定义容器中区间的迭代器，最后一个是指向函数的指针（更普遍地 说，最后一个参数是一个函数对象，函数对象将稍后介绍）。for_each( )函数将被指向的函数应用于容器区间中的各个元素。被指向的函数不 能修改容器元素的值。可以用for_each( )函数来代替for循环。



Random_shuffle( )函数接受两个指定区间的迭代器参数，并随机排 列该区间中的元素。



sort( )函数也要求容器支持随机访问。该函数有两个版本，第一个 版本接受两个定义区间的迭代器参数，并使用为存储在容器中的类型元 素定义的<运算符，对区间中的元素进行操作。



### 16.3.4 基于范围的 for 循环（C++11）

```c++
double prices[5] = {4.99, 10.99, 6.87, 7.99, 8.49};
for (double x : prices)
{
    cout << x << std::endl;
}
```



基于范围的for循环可修改容器的内容，诀窍是 指定一个引用参数。



## 16.4 泛型编程

STL 是一种泛型编程，generic programming 。

面向对象编程，关注的是编程的数据方面；而泛型编程关注的是算法。

他们之间的共同点是抽象和创建可重用代码。



### 16.4.1 为何使用迭代器

模板使得算法独立于存储的数 据类型，而迭代器使算法独立于使用的容器类型。



要实现find函数，迭代器应具备哪些特征呢？

- 应能够对迭代器执行解除引用的操作，以便能够访问它引用的值。 即如果p是一个迭代器，则应对*p进行定义。
- 应能够将一个迭代器赋给另一个。即如果p和q都是迭代器，则应对 表达式p=q进行定义。
- 应能够将一个迭代器与另一个进行比较，看它们是否相等。即如果 p和q都是迭代器，则应对p= =q和p!=q进行定义。
-  应能够使用迭代器遍历容器中的所有元素，这可以通过为迭代器p 定义++p和p++来实现。



为区分++运算符的前缀版本和后缀版本，C++将operator++作为前 缀版本，将operator++（int）作为后缀版本；其中的参数永远也不会被 用到，所以不必指定其名称。



作为一种编程风格，最好避免直接使用迭代器，而应尽可 能使用STL函数（如for_each( )）来处理细节。也可使用C++11新增的基 于范围的for循环：

```c++
for (auto x : scores) cout << x << endl;
```



来总结一下STL方法。首先是处理容器的算法，应尽可能用通用的 术语来表达算法，使之独立于数据类型和容器类型。为使通用算法能够 适用于具体情况，应定义能够满足算法需求的迭代器，并把要求加到容 器设计上。即基于算法的要求，设计基本迭代器的特征和容器特征。



### 16.4.2 迭代器类型

1. 输入迭代器

需要输入迭代器的算法将不会修改容器中的值。

基于输入迭代器的任何算法都应当是单通行 （single-pass）的，不依赖于前一次遍历时的迭代器值，也不依赖于本 次遍历中前面的迭代器值。 

注意，输入迭代器是单向迭代器，可以递增，但不能倒退。



2. 输出迭代器

对于单通行、只读算法，可以使用输入迭代器；而对于 单通行、只写算法，则可以使用输出迭代器。



3. 正向迭代器

将正向迭代 器递增后，仍然可以对前面的迭代器值解除引用（如果保存了它），并 可以得到相同的值。这些特征使得多次通行算法成为可能。



4. 双向迭代器

双向迭代器具 有正向迭代器的所有特性，同时支持两种（前缀和后缀）递减运算符。



5. 随机访问迭代器

有些算法（如标准排序和二分检索）要求能够直接跳到容器中的任 何一个元素，这叫做随机访问，需要随机访问迭代器。随机访问迭代器 具有双向迭代器的所有特性，同时添加了支持随机访问的操作（如指针 增加运算）和用于对元素进行排序的关系运算符。

下表X表示随机迭 代器类型，T表示被指向的类型，a和b都是迭代器值，n为整数，r为随 机迭代器变量或引用。

<center>
    表16.3 随机访问迭代器操作
</center>

| 表达式 | 描述                               |
| ------ | ---------------------------------- |
| a + n  | 指向 a 所指向的元素后的第 n 个元素 |
| n + a  | 与 a + n  相同                     |
| a - n  | 指向 a 所指向的元素前的第 n 个元素 |
| r += n | 等价于 r = r + n                   |
| r -= n | 等价于 r = r - n                   |
| a[n]   | 等价于 *(a + n)                    |
| b - a  | 结果为这样的 n 值，即 b = a + n    |
| a < b  | 如果 b - a > 0 ，则为真            |
| a > b  | 如果 b < a ，则为真                |
| a >= b | 如果 !(a < b) ，则为真             |
| a <= b | 如果 !(a > b) ，则为真             |

像a+n这样的表达式仅当a和a+n都位于容器区间（包括超尾）内时 才合法。



### 16.4.3 迭代器层次结构



### 16.4.4 概念、改进和模型

1. 将指针用作迭代器

```c++
int casts[10] = {6, 7, 2, 9, 4, 11, 8, 7, 10, 5};
vector<int> dice(10);
copy(casts, casts + 10, dice.begin());
```

copy( )的前两个迭代器参数表示要复制的范围，最后一个迭代器参 数表示要将第一个元素复制到什么位置。前两个参数必须是（或最好 是）输入迭代器，最后一个参数必须是（或最好是）输出迭代器。 Copy( )函数将覆盖目标容器中已有的数据，同时目标容器必须足够大， 以便能够容纳被复制的元素。



2. 其他有用的迭代器

> **注意**
>
> rbegin( )和end( )返回相同的值（超尾），但类型不同（reverse_iterator和iterator）。同样， rend( )和begin( )也返回相同的值（指向第一个元素的迭代器），但类型不同。



> **提示：**
>
> 可以用insert_iterator将复制数据的算法转换为插入数据的算法。



### 16.4.5 容器种类

STL 具有容器概念和容器类型。



1. 容器概念

没有与基本容器概念对应的类型，但概念描述了所有容器类都通用 的元素。它是一个概念化的抽象基类——说它概念化，是因为容器类并 不真正使用继承机制。

下表 X 表示容器类型，如vector；T表示存储在容器中的对象类型；a和b表示类 型为X的值；r表示类型为X&的值；u表示类型为X的标识符（即如果X 表示vector，则u是一个vector对象）。

<center>
    表16.5 一些基本的容器特征
</center>

| 表达式        | 返回类型          | 说明                                                         | 复杂度   |
| ------------- | ----------------- | ------------------------------------------------------------ | -------- |
| X::iterator   | 指向T的迭代器类型 | 满足正向迭代器要求的任何迭代器                               | 编译时间 |
| X::value_type | T                 | T的类型                                                      | 编译时间 |
| X u;          |                   | 创建一个名为 u 的空容器                                      | 固定     |
| X();          |                   | 创建一个匿名的空容器                                         | 固定     |
| X u(a);       |                   | 调用复制构造函数后 u == a                                    | 线性     |
| X u = a;      |                   | 作用同 X u(a);                                               | 线性     |
| r = a;        | X&                | 调用赋值运算符后 r == a                                      | 线性     |
| (&a)->~X()    | void              | 对容器中每个元素应用析构函数                                 | 线性     |
| a.begin()     | 迭代器            | 返回指向容器第一个元素的迭代器                               | 固定     |
| a.end()       | 迭代器            | 返回超尾值迭代器                                             | 固定     |
| a.size()      | 无符号整型        | 返回元素个数，等价于 a.end() - a.begin()                     | 固定     |
| a.swap(b)     | void              | 交换 a 和 b 的内容                                           | 固定     |
| a == b        | 可转换为 bool     | 如果 a 和 b 的长度相同，且 a 中每个元素都等于（== 为真）b 中相应的元素，则为真 | 线性     |
| a != b        | 可转换为 bool     | 返回 !(a == b)                                               | 线性     |
|               |                   |                                                              |          |

上表中的 “复杂度” 描述了执行操作所需的时间，从快到慢依次是

- 编译时间
- 固定时间
- 线性时间



如果复杂度为编译时间，则操作将在编译时执行，执行时间为0。 固定复杂度意味着操作发生在运行阶段，但独立于对象中的元素数目。 线性复杂度意味着时间与元素数目成正比。即如果a和b都是容器，则a = = b具有线性复杂度，因为= =操作必须用于容器中的每个元素。实际上，这是最糟糕的情况。如果两个容器的长度不同，则不需要作任何的 单独比较。



2. C++11新增的容器要求

rv表示类 型为X的非常量右值，如函数的返回值。

<center>
    表16.6 C++11新增的基本容器要求
</center>

| 表达式     | 返回类型       | 说明                                           | 复杂度   |
| ---------- | -------------- | ---------------------------------------------- | -------- |
| X u(rv);   |                | 调用移动构造函数后，u 的值与 rv 的原始值相同   | 编译时间 |
| X u = rv;  |                | 作用同 X u(rv);                                |          |
| a = rv;    | X&             | 调用移动赋值运算符后，u 的值与 rv 的原始值相同 | 线性     |
| a.cbegin() | const_iterator | 返回指向容器第一个元素的 const 迭代器          | 固定     |
| a.cend()   | const_iterator | 返回超尾值 const 迭代器                        | 固定     |

复制构造和复制赋值以及移动构造和移动赋值之间的差别在于，复 制操作保留源对象，而移动操作可修改源对象，还可能转让所有权，而 不做任何复制。如果源对象是临时的，移动操作的效率将高于常规复 制。



3. 序列

（1）vector

提供了自动内存管 理功能，可以动态地改变vector对象的长度，并随着元素的添加和删除 而增大和缩小。它提供了对元素的随机访问。在尾部添加和删除元素的 时间是固定的，但在头部或中间插入和删除元素的复杂度为线性时间。

vector模板类是最简单的序列类型，除非其他类型的特殊优点能够 更好地满足程序的要求，否则应默认使用这种类型。



（2）deque

双端队列。

在STL中，其实现类似于vector容 器，支持随机访问。主要区别在于，从deque对象的开始位置插入和删 除元素的时间是固定的，而不像vector中那样是线性时间的。所以，如 果多数操作发生在序列的起始和结尾处，则应考虑使用deque数据结 构。



（3）list

与vector不同的是，list不支持 数组表示法和随机访问。与矢量迭代器不同，从容器中插入或删除元素 之后，链表迭代器指向元素将不变。我们来解释一下这句话。例如，假 设有一个指向vector容器第5个元素的迭代器，并在容器的起始处插入一 个元素。此时，必须移动其他所有元素，以便腾出位置，因此插入后， 第5个元素包含的值将是以前第4个元素的值。因此，迭代器指向的位置 不变，但数据不同。然后，在链表中插入新元素并不会移动已有的元 素，而只是修改链接信息。指向某个元素的迭代器仍然指向该元素，但 它链接的元素可能与以前不同。



（4）程序说明

参考代码 16.02 。



（5）list 工具箱

排序 sort 、合并 merge 、删除重复元素 unique ，等方法。



（6）forward_list （C++11）

单链表。



（7）queue

queue模板的限制比deque更多。它不仅不允许随机访问队列元素， 甚至不允许遍历队列。它把使用限制在定义队列的基本操作上，可以将 元素添加到队尾、从队首删除元素、查看队首和队尾的值、检查元素数 目和测试队列是否为空。

其他方法，可以参考网站，后者 C++ Primer ，都有更详细的说明。



（8）priority_queue

支持的操作与queue相同。两者之间的主要区别在于，在 priority_queue中，最大的元素被移到队首（生活不总是公平的，队列也 一样）。内部区别在于，默认的底层类是vector。可以修改用于确定哪 个元素放到队首的比较方式，方法是提供一个可选的构造函数参数：

```c++
priority_queue<int> pq1;

// greater 是一个预定义的函数对象
priority_queue<int> pq2(greater<int>);
```



（9）stack

适配器类。



（10）array （C++11）

array没有定义调整容器大小的操 作，如push_back( )和insert( )，但定义了对它来说有意义的成员函数， 如operator [] ()和at( )。可将很多标准STL算法用于array对象，如copy( ) 和for_each( )。



### 16.4.6 关联容器

set 值类型与键相同，键是唯一的。multiset 基本与 set 相同，只是可能有多个值的键相同。

map ，值与键的类型不同，键是唯一的，每个键只对应一个值。multimap 一个键可以与多个值相关联。



1. set 示例

键是唯一的，不能存储多个相同的值。

数学为集合定义了一些标准操作，例如，并集包含两个集合合并后 的内容。如果两个集合包含相同的值，则这个值将在并集中只出现一 次，这是因为键是唯一的。交集包含两个集合都有的元素。两个集合的 差是第一个集合减去两个集合都有的元素。



2. multimap 示例

可反转、经过排序的关联容器，但同一个键可能与多个值相关联。

STL使用模板类pair将这两种值存储到一个 对象中。可以使用first和second成员来访问其两个部分。



### 16.4.7 无序关联容器（C++11）

无序 关联容器也将值与键关联起来，并使用键来查找值。但底层的差别在 于，关联容器是基于树结构的，而无序关联容器是基于数据结构哈希表 的，这旨在提高添加和删除元素的速度以及提高查找算法的效率。有4 种无序关联容器，它们是unordered_set、unordered_multiset、 unordered_map和unordered_multimap。



## 16.5 函数对象



### 16.5.1 函数符的概念

生成器（generator）是不用参数就可以调用的函数符。

一元函数（unary function）是用一个参数可以调用的函数符。

二元函数（binary function）是用两个参数可以调用的函数符。



返回bool值的一元函数是谓词（predicate）；

返回bool值的二元函数是二元谓词（binary predicate）。



list模板有一个将谓词作为参数的remove_if( )成员，该函数将谓词 应用于区间中的每个元素，如果谓词返回true，则删除这些元素。



### 16.5.2 预定义的函数符

函数transform( )。它有两个版本。第一个版本接 受4个参数，前两个参数是指定容器区间的迭代器（现在您应该已熟悉 了这种方法），第3个参数是指定将结果复制到哪里的迭代器，最后一 个参数是一个函数符，它被应用于区间中的每个元素，生成结果中的新 元素。



第2种版本使用一个接受两个参数的函数，并将该函数用于两个区 间中元素。它用另一个参数（即第3个）标识第二个区间的起始位置。



头文件 functional（以前为function.h）定义了多个模板类函数对象，其中包括 plus< >( )。 

可以用plus< >类来完成常规的相加运算。



<center>
    表16.12 运算符和相应的函数符
</center>

| 运算符 | 相应的函数符  |
| :----: | :-----------: |
|   +    |     plus      |
|   -    |     minus     |
|   *    |  multiplies   |
|   /    |    divides    |
|   %    |    modulus    |
|   -    |    negate     |
|   ==   |   equal_to    |
|   !=   | not_equal_to  |
|   >    |    greater    |
|   <    |     less      |
|   >=   | greater_equal |
|   <=   |  less_equal   |
|   &&   |  logical_and  |
|  \|\|  |  logical_or   |
|   !    |  logical_not  |



> **警告**
>
> 老式 C++ 实现使用函数符名 times ，而不是 multiplies 。



### 16.5.3 自适应函数符和函数适配器

自适应生成器（adaptable generator）、自适应一元函数 （adaptable unary function）、自适应二元函数（adaptable binary function）、自适应谓词（adaptable predicate）和自适应二元谓词 （adaptable binary predicate）



## 16.6 算法

对于算法函数设计，有两个主要的通用部分。首先，它们都使用模 板来提供泛型；其次，它们都使用迭代器来提供访问容器中数据的通用 表示。因此，copy( )函数可用于将double值存储在数组中的容器、将 string值存储在链表中的容器，也可用于将用户定义的对象存储在树结 构中（如set所使用的）的容器。因为指针是一种特殊的迭代器，因此诸 如copy( )等STL函数可用于常规数组。



### 16.6.1 算法组

STL将算法库分成4组：

- 非修改式序列操作；
- 修改式序列操作；
- 排序和相关操作；
- 通用数字运算。

非修改式序列操作对区间中的每个元素进行操作。这些操作不修改 容器的内容。例如，find( )和for_each( )就属于这一类。

修改式序列操作也对区间中的每个元素进行操作。然而，顾名思 义，它们可以修改容器的内容。可以修改值，也可以修改值的排列顺 序。transform( )、random_shuffle( )和copy( )属于这一类。

排序和相关操作包括多个排序函数（包括sort( )）和其他各种函 数，包括集合操作。

数字操作包括将区间的内容累积、计算两个容器的内部乘积、计算 小计、计算相邻对象差的函数。通常，这些都是数组的操作特性，因此 vector是最有可能使用这些操作的容器。



### 16.6.2 算法的通用特征



### 16.6.3 STL和string类

next_permutation( )算法将区间内容转换为下一种排列方式。对于字符 串，排列按照字母递增的顺序进行。如果成功，该算法返回true；如果 区间已经处于最后的序列中，则该算法返回false。

算法next_permutation( )自动提供唯一的排列组合，这就是输 出中“awl”一词的排列组合比“all”（它有重复的字母）的排列组合要多 的原因。



### 16.6.4 函数和容器方法

有时可以选择使用STL方法或STL函数。通常方法是更好的选择。 首先，它更适合于特定的容器；其次，作为成员函数，它可以使用模板 类的内存管理工具，从而在需要时调整容器的长度。



尽管方法通常更适合，但非方法函数更通用。正如您看到的，可以 将它们用于数组、string对象、STL容器，还可以用它们来处理混合的容 器类型，例如，将矢量容器中的数据存储到链表或集合中。



### 16.6.5 使用STL

这里的寓意在于，使用STL时应尽可能减少要编写的代码。STL通 用、灵活的设计将节省大量工作。另外，STL设计者就是非常关心效率 的算法人员，算法是经过仔细选择的，并且是内联的。



## 16.7 其他库

### 16.7.1 vector、valarray和array

参考代码 16.20 / 16.21 。



### 16.7.2 模板initializer_list（C++11）

C++11 新增支持初始化列表语法将容器初始化为一系列值。



所有 initializer_list 元素的类型都必须相同。

编译器可以进行必要的转换，如vector的元素类型为double，因此列表的类型为 initializer_list，所以19和89被转换为double。但不能进行隐式的 **窄化** 转换。



### 16.7.3 使用 initializer_list

参考代码 16.22 ，注意编译时需要显式指定 --std=c++11 或以上版本。



## 16.8 总结

有些算法被表示为容器类方法，但大量算法都被表示为通用的、非 成员函数，这是通过将迭代器作为容器和算法之间的接口得以实现的。 这种方法的一个优点是：只需一个诸如for_each( )或copy( )这样的函 数，而不必为每种容器提供一个版本；另一个优点是：STL算法可用于 非STL容器，如常规数组、string对象、array对象以及您设计的秉承STL 迭代器和容器规则的任何类。



# 17 输入、输出和文件

## 17.1 C++输入和输出概述

### 17.1.1 流和缓冲区

C++程序把输入和输出看作字节流。输入时，程序从输入流中抽取 字节；输出时，程序将字节插入到输出流中。对于面向文本的程序，每 个字节代表一个字符，更通俗地说，字节可以构成字符或数值数据的二 进制表示。输入流中的字节可能来自键盘，也可能来自存储设备（如硬 盘）或其他程序。同样，输出流中的字节可以流向屏幕、打印机、存储 设备或其他程序。



此管理输入包含两步：

- 将流与输入去向的程序关联起来。
- 将流与文件连接起来。



### 17.1.2 流、缓冲区和iostream文件



- streambuf类为缓冲区提供了内存，并提供了用于填充缓冲区、访问缓冲区内容、刷新缓冲区和管理缓冲区内存的类方法；
- ios_base类表示流的一般特征，如是否可读取、是二进制流还是文 本流等；
- ios类基于ios_base，其中包括了一个指向streambuf对象的指针成 员；
- ostream类是从ios类派生而来的，提供了输出方法；
- istream类也是从ios类派生而来的，提供了输入方法；
- iostream类是基于istream和ostream类的，因此继承了输入方法和输 出方法。



C++的iostream类库管理了很多细节。例如，在程序中包含iostream 文件将自动创建8个流对象（4个用于窄字符流，4个用于宽字符流）。

- cin对象对应于标准输入流。在默认情况下，这个流被关联到标准 输入设备（通常为键盘）。wcin对象与此类似，但处理的是wchar_t 类型。
- cout对象与标准输出流相对应。在默认情况下，这个流被关联到标 准输出设备（通常为显示器）。wcout对象与此类似，但处理的是 wchar_t类型。
- cerr对象与标准错误流相对应，可用于显示错误消息。在默认情况 下，这个流被关联到标准输出设备（通常为显示器）。这个流没有 被缓冲，这意味着信息将被直接发送给屏幕，而不会等到缓冲区填 满或新的换行符。wcerr对象与此类似，但处理的是wchar_t类型。
- clog对象也对应着标准错误流。在默认情况下，这个流被关联到标 准输出设备（通常为显示器）。这个流被缓冲。wclog对象与此类 似，但处理的是wchar_t类型。
- 对象代表流——这意味着什么呢？当iostream文件为程序声明一个 cout对象时，该对象将包含存储了与输出有关的信息的数据成员， 如显示数据时使用的字段宽度、小数位数、显示整数时采用的计数 方法以及描述用来处理输出流的缓冲区的streambuf对象的地址。下 面的语句通过指向的streambuf对象将字符串“Bjarna free”中的字符 放到cout管理的缓冲区中。



### 17.1.3 重定向

标准输入和输出流通常连接着键盘和屏幕。但很多操作系统（包括 UNIX、Linux和Windows）都支持重定向，这个工具使得能够改变标准 输入和标准输出。



有些操作系统也允许对标准错误进行重定向。例如，在 UNIX和Linux中，运算符2>重定向标准错误。



## 17.2 使用cout进行输出

C++将输出看作字节流（根据实现和平台的不 同，可能是8位、16位或32位的字节，但都是字节），但在程序中，很 多数据被组织成比字节更大的单位。

### 17.2.1 重载的<<运算符











