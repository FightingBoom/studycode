## 13.8 类设计回顾

### 13.8.1 编译器生成的成员函数

如果定义了某种构造函数，则编译器将不会定义默认构造函数。如果有需要，则必须自己提供。

提供构造函数的动机之一是确保对象总能被正确地初始化。如果类包含指针成员，则必须初始化这些成员。因此，最好提供一个显式默认构造函数，将所有的类数据成员都初始化为合理的值。

------

复制构造函数接受其所属类的对象作为参数。

Star(const Star &);

在下述情况下，将使用复制构造函数：

- 将新对象初始化为一个同类对象；
- 按值将对象传递给函数；
- 函数按值返回对象；
- 编译器生成临时对象；

------

默认的赋值运算符用于处理同类对象之间的赋值。

PS：不要将赋值与初始化混淆了。如果语句创建新的对象，则使用初始化；如果语句修改已有对象的值，则是赋值；

默认赋值为成员赋值。

### 13.8.2 其他的类方法

1. 构造函数

构造函数不同于其他类方法，因为它创建新的对象，而其他类方法只是被现有的对象调用。这是构造函数不被继承的原因之一。

继承意味着派生类对象可以使用基类的方法，但构造函数在完成其工作之前，对象并不存在。

------

2. 析构函数

一定要定义显式析构函数来释放类构造函数使用 new 分配的所有内存，并完成类对象所需的任何特殊的清理工作。

对于基类，即使它不需要析构函数，也应提供一个虚析构函数。

------

3. 转换

在带一个参数的构造函数原型中使用 explicit 将禁止进行隐式转换，但仍允许显式转换：

```c++
class star
{
...
public:
    explicit Star(const char *);
...
};

...

Star north;
north = "polaris";        // not allowed
north = Star("polaris");  // allowed
```



另外，对于某些类，包含转换函数将增加代码的二义性。



C++11 支持将关键字 explicit 用于转换函数。与构造函数一样，explicit 允许使用强制类型转换进行显式转换，但不允许隐式转换。

---

4. 按值传递对象与传递引用

通常，编写使用对象作为参数的函数时，应按引用而不是按值来传递对象。

原因之一是为了提高效率。按值传递对象涉及到生成临时拷贝，即调用复制构造函数，然后调用析构函数。调用这些函数需要时间，复制大型对象比传递引用花费的时间要多得多。如果函数不修改对象，应将参数声明为 const 引用。

按引用传递对象的另外一个原因是，在继承使用虚函数时，被定义为接受基类引用参数的函数可以接受派生类。

---

5. 返回对象和返回引用

有些类方法返回对象。有些成员函数直接返回对象，另一些返回引用。有时方法必须返回对象，但如果可以不返回对象，则应返回引用。

```c++
// 返回对象
Star nova1(const Star &);

// 返回引用
Star & nova2(const Star &);
```

返回对象涉及生成调用函数的程序，可以使用的临时副本。因此，返回对象的时间成本包括调用复制构造函数来生成副本所需的时间和调用析构函数删除副本所需的时间。

返回引用可以节省时间和内存。

直接返回对象与按值传递对象相似：都生成临时副本。

返回引用与按引用传递对象相似：调用和被调用的函数对同一个对象进行操作。



函数不能返回在函数中创建的临时对象的引用，因为当函数结束时，临时对象将消失，因此这种引用将是非法的。在这种情况下，应返回对象，以生成一个调用程序可以使用的副本。

---

6. 使用 const

使用 const 可以确保方法不修改参数；可以确保方法不修改调用它的对象；

可以使用 const 来确保引用或指针返回的值不能用于修改对象中的数据：
```c++
const Stock & Stock::topval(const Stock & s) const
{
	if (s.total_val > total_val)
        return s;
    else
        return *this;
}
```

该方法返回对 this 或 s 的引用，且因为 this 与 s 都被声明为 const ，所以函数不能对它们进行修改，同时意味着返回的引用也必须被声明为 const 。

如果函数将参数声明为指向 const 的引用或指针，则不能将该参数传递给另一个函数，除非后者也确保了参数不会被修改。











