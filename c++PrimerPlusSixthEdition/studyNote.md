### 13.4.3 有关虚函数注意事项

构造函数不能是虚函数。

析构函数应当是虚函数，除非类不用做基类。

派生类中存在 new 等内存，需要在派生类销毁时，回收对应内存，因此析构函数应当是虚函数，这样派生类可以有自己的实现。

当 delete 派生类的内存时，会先调用派生类的析构函数，再调用基类的析构函数。

通常应该给类定义一个虚析构函数，即使他并不需要析构函数。

友元不能是虚函数，因为友元不是类成员，只有成员才能是虚函数。如果有设计问题，可以让友元函数使用虚成员函数来解决。



5. 重新定义将隐藏方法

基类有一个虚函数，派生类重新实现，但参数不同，此时会隐藏基类的同名函数

```c++
class Dwelling
{
public:
    virtual void showperks(int a) const;
...
};


class Hovel : public Dwelling
{
public:
    virtual void showperks() const;
...
}
```

重新定义不会生成函数的两个重载版本，而是隐藏了接受一个 int 参数的基类版本。

总之，重新定义继承的方法并不是重载。如果重新定义派生类中的函数，将不只是使用相同的函数参数列表覆盖基类声明，无论参数列表是否相同，该操作将隐藏所有的同名基类方法。



此引出来两条规则

第一，如果重新定义继承的方法，应确保与原来的原型完全相同，但如果返回类型是基类引用或指针，则可以修改为指向派生类的引用或指针。这种特性被称为返回类型协变，因为允许返回类型随类类型的变化而变化。

需要注意，这种例外只适用于返回值，而不适用于参数。

```c++
class Dwelling
{
public:
    virtual Dwelling & build(int n);
...
};


class Hovel : public Dwelling
{
public:
    virtual Hovel & build(int n); // 同名虚函数，只是返回值类型不同
...
}
```

第二，如果基类声明被重载了，则应在派生类中重新定义所有的基类版本。

```c++
class Dwelling
{
public:
    virtual void showperks(int a) const;
    virtual void showperks(double x) const;
    virtual void showperks() const;
...
};


class Hovel : public Dwelling
{
public:
    virtual void showperks(int a) const;
    virtual void showperks(double x) const;
    virtual void showperks() const;
...
}
```

如果只重新定义一个版本，则另外两个版本将被隐藏，派生类对象将无法使用它们。如果不需要修改，新定义可以只调用基类版本。

```c++
void Hovel::showperks() const {Dwelling::showperks();}
```





## 13.5 访问控制：protected

protected 与 private ，在 类外 只能用公有类成员来访问。

派生类的成员，可以直接访问基类的保护成员，但不能直接访问基类的私有成员。

| 基类关键字类型 | 派生类访问权限 | 外部类访问权限 |
| :------------: | :------------: | :------------: |
|    private     |    无法访问    |    无法访问    |
|    protect     |    可以访问    |    无法访问    |
|     public     |    可以访问    |    可以访问    |
|                |                |                |

注意：最好对类数据成员采用私有访问控制，不要使用保护访问控制；同时通过基类方法使派生类能够访问基类数据；

另外对于成员函数来说，保护访问控制很有用，它让派生类能够访问公众不能使用的内部函数。



## 13.6 抽象基类

ABC：abstract base class

真正的 ABC ，必须至少包含一个纯虚函数。

当类声明中包含纯虚函数时，则不能创建该类的对象。

理念：包含纯虚函数的类只用作基类。



## 13.7 继承和动态内存分配

### 13.7.1 第一种情况：派生类不使用 new

可以不需要为派生类定义显式析构函数、复制构造函数和赋值运算符。



### 13.7.2 第二种情况：派生类使用 new

如果派生类有使用 new ，则必须为派生类定义显式析构函数、复制构造函数和赋值运算符。

派生类析构函数自动调用基类的析构函数，故其自身的职责是对派生类构造函数执行工作的进行清理。因此，hasDMA （派生类）的析构函数必须释放指针 style 管理的内存，并依赖于 baseDMA （基类）的析构函数来释放指针 label 管理的内存。

hasDMA （派生类）复制构造函数只能访问 hasDMA 的数据，因此必须调用 baseDMA 复制构造函数来处理共享的 baseDMA 数据。

当基类和派生类都采用动态内存分配时，派生类的析构函数、复制构造函数、赋值运算符都必须使用相应的积累方法来处理基类元素。

这种要求是通过三种不同的方式来满足的。

对于析构函数，这是自动完成的；

对于构造函数，这是通过在初始化成员类表中调用基类的复制构造函数来完成的；如果不这样做，将自动调用基类的默认构造函数。

对于复制运算符，这是通过使用作用域解析运算符显式地调用基类的复制运算符来完成的。



## 13.8 类设计回顾

### 13.8.1 编译器生成的成员函数

如果定义了某种构造函数，则编译器将不会定义默认构造函数。如果有需要，则必须自己提供。

提供构造函数的动机之一是确保对象总能被正确地初始化。如果类包含指针成员，则必须初始化这些成员。因此，最好提供一个显式默认构造函数，将所有的类数据成员都初始化为合理的值。

------

复制构造函数接受其所属类的对象作为参数。

Star(const Star &);

在下述情况下，将使用复制构造函数：

- 将新对象初始化为一个同类对象；
- 按值将对象传递给函数；
- 函数按值返回对象；
- 编译器生成临时对象；

------

默认的赋值运算符用于处理同类对象之间的赋值。

PS：不要将赋值与初始化混淆了。如果语句创建新的对象，则使用初始化；如果语句修改已有对象的值，则是赋值；

默认赋值为成员赋值。



### 13.8.2 其他的类方法

1. 构造函数

构造函数不同于其他类方法，因为它创建新的对象，而其他类方法只是被现有的对象调用。这是构造函数不被继承的原因之一。

继承意味着派生类对象可以使用基类的方法，但构造函数在完成其工作之前，对象并不存在。

------

2. 析构函数

一定要定义显式析构函数来释放类构造函数使用 new 分配的所有内存，并完成类对象所需的任何特殊的清理工作。

对于基类，即使它不需要析构函数，也应提供一个虚析构函数。

------

3. 转换

在带一个参数的构造函数原型中使用 explicit 将禁止进行隐式转换，但仍允许显式转换：

```c++
class star
{
...
public:
    explicit Star(const char *);
...
};

...

Star north;
north = "polaris";        // not allowed
north = Star("polaris");  // allowed
```



另外，对于某些类，包含转换函数将增加代码的二义性。



C++11 支持将关键字 explicit 用于转换函数。与构造函数一样，explicit 允许使用强制类型转换进行显式转换，但不允许隐式转换。

---

4. 按值传递对象与传递引用

通常，编写使用对象作为参数的函数时，应按引用而不是按值来传递对象。

原因之一是为了提高效率。按值传递对象涉及到生成临时拷贝，即调用复制构造函数，然后调用析构函数。调用这些函数需要时间，复制大型对象比传递引用花费的时间要多得多。如果函数不修改对象，应将参数声明为 const 引用。

按引用传递对象的另外一个原因是，在继承使用虚函数时，被定义为接受基类引用参数的函数可以接受派生类。

---

5. 返回对象和返回引用

有些类方法返回对象。有些成员函数直接返回对象，另一些返回引用。有时方法必须返回对象，但如果可以不返回对象，则应返回引用。

```c++
// 返回对象
Star nova1(const Star &);

// 返回引用
Star & nova2(const Star &);
```

返回对象涉及生成调用函数的程序，可以使用的临时副本。因此，返回对象的时间成本包括调用复制构造函数来生成副本所需的时间和调用析构函数删除副本所需的时间。

返回引用可以节省时间和内存。

直接返回对象与按值传递对象相似：都生成临时副本。

返回引用与按引用传递对象相似：调用和被调用的函数对同一个对象进行操作。



函数不能返回在函数中创建的临时对象的引用，因为当函数结束时，临时对象将消失，因此这种引用将是非法的。在这种情况下，应返回对象，以生成一个调用程序可以使用的副本。

---

6. 使用 const

使用 const 可以确保方法不修改参数；可以确保方法不修改调用它的对象；

可以使用 const 来确保引用或指针返回的值不能用于修改对象中的数据：
```c++
const Stock & Stock::topval(const Stock & s) const
{
	if (s.total_val > total_val)
        return s;
    else
        return *this;
}
```

该方法返回对 this 或 s 的引用，且因为 this 与 s 都被声明为 const ，所以函数不能对它们进行修改，同时意味着返回的引用也必须被声明为 const 。

如果函数将参数声明为指向 const 的引用或指针，则不能将该参数传递给另一个函数，除非后者也确保了参数不会被修改。



### 13.8.3 公有继承的考虑因素

1. is-a 关系

要遵循 is-a 关系。如果派生类不是一种特殊的基类，则不要使用公有派生。

在某些情况下，最好的方法可能是创建包含纯虚函数的抽象数据类，并从它派生出其他的类。

表示 is-a 关系的方式之一：

- 无需进行显式类型转换，基类指针就可以指向派生类对象，基类引用可以引用派生类对象。
- 反过来行不通，即不能在不进行显式类型转换的情况下，将派生类指针或引用指向基类对象。不安全。

---

2. 什么不能被继承

构造函数是不能继承的。

析构函数也是不能继承的。在释放对象时，程序将首先调用派生类的析构函数，然后调用基类的析构函数。通常对于基类，析构函数应该设置为虚函数。

赋值运算符是不能继承的。派生类继承的方法的特征标与基类完全相同，但赋值运算符的特征标随类而异，因为它包含一个类型为其所属类的形参。

---

3. 赋值运算符

如果编译器发现程序将一个对象赋给同一个类的另一个对象，它将自动为这个类提供一个赋值运算符。

---

4. 私有成员与保护成员

对派生类而言，保护成员类似于公有成员；但对于外部而言，保护成员与私有成员类似。

讲基类成员设置为私有的可以提高安全性，而将它们设置为保护成员则可简化代码的编写工作，并提高访问速度。

Stroustrup：使用私有数据成员比使用保护数据成员更好，但保护方法很有用。



5. 虚方法

设计基类时，必须确定是否将类方法声明为虚的。

如果希望派生类能够重新定义方法，则应在基类中将方法定义为虚的，这样可以启用晚期联编（动态联编）；

如果不希望重新定义方法，则不必将其声明为虚的；



6. 析构函数

基类的析构函数应当是虚的。

这样，当通过指向对象的基类指针或引用来删除派生类对象时，程序将首先调用派生类的析构函数，然后调用基类的析构函数，而不仅仅是调用基类的析构函数。



7. 友元函数

由于友元函数并非类成员，因此不能继承。

然而，可以通过强制类型转换，将派生类引用或指针转换为基类引用或指针，然后使用转换后的指针或引用来调用基类的友元函数。



8. 有关使用基类方法的说明

以公有方式派生的类的对象可以通过多种方式来使用基类的方法。

- 派生类对象自动使用继承而来的基类方法，如果派生类没有重新定义该方法。
- 派生类的构造函数自动调用基类的构造函数。
- 派生类的构造函数自动调用基类的默认构造函数，如果没有在成员初始化列表中指定其他构造函数。
- 派生类构造函数显式地调用成员初始化列表中指定的基类构造函数。
- 派生类方法可以使用作用域解析运算符来调用公有的和受保护的基类方法。
- 派生类的友元函数可以通过强制类型转换，将派生类引用或指针转换为基类引用或指针，然后使用该引用或指针来调用基类的友元函数。

PS：今天，2024年01月26日，农历腊月十六，是我的生日，哈哈哈哈，太开心啦



### 13.8.4 类函数小节

C++类函数有很多不同的变体，其中有些可以继承，有些不可以。

参考下表，其中 op= 表示诸如 += 、*= 等格式的赋值运算符。


|    函数    | 能否继承 | 成员还是友元 | 默认能否生成 | 能否为虚函数 | 是否可以有返回类型 |
| :--------: | :------: | :----------: | :----------: | :----------: | :----------------: |
|  构造函数  |    否    |     成员     |      能      |      否      |         否         |
|  析构函数  |    否    |     成员     |      能      |      能      |         否         |
|     =      |    否    |     成员     |      能      |      能      |         能         |
|     &      |    能    |     任意     |      能      |      能      |         能         |
|  转换函数  |    能    |     成员     |      否      |      能      |         否         |
|     ()     |    能    |     成员     |      否      |      能      |         能         |
|     []     |    能    |     成员     |      否      |      能      |         能         |
|     ->     |    能    |     成员     |      否      |      能      |         能         |
|    op=     |    能    |     任意     |      否      |      能      |         能         |
|    new     |    能    |   静态成员   |      否      |      否      |       void*        |
|   delete   |    能    |   静态成员   |      否      |      否      |        void        |
| 其他运算符 |    能    |     任意     |      否      |      能      |         能         |
|  其他成员  |    能    |     成员     |      否      |      能      |         能         |
|    友元    |    否    |     友元     |      否      |      否      |         能         |



# 14 C++ 中的代码重用

## 14.1 包含对象成员的类

### 14.1.1 valarray 类简介

valarray 类，包含在头文件 <valarray> 中，参考链接：[valarray](https://zh.cppreference.com/w/cpp/numeric/valarray)

支持将数组中所有元素的值相加以及在数组中找出最大和最小的值等操作。

valarray 是一个模板类，便于处理不同的数据类型。在声明对象时，必须指定具体的数据类型。

```c++
// int数组
valarray<int> q_values;

// double数组
valarray<double> weights;
```

构造函数使用方法举例

```c++
double gpa[5] = {3.1, 3.5, 3.8, 2.9, 3.3};

// 一个空的double类型数组
valarray<double> v1;

// 拥有8个元素的int类型数组
valarray<int> v2(8);

// 拥有8个元素的int类型数组，均被初始化为10
valarray<int> v3(10, 8);

// 拥有4个元素的double类型数组，被初始化为gpa数组前四个元素值
valarray<double> v4(gpa, 4);

// C++11可以使用初始化列表
valarray<int> v5 = {20, 32, 17, 9};
```

类方法举例

- `operator[]()`：可以直接访问各个元素；
- `size()`：返回包含的元素数；
- `sum()`：返回所有元素的总和；
- `max()`：返回最大的元素；
- `min()`：返回最小的元素；











