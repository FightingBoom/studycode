# 未归类

1、signed 、unsigned 单独使用时，默认为 int 类型；

```c++
signed = signed int
unsigned = unsigned int
```



## 名词缩写

多重继承（multiple inheritance，MI）



### 10.3.5 构造函数

如果可以通过初始化，也可以通过赋值来设置对象的值，则应采用初始化的方式，通常这种方式的效率更高；

可以将列表初始化语法，用于类；只需要提供与某个构造函数的参数列表匹配的内容，并用大括号将他们括起；【C++11及以上支持】

可以通过将函数参数声明为 const 引用或指向 const 的指针，保证函数不会修改调用对象

```c++
// 函数声明
void show() const;
// 函数定义
void stock::show() const;
```

以这种方式声明和定义的类函数被称为 const 成员函数。应尽可能将 const 引用和指针用作函数形参，只要类方法不修改调用对象，就应将其声明为 const 。



### 10.3.6 构造函数和析构函数小结

如果构造函数使用了 new ，则必须提供使用 delete 的析构函数；



## 10.4 this 指针

一般来说，所有的类方法都将 this 指针设置为调用它的对象的地址。

*this，将解除引用运算符 * 用于指针，将得到指针指向的值。



## 10.8 总结

由于 this 指针被设置为调用对象的地址，因此 *this 是该对象的别名；



# 11 使用类

## 11.2 计算时间：一个运算符重载示例

将参数声明为引用的目的是为了提高效率。

个人理解：如果不需要修改值，请加上 const 限定符；

不要返回指向局部变量或临时对象的引用。函数执行完毕后，局部变量和临时对象将消失，引用将指向不存在的数据。



### 11.2.1 添加加法运算符

编译器将根据操作数的类型来确定做

```c++
int a, b, c;
Time A, B, C;
c = a + b;
C = A + B;
```

同时可以将两个以上的对象相加

```c++
t4 = t1 + t2 + t3;

t4 = t1.operator+(t2 + t3);

t4 = t1.operator+(t2.operator + (t3));
```



### 11.2.2 重载限制

C++ 对用户定义的运算符重载的限制，2023/03/26 17:22

1、重载后的运算符必须至少有一个操作数是用户定义的类型，这将防止用户为标准类型重载运算符；

2、使用运算符时， 不能违反运算符原来的句法规则。同样，不能修改运算符的优先级。

3、不能创建新运算符。

4、不能重载下面的运算符

- **sizeof** ：sizeof 运算符。
- **.** ：成员运算符。
- **. \*** ：成员指针运算符。
- **::** ：作用域解析运算符。
- **?;** ：条件运算符。
- **typeid** ：一个 RTTI 运算符。
- **const_cast** ：强制类型转换运算符。
- **dynamic_cast** ：强制类型转换运算符。
- **reinterpret_cast** ：强制类型转换运算符。
- **static_cast** ：强制类型转换运算符。

5、如下运算符只能通过成员函数进行重载

- **=** ：复制运算符。
- **()** ：函数调用运算符。
- **[]** ：下标运算符。
- **->** ：通过指针访问类成员的运算符。



## 11.3 友元

类的友元函数是非成员函数，其访问权限与成员函数相同。

应将友元函数看作类的扩展接口的组成部分。

只有类声明可以决定哪一个函数是友元，因此类声明仍然控制了哪些函数可以访问私有数据。

总之，类方法和友元只是表达类接口的两种不同机制。



### 11.3.1 创建友元

如果要为类重载运算符，并将非类的项作为其第一个操作数，则可以用友元函数来反转操作数的顺序。



### 11.3.2 常用的友元：重载<<运算符

<< 运算符是 C 和 C++ 的位运算符，将值中的位左移。2023/03/27 22:57

cout 是一个 ostream 对象，可以识别所有的 C++ 基本类型。因为对于每种基本类型，ostream 类声明中都包含了相应的重载的 operator<<() 定义。

按引用传递使用的内存和时间都比按值传递少。

```c++
int x = 5;
int y = 8;

cout << x << y;
// 上下两条语句等价
(cout << x) << y;
```

<< 运算符左边是一个 ostream 对象。

ostream 类将 operator <<() 函数实现为返回一个指向 ostream 对象的引用。具体地说，他返回一个指向调用对象（这里是 cout ）的引用。因此，表达式 (cout << x) 本身就是 ostream 对象 cout，从而可以位于 << 运算符的左侧。





## 13.3 多态公有继承

1、希望同一个方法在派生类和基类中的行为是不同的。方法的行为应取决于调用该方法的对象。这种复杂的行为称为多态 —— 具有多种形态。

2、有两种重要的机制可用于实现多态公有继承：

- 在派生类中重新定义基类的方法；
- 使用虚方法（虚函数）；



如果方法是通过引用或指针而不是对象调用的，它将确定使用哪一种方法。

如果没有使用关键字 virtual ，程序将根据引用类型或指针类型选择方法；

如果使用了 virtual ，程序将根据引用或指针指向的对象的类型来选择方法；

```c++
// ViewAcct 不是虚函数
Brass dom("Dominic Banker", 11224, 4183.45);
BrassPlus dot("Dorothy Banker", 12118, 2592.00);
Brass & b1_ref = dom;
Brass & b2_ref = dot;
b1_ref.ViewAcct();    // use Brass::ViewAcct()
b2_ref.ViewAcct();    // use Brass::ViewAcct()
```



```c++
// ViewAcct 是虚函数
Brass dom("Dominic Banker", 11224, 4183.45);
BrassPlus dot("Dorothy Banker", 12118, 2592.00);
Brass & b1_ref = dom;
Brass & b2_ref = dot;
b1_ref.ViewAcct();    // use Brass::ViewAcct()
b2_ref.ViewAcct();    // use BrassPlus::ViewAcct()
```

方法在基类中被声明为虚的后，它在派生类中将自动成为虚方法。然而，在派生类中使用 virtual 指出哪些是虚函数也挺好。

如果要在派生类中重新定义基类的方法，通常应将基类方法声明为虚的。这样，程序将根据对象类型而不是引用或指针的类型来选择方法版本。为基类声明一个虚析构函数也是一种惯例。

关键字 virtual 只用于类声明的方法原型中，没有用于方法定义中。

在派生类方法中，标准技术是使用作用域解析运算符来调用基类方法。



## 13.4 静态联编和动态联编

### 13.4.1 指针和引用类型的兼容性

对于使用基类引用或指针作为参数的函数调用，将进行向上转换。如下代码，假定每个函数都调用虚方法 ViewAcct() ；

```c++
// 引用、指针，可以隐式向上转换
void fr(Brass & rb);   // uses rb.ViewAcct()
void fp(Brass * pb);   // uses pb->ViewAcct()
void fv(Brass b);      // uses b.ViewAcct()

int main()
{
    Brass b("Billy Bee", 123432, 10000.0);
    BrassPlus bp("Betty Beep", 232313, 12345.0);

    fr(b);    // uses Brass::ViewAcct()
    fr(bp);   // uses BrassPlus::ViewAcct()
    fp(b);    // uses Brass::ViewAcct()
    fp(bp);   // uses BrassPlus::ViewAcct()
    fv(b);    // uses Brass::ViewAcct()
    fv(bp);   // uses Brass::ViewAcct()
}
```



### 13.4.2 虚成员函数和动态联编

编译器对非虚方法，使用静态联编。

编译器对虚方法，使用动态联编。因为通常只有在运行程序时才能确定对象的类型。

C++的指导原则之一：不要为不使用的特性付出代价（内存或者处理时间）

使用虚函数时，在内存和执行速度方面有一定的成本，包括：

- 每个对象都将增大，增大量为存储地址的空间；
- 对于每个类，编译器都创建一个虚函数地址表（数组）；
- 对于每个函数调用，都需要执行一项额外的操作，即到表中查找地址。

虽然非虚函数的效率比虚函数稍高，但不具备动态联编功能。



### 13.4.3 有关虚函数注意事项

构造函数不能是虚函数。

析构函数应当是虚函数，除非类不用做基类。

派生类中存在 new 等内存，需要在派生类销毁时，回收对应内存，因此析构函数应当是虚函数，这样派生类可以有自己的实现。

当 delete 派生类的内存时，会先调用派生类的析构函数，再调用基类的析构函数。

通常应该给类定义一个虚析构函数，即使他并不需要析构函数。

友元不能是虚函数，因为友元不是类成员，只有成员才能是虚函数。如果有设计问题，可以让友元函数使用虚成员函数来解决。



5. 重新定义将隐藏方法

基类有一个虚函数，派生类重新实现，但参数不同，此时会隐藏基类的同名函数

```c++
class Dwelling
{
public:
    virtual void showperks(int a) const;
...
};


class Hovel : public Dwelling
{
public:
    virtual void showperks() const;
...
}
```

重新定义不会生成函数的两个重载版本，而是隐藏了接受一个 int 参数的基类版本。

总之，重新定义继承的方法并不是重载。如果重新定义派生类中的函数，将不只是使用相同的函数参数列表覆盖基类声明，无论参数列表是否相同，该操作将隐藏所有的同名基类方法。



此引出来两条规则

第一，如果重新定义继承的方法，应确保与原来的原型完全相同，但如果返回类型是基类引用或指针，则可以修改为指向派生类的引用或指针。这种特性被称为返回类型协变，因为允许返回类型随类类型的变化而变化。

需要注意，这种例外只适用于返回值，而不适用于参数。

```c++
class Dwelling
{
public:
    virtual Dwelling & build(int n);
...
};


class Hovel : public Dwelling
{
public:
    virtual Hovel & build(int n); // 同名虚函数，只是返回值类型不同
...
}
```

第二，如果基类声明被重载了，则应在派生类中重新定义所有的基类版本。

```c++
class Dwelling
{
public:
    virtual void showperks(int a) const;
    virtual void showperks(double x) const;
    virtual void showperks() const;
...
};


class Hovel : public Dwelling
{
public:
    virtual void showperks(int a) const;
    virtual void showperks(double x) const;
    virtual void showperks() const;
...
}
```

如果只重新定义一个版本，则另外两个版本将被隐藏，派生类对象将无法使用它们。如果不需要修改，新定义可以只调用基类版本。

```c++
void Hovel::showperks() const {Dwelling::showperks();}
```





## 13.5 访问控制：protected

protected 与 private ，在 类外 只能用公有类成员来访问。

派生类的成员，可以直接访问基类的保护成员，但不能直接访问基类的私有成员。

| 基类关键字类型 | 派生类访问权限 | 外部类访问权限 |
| :------------: | :------------: | :------------: |
|    private     |    无法访问    |    无法访问    |
|    protect     |    可以访问    |    无法访问    |
|     public     |    可以访问    |    可以访问    |
|                |                |                |

注意：最好对类数据成员采用私有访问控制，不要使用保护访问控制；同时通过基类方法使派生类能够访问基类数据；

另外对于成员函数来说，保护访问控制很有用，它让派生类能够访问公众不能使用的内部函数。



## 13.6 抽象基类

ABC：abstract base class

真正的 ABC ，必须至少包含一个纯虚函数。

当类声明中包含纯虚函数时，则不能创建该类的对象。

理念：包含纯虚函数的类只用作基类。



## 13.7 继承和动态内存分配

### 13.7.1 第一种情况：派生类不使用 new

可以不需要为派生类定义显式析构函数、复制构造函数和赋值运算符。



### 13.7.2 第二种情况：派生类使用 new

如果派生类有使用 new ，则必须为派生类定义显式析构函数、复制构造函数和赋值运算符。

派生类析构函数自动调用基类的析构函数，故其自身的职责是对派生类构造函数执行工作的进行清理。因此，hasDMA （派生类）的析构函数必须释放指针 style 管理的内存，并依赖于 baseDMA （基类）的析构函数来释放指针 label 管理的内存。

hasDMA （派生类）复制构造函数只能访问 hasDMA 的数据，因此必须调用 baseDMA 复制构造函数来处理共享的 baseDMA 数据。

当基类和派生类都采用动态内存分配时，派生类的析构函数、复制构造函数、赋值运算符都必须使用相应的积累方法来处理基类元素。

这种要求是通过三种不同的方式来满足的。

对于析构函数，这是自动完成的；

对于构造函数，这是通过在初始化成员类表中调用基类的复制构造函数来完成的；如果不这样做，将自动调用基类的默认构造函数。

对于复制运算符，这是通过使用作用域解析运算符显式地调用基类的复制运算符来完成的。



## 13.8 类设计回顾

### 13.8.1 编译器生成的成员函数

如果定义了某种构造函数，则编译器将不会定义默认构造函数。如果有需要，则必须自己提供。

提供构造函数的动机之一是确保对象总能被正确地初始化。如果类包含指针成员，则必须初始化这些成员。因此，最好提供一个显式默认构造函数，将所有的类数据成员都初始化为合理的值。



复制构造函数接受其所属类的对象作为参数。

Star(const Star &);

在下述情况下，将使用复制构造函数：

- 将新对象初始化为一个同类对象；
- 按值将对象传递给函数；
- 函数按值返回对象；
- 编译器生成临时对象；



默认的赋值运算符用于处理同类对象之间的赋值。

PS：不要将赋值与初始化混淆了。如果语句创建新的对象，则使用初始化；如果语句修改已有对象的值，则是赋值；

默认赋值为成员赋值。



### 13.8.2 其他的类方法

1. 构造函数

构造函数不同于其他类方法，因为它创建新的对象，而其他类方法只是被现有的对象调用。这是构造函数不被继承的原因之一。

继承意味着派生类对象可以使用基类的方法，但构造函数在完成其工作之前，对象并不存在。



2. 析构函数

一定要定义显式析构函数来释放类构造函数使用 new 分配的所有内存，并完成类对象所需的任何特殊的清理工作。

对于基类，即使它不需要析构函数，也应提供一个虚析构函数。



3. 转换

在带一个参数的构造函数原型中使用 explicit 将禁止进行隐式转换，但仍允许显式转换：

```c++
class star
{
...
public:
    explicit Star(const char *);
...
};

...

Star north;
north = "polaris";        // not allowed
north = Star("polaris");  // allowed
```



另外，对于某些类，包含转换函数将增加代码的二义性。

C++11 支持将关键字 explicit 用于转换函数。与构造函数一样，explicit 允许使用强制类型转换进行显式转换，但不允许隐式转换。



4. 按值传递对象与传递引用

通常，编写使用对象作为参数的函数时，应按引用而不是按值来传递对象。

原因之一是为了提高效率。按值传递对象涉及到生成临时拷贝，即调用复制构造函数，然后调用析构函数。调用这些函数需要时间，复制大型对象比传递引用花费的时间要多得多。如果函数不修改对象，应将参数声明为 const 引用。

按引用传递对象的另外一个原因是，在继承使用虚函数时，被定义为接受基类引用参数的函数可以接受派生类。



5. 返回对象和返回引用

有些类方法返回对象。有些成员函数直接返回对象，另一些返回引用。有时方法必须返回对象，但如果可以不返回对象，则应返回引用。

```c++
// 返回对象
Star nova1(const Star &);

// 返回引用
Star & nova2(const Star &);
```

返回对象涉及生成调用函数的程序，可以使用的临时副本。因此，返回对象的时间成本包括调用复制构造函数来生成副本所需的时间和调用析构函数删除副本所需的时间。

返回引用可以节省时间和内存。

直接返回对象与按值传递对象相似：都生成临时副本。

返回引用与按引用传递对象相似：调用和被调用的函数对同一个对象进行操作。



函数不能返回在函数中创建的临时对象的引用，因为当函数结束时，临时对象将消失，因此这种引用将是非法的。在这种情况下，应返回对象，以生成一个调用程序可以使用的副本。



6. 使用 const

使用 const 可以确保方法不修改参数；可以确保方法不修改调用它的对象；

可以使用 const 来确保引用或指针返回的值不能用于修改对象中的数据：
```c++
const Stock & Stock::topval(const Stock & s) const
{
	if (s.total_val > total_val)
        return s;
    else
        return *this;
}
```

该方法返回对 this 或 s 的引用，且因为 this 与 s 都被声明为 const ，所以函数不能对它们进行修改，同时意味着返回的引用也必须被声明为 const 。

如果函数将参数声明为指向 const 的引用或指针，则不能将该参数传递给另一个函数，除非后者也确保了参数不会被修改。



### 13.8.3 公有继承的考虑因素

1. is-a 关系

要遵循 is-a 关系。如果派生类不是一种特殊的基类，则不要使用公有派生。

在某些情况下，最好的方法可能是创建包含纯虚函数的抽象数据类，并从它派生出其他的类。

表示 is-a 关系的方式之一：

- 无需进行显式类型转换，基类指针就可以指向派生类对象，基类引用可以引用派生类对象。
- 反过来行不通，即不能在不进行显式类型转换的情况下，将派生类指针或引用指向基类对象。不安全。



2. 什么不能被继承

构造函数是不能继承的。

析构函数也是不能继承的。在释放对象时，程序将首先调用派生类的析构函数，然后调用基类的析构函数。通常对于基类，析构函数应该设置为虚函数。

赋值运算符是不能继承的。派生类继承的方法的特征标与基类完全相同，但赋值运算符的特征标随类而异，因为它包含一个类型为其所属类的形参。



3. 赋值运算符

如果编译器发现程序将一个对象赋给同一个类的另一个对象，它将自动为这个类提供一个赋值运算符。



4. 私有成员与保护成员

对派生类而言，保护成员类似于公有成员；但对于外部而言，保护成员与私有成员类似。

讲基类成员设置为私有的可以提高安全性，而将它们设置为保护成员则可简化代码的编写工作，并提高访问速度。

Stroustrup：使用私有数据成员比使用保护数据成员更好，但保护方法很有用。



5. 虚方法

设计基类时，必须确定是否将类方法声明为虚的。

如果希望派生类能够重新定义方法，则应在基类中将方法定义为虚的，这样可以启用晚期联编（动态联编）；

如果不希望重新定义方法，则不必将其声明为虚的；



6. 析构函数

基类的析构函数应当是虚的。

这样，当通过指向对象的基类指针或引用来删除派生类对象时，程序将首先调用派生类的析构函数，然后调用基类的析构函数，而不仅仅是调用基类的析构函数。



7. 友元函数

由于友元函数并非类成员，因此不能继承。

然而，可以通过强制类型转换，将派生类引用或指针转换为基类引用或指针，然后使用转换后的指针或引用来调用基类的友元函数。



8. 有关使用基类方法的说明

以公有方式派生的类的对象可以通过多种方式来使用基类的方法。

- 派生类对象自动使用继承而来的基类方法，如果派生类没有重新定义该方法。
- 派生类的构造函数自动调用基类的构造函数。
- 派生类的构造函数自动调用基类的默认构造函数，如果没有在成员初始化列表中指定其他构造函数。
- 派生类构造函数显式地调用成员初始化列表中指定的基类构造函数。
- 派生类方法可以使用作用域解析运算符来调用公有的和受保护的基类方法。
- 派生类的友元函数可以通过强制类型转换，将派生类引用或指针转换为基类引用或指针，然后使用该引用或指针来调用基类的友元函数。

PS：今天，2024年01月26日，农历腊月十六，是我的生日，哈哈哈哈，太开心啦



### 13.8.4 类函数小节

C++类函数有很多不同的变体，其中有些可以继承，有些不可以。

参考下表，其中 op= 表示诸如 += 、*= 等格式的赋值运算符。


|    函数    | 能否继承 | 成员还是友元 | 默认能否生成 | 能否为虚函数 | 是否可以有返回类型 |
| :--------: | :------: | :----------: | :----------: | :----------: | :----------------: |
|  构造函数  |    否    |     成员     |      能      |      否      |         否         |
|  析构函数  |    否    |     成员     |      能      |      能      |         否         |
|     =      |    否    |     成员     |      能      |      能      |         能         |
|     &      |    能    |     任意     |      能      |      能      |         能         |
|  转换函数  |    能    |     成员     |      否      |      能      |         否         |
|     ()     |    能    |     成员     |      否      |      能      |         能         |
|     []     |    能    |     成员     |      否      |      能      |         能         |
|     ->     |    能    |     成员     |      否      |      能      |         能         |
|    op=     |    能    |     任意     |      否      |      能      |         能         |
|    new     |    能    |   静态成员   |      否      |      否      |       void*        |
|   delete   |    能    |   静态成员   |      否      |      否      |        void        |
| 其他运算符 |    能    |     任意     |      否      |      能      |         能         |
|  其他成员  |    能    |     成员     |      否      |      能      |         能         |
|    友元    |    否    |     友元     |      否      |      否      |         能         |



# 14 C++ 中的代码重用

## 14.1 包含对象成员的类

### 14.1.1 valarray 类简介

valarray 类，包含在头文件 <valarray> 中，参考链接：[valarray](https://zh.cppreference.com/w/cpp/numeric/valarray)

支持将数组中所有元素的值相加以及在数组中找出最大和最小的值等操作。

valarray 是一个模板类，便于处理不同的数据类型。在声明对象时，必须指定具体的数据类型。

```c++
// int数组
valarray<int> q_values;

// double数组
valarray<double> weights;
```

构造函数使用方法举例

```c++
double gpa[5] = {3.1, 3.5, 3.8, 2.9, 3.3};

// 一个空的double类型数组
valarray<double> v1;

// 拥有8个元素的int类型数组
valarray<int> v2(8);

// 拥有8个元素的int类型数组，均被初始化为10
valarray<int> v3(10, 8);

// 拥有4个元素的double类型数组，被初始化为gpa数组前四个元素值
valarray<double> v4(gpa, 4);

// C++11可以使用初始化列表
valarray<int> v5 = {20, 32, 17, 9};
```

类方法举例

- `operator[]()`：可以直接访问各个元素；
- `size()`：返回包含的元素数；
- `sum()`：返回所有元素的总和；
- `max()`：返回最大的元素；
- `min()`：返回最小的元素；

### 14.1.2 **Student**类的设计

学生不是姓名，也不是一组考试成绩。这里的关系是 has-a ，学生有姓名，也有一组考试分数。通常，用于建立 has-a 关系的 C++ 技术是组合（包含），即创建一个包含其他类对象的类。

> **接口和实现**
>
> 使用公有继承时，类可以继承接口，可能还有实现（基类的纯虚函数提供接口，但不提供实现）。获得接口是 is-a 关系的组成部分。而使用组合，类可以获得实现，但不能获得接口。不继承接口是 has-a 关系的组成部分。

### **14.1.3 Student**类示例

代码参考对应小节练习代码。



> **C++和约束**
>
> C++包含让程序员能够限制程序结构的特性——使用 explicit 防止单参数构造函数的隐式转换，使用 const 限制方法修改数据，等等。这样做的根本原因是：在编译阶段出现错误优于在运行阶段出现错误。



**初始化顺序**

当初始化列表包含多个项目时，这些项目被初始化的顺序为它们被声明的顺序，而不是它们在初始化列表中的顺序。例如，假设 Student 构造函数如下：

```c++
Student(const char * str, const double * pd, int n)
	: scores(pd, n), name(str) {}
```

则 name 成员仍将首先被初始化，因为在类定义中它首先被声明。对于这个例子来说，初始化顺序并不重要，但如果代码使用一个成员的值作为另一个成员的初始化表达式的一部分时，初始化顺序就非常重要了。



## 14.2 私有继承

使用私有继承，基类的公有成员和保护成员都将成为派生类的私有成员。这意味着基类方法将不会成为派生对象公有接口的一部分，但可以在派生类的成员函数中使用它们。

省略关键字则默认为私有继承，private 是默认值，因此省略访问限定符也将导致私有继承。



### 14.2.2 使用包含还是私有继承

大部分首选使用包含

- 易于理解；
- 继承会引起很多问题，尤其从多个基类继承时，可能必须处理很多问题，如包含同名方法的独立的基类或共享祖先的独立基类；
- 包含能够包括多个同类的子对象。如果使用继承 string 类对象，则只能有一个对象，但使用包含，则可以使用多个；

另一种需要使用私有继承的情况是需要重新定义虚函数。派生类可以重新定义虚函数，但包含类不能。使用私有继承，重新定义的函数将只能在类中使用，而不是公有的。

> **提示：**
>
> 通常，应使用包含来建立has-a关系；如果新类需要访问原有类的保护成员，或需要重新定义虚函数，则应使用私有继承。



### 14.2.3 保护继承

保护继承，使用关键字 protected 。下表为各种继承方式：

|       特征       |       公有继承       |        保护继承        |       私有继承       |
| :--------------: | :------------------: | :--------------------: | :------------------: |
|   公有成员变量   |   派生类的公有成员   |    派生类的保护成员    |   派生类的私有成员   |
|   保护成员变量   |   派生类的保护成员   |    派生类的保护成员    |   派生类的私有成员   |
|   私有成员变量   | 只能通过基类接口访问 |  只能通过基类接口访问  | 只能通过基类接口访问 |
| 能否隐式向上转换 |          是          | 是（但只能在派生类中） |          否          |



### 14.2.4 使用**using**重新定义访问权限

设要让基类的方法在派生类外面可用，方法之一是定义一个使用该基类方法的派生类方法。

PS：基本像是把基类方法（STL标准库/其他自定义基类私有/保护方法），重新封装对外接口；



第二种方法，使用 using ，但 using 声明只适用于继承，并不适用于包含。

```c++
class Student : private std::string, private std::valarray<double>
{
public:
    using std::valarray<double>::min;
    using std::valarray<double>::max;
}
```



## 14.3 多重继承



### 14.3.1 有多少 Worker

此时如果从 Singer 和 Waiter 公有派生出 SingingWaiter ，如下

```c++
class SiingingWaiter : public Singer, public Waiter
{
    
};
```

因为 Singer 和 Waiter 都继承自 Worker ，因此 SingingWaiter 将包含两个 Worker 组件。

如果将派生类对象的地址赋给基类指针，将出现二义性：

```C++
SingingWaiter ed;
Worker * pw = &ed; // 不知道是Singer还是Waiter的指针
```

此时应该使用类型转换来指定对象：

```c++
Worker * pw1 = (Waiter *) &ed;
Worker * pw2 = (Singer *) &ed;
```



1. 虚基类

虚基类使得从多个类（它们的基类相同）派生出的对象只继承一个基类对象。例如，通过在类声明中使用关键字 virtual ，可以使 Worker 被用作 Singer 和 Waiter 的虚基类（ virtual 和 public 的次序无关紧要）：

```c++
// 虚基类
class Singer : virtual public Worker
{
    
};

// 虚基类，与顺序无关
class Waiter : public virtual Worker
{
    
};

class SiingingWaiter : public Singer, public Waiter
{
    
};
```

SingingWaiter 对象将只包含 Worker 对象的一个副本。从本质上说，继承的 Singer 和 Waiter 对象共享一个 Worker 对象，而不是各自引入自己的 Worker 对象副本。因为 SingingWaiter 现在只包含了一个 Worker 子对象，所以可以使用多态。



为什么使用术语虚？

毕竟，在虚函数和虚基类之间并不存在明显的联系。C++ 用户强烈反对引入新的关键字，因为这将给他们带来很大的压力。例如，如果新关键字与重要程序中的重要函数或变量的名称相同，这将非常麻烦。因此，C++ 对这种新特性也使用关键字 virtual ——有点像关键字重载。



为什么不抛弃将基类声明为虚的这种方式，而使虚行为成为 MI 的准则呢？

第一，在一些情况下，可能需要基类的多个拷贝；

第二，将基类作为虚的要求程序完成额外的计算，为不需要的工具付出代价是不应当的；

第三，这样做有其缺点；



是否存在麻烦？

是的。为使虚基类能够工作，需要对 C++ 规则进行调整，必须以不同的方式编写一些代码。另外，使用虚基类还可能需要修改已有的代码。例如，将 SingingWaiter 类添加到 Worker 集成层次中时，需要在 Singer 和 Waiter 类中添加关键字 virtual 。



2. 新的构造函数规则

如果 Worker 是虚基类，构造函数默认的信息传递是无效的，如下

```c++
SingingWaiter(const Worker & wk, int p = 0, int v = Singer::other)
    : Waiter(wk, p), Singer(wk, v)
{
        
}
```

此时，如果需要自动传递信息给基类，将通过两条不同的途径（Waiter / Singer）将 wk 传递给 Worker 对象。

因此为了避免冲突，C++ 在基类是虚的时，禁止信息通过中间类自动传递给基类。

但编译器必须在构造派生对象之前构造基类对象组件，此时编译器将使用 Worker 的默认构造函数。

如果不想用默认的，则需要显式地调用所需的基类构造函数

```c++
SingingWaiter(const Worker & wk, int p = 0, int v = Singer::other)
    : Worker(wk), Waiter(wk, p), Singer(wk, v)
{
        
}
```

如上代码将显式的调用构造函数 worker (const Worker &)。此时这种用法是合法的，对于虚基类，必须这样做；但对于非虚基类，则是非法的。



### 14.3.2 哪个方法











